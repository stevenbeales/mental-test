<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>module AST::Processor::Mixin - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/jquery.js"></script>
<script src="../../js/darkfish.js"></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="module">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    
    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-i-handler_missing">#handler_missing</a>
    
    <li ><a href="#method-i-process">#process</a>
    
    <li ><a href="#method-i-process_all">#process_all</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="module-AST::Processor::Mixin">
  <h1 id="module-AST::Processor::Mixin" class="module">
    module AST::Processor::Mixin
  </h1>

  <section class="description">
    
<p>The processor module is a module which helps transforming one <a
href="../../AST.html">AST</a> into another.  In a nutshell, the {#process}
method accepts a {Node} and dispatches it to a handler corresponding to its
type, and returns a (possibly) updated variant of the node.</p>

<p>The processor module has a set of associated design patterns. They are best
explained with a concrete example. Let&#39;s define a simple arithmetic
language and an <a href="../../AST.html">AST</a> format for it:</p>

<p>Terminals (AST nodes which do not have other <a
href="../../AST.html">AST</a> nodes inside):</p>

<pre>* `(integer &lt;int-literal&gt;)`,</pre>

<p>Nonterminals (AST nodes with other nodes as children):</p>

<pre>* `(add &lt;node&gt; &lt;node&gt;)`,
* `(multiply &lt;node&gt; &lt;node&gt;)`,
* `(divide &lt;node&gt; &lt;node&gt;)`,
* `(negate &lt;node&gt;)`,
* `(store &lt;node&gt; &lt;string-literal&gt;)`: stores value of `&lt;node&gt;`
  into a variable named `&lt;string-literal&gt;`,
* `(load &lt;string-literal&gt;)`: loads value of a variable named
  `&lt;string-literal&gt;`,
* `(each &lt;node&gt; ...): computes each of the `&lt;node&gt;`s and
  prints the result.</pre>

<p>All <a href="../../AST.html">AST</a> nodes have the same Ruby class, and
therefore they don&#39;t know how to traverse themselves. (A solution which
dynamically checks the type of children is possible, but is slow and
error-prone.) So, a class including the module which knows how to traverse
the entire tree should be defined.  Such classes have a handler for each
nonterminal node which recursively processes children nodes:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;ast&#39;</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">ArithmeticsProcessor</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">Processor</span><span class="ruby-operator">::</span><span class="ruby-constant">Mixin</span>
  <span class="ruby-comment"># This method traverses any binary operators such as (add)</span>
  <span class="ruby-comment"># or (multiply).</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">process_binary_op</span>(<span class="ruby-identifier">node</span>)
    <span class="ruby-comment"># Children aren&#39;t decomposed automatically; it is</span>
    <span class="ruby-comment"># suggested to use Ruby multiple assignment expansion,</span>
    <span class="ruby-comment"># as it is very convenient here.</span>
    <span class="ruby-identifier">left_expr</span>, <span class="ruby-identifier">right_expr</span> = <span class="ruby-operator">*</span><span class="ruby-identifier">node</span>

    <span class="ruby-comment"># AST::Node#updated won&#39;t change node type if nil is</span>
    <span class="ruby-comment"># passed as a first argument, which allows to reuse the</span>
    <span class="ruby-comment"># same handler for multiple node types using `alias&#39;</span>
    <span class="ruby-comment"># (below).</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">updated</span>(<span class="ruby-keyword">nil</span>, [
      <span class="ruby-identifier">process</span>(<span class="ruby-identifier">left_expr</span>),
      <span class="ruby-identifier">process</span>(<span class="ruby-identifier">right_expr</span>)
    ])
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">alias_method</span> :<span class="ruby-identifier">on_add</span>,      :<span class="ruby-identifier">process_binary_op</span>
  <span class="ruby-identifier">alias_method</span> :<span class="ruby-identifier">on_multiply</span>, :<span class="ruby-identifier">process_binary_op</span>
  <span class="ruby-identifier">alias_method</span> :<span class="ruby-identifier">on_divide</span>,   :<span class="ruby-identifier">process_binary_op</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">on_negate</span>(<span class="ruby-identifier">node</span>)
    <span class="ruby-comment"># It is also possible to use #process_all for more</span>
    <span class="ruby-comment"># compact code if every child is a Node.</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">updated</span>(<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">process_all</span>(<span class="ruby-identifier">node</span>))
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">on_store</span>(<span class="ruby-identifier">node</span>)
    <span class="ruby-identifier">expr</span>, <span class="ruby-identifier">variable_name</span> = <span class="ruby-operator">*</span><span class="ruby-identifier">node</span>

    <span class="ruby-comment"># Note that variable_name is not a Node and thus isn&#39;t</span>
    <span class="ruby-comment"># passed to #process.</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">updated</span>(<span class="ruby-keyword">nil</span>, [
      <span class="ruby-identifier">process</span>(<span class="ruby-identifier">expr</span>),
      <span class="ruby-identifier">variable_name</span>
    ])
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># (load) is effectively a terminal node, and so it does</span>
  <span class="ruby-comment"># not need an explicit handler, as the following is the</span>
  <span class="ruby-comment"># default behavior.  Essentially, for any nodes that don&#39;t</span>
  <span class="ruby-comment"># have a defined handler, the node remains unchanged.</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">on_load</span>(<span class="ruby-identifier">node</span>)
    <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">on_each</span>(<span class="ruby-identifier">node</span>)
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">updated</span>(<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">process_all</span>(<span class="ruby-identifier">node</span>))
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Let&#39;s test our ArithmeticsProcessor:</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">Sexp</span>
<span class="ruby-identifier">expr</span> = <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">add</span>, <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">integer</span>, <span class="ruby-value">2</span>), <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">integer</span>, <span class="ruby-value">2</span>))

<span class="ruby-identifier">p</span> <span class="ruby-constant">ArithmeticsProcessor</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">process</span>(<span class="ruby-identifier">expr</span>) <span class="ruby-operator">==</span> <span class="ruby-identifier">expr</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>As expected, it does not change anything at all. This isn&#39;t actually
very useful, so let&#39;s now define a Calculator, which will compute the
expression values:</p>

<pre class="ruby"><span class="ruby-comment"># This Processor folds nonterminal nodes and returns an</span>
<span class="ruby-comment"># (integer) terminal node.</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">ArithmeticsCalculator</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ArithmeticsProcessor</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">compute_op</span>(<span class="ruby-identifier">node</span>)
    <span class="ruby-comment"># First, node children are processed and then unpacked</span>
    <span class="ruby-comment"># to local variables.</span>
    <span class="ruby-identifier">nodes</span> = <span class="ruby-identifier">process_all</span>(<span class="ruby-identifier">node</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">all?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> :<span class="ruby-identifier">integer</span> }
      <span class="ruby-comment"># If each of those nodes represents a literal, we can</span>
      <span class="ruby-comment"># fold this node!</span>
      <span class="ruby-identifier">values</span> = <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">children</span>.<span class="ruby-identifier">first</span> }
      <span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">integer</span>, [
        <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">values</span>)
      ])
    <span class="ruby-keyword">else</span>
      <span class="ruby-comment"># Otherwise, we can just leave the current node in the</span>
      <span class="ruby-comment"># tree and only update it with processed children</span>
      <span class="ruby-comment"># nodes, which can be partially folded.</span>
      <span class="ruby-identifier">node</span>.<span class="ruby-identifier">updated</span>(<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">nodes</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">on_add</span>(<span class="ruby-identifier">node</span>)
    <span class="ruby-identifier">compute_op</span>(<span class="ruby-identifier">node</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">left</span>, <span class="ruby-identifier">right</span><span class="ruby-operator">|</span> <span class="ruby-identifier">left</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">right</span> }
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">on_multiply</span>(<span class="ruby-identifier">node</span>)
    <span class="ruby-identifier">compute_op</span>(<span class="ruby-identifier">node</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">left</span>, <span class="ruby-identifier">right</span><span class="ruby-operator">|</span> <span class="ruby-identifier">left</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">right</span> }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Let&#39;s check:</p>

<pre class="ruby"><span class="ruby-identifier">p</span> <span class="ruby-constant">ArithmeticsCalculator</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">process</span>(<span class="ruby-identifier">expr</span>) <span class="ruby-comment"># =&gt; (integer 4)</span>
</pre>

<p>Excellent, the calculator works! Now, a careful reader could notice that
the ArithmeticsCalculator does not know how to divide numbers. What if we
pass an expression with division to it?</p>

<pre class="ruby"><span class="ruby-identifier">expr_with_division</span> =    <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">add</span>,
    <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">integer</span>, <span class="ruby-value">1</span>),
    <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">divide</span>,
      <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">add</span>, <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">integer</span>, <span class="ruby-value">8</span>), <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">integer</span>, <span class="ruby-value">4</span>)),
      <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">integer</span>, <span class="ruby-value">3</span>))) <span class="ruby-comment"># 1 + (8 + 4) / 3</span>

<span class="ruby-identifier">folded_expr_with_division</span> = <span class="ruby-constant">ArithmeticsCalculator</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">process</span>(<span class="ruby-identifier">expr_with_division</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">folded_expr_with_division</span>
<span class="ruby-comment"># =&gt; (add</span>
<span class="ruby-comment">#      (integer 1)</span>
<span class="ruby-comment">#      (divide</span>
<span class="ruby-comment">#        (integer 12)</span>
<span class="ruby-comment">#        (integer 3)))</span>
</pre>

<p>As you can see, the expression was folded <em>partially</em>: the inner
`(add)` node which could be computed was folded to `(integer 12)`, the
`(divide)` node is left as-is because there is no computing handler for it,
and the root `(add)` node was also left as it is because some of its
children were not literals.</p>

<p>Note that this partial folding is only possible because the <em>data</em>
format, i.e. the format in which the computed values of the nodes are
represented, is the same as the <a href="../../AST.html">AST</a> itself.</p>

<p>Let&#39;s extend our ArithmeticsCalculator class further.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ArithmeticsCalculator</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">on_divide</span>(<span class="ruby-identifier">node</span>)
    <span class="ruby-identifier">compute_op</span>(<span class="ruby-identifier">node</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">left</span>, <span class="ruby-identifier">right</span><span class="ruby-operator">|</span> <span class="ruby-identifier">left</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">right</span> }
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">on_negate</span>(<span class="ruby-identifier">node</span>)
    <span class="ruby-comment"># Note how #compute_op works regardless of the operator</span>
    <span class="ruby-comment"># arity.</span>
    <span class="ruby-identifier">compute_op</span>(<span class="ruby-identifier">node</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-operator">-</span><span class="ruby-identifier">value</span> }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Now, let&#39;s apply our renewed ArithmeticsCalculator to a partial result
of previous evaluation:</p>

<pre class="ruby"><span class="ruby-identifier">p</span> <span class="ruby-constant">ArithmeticsCalculator</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">process</span>(<span class="ruby-identifier">expr_with_division</span>) <span class="ruby-comment"># =&gt; (integer 5)</span>
</pre>

<p>Five! Excellent. This is also pretty much how CRuby 1.8 executed its
programs.</p>

<p>Now, let&#39;s do some automated bug searching. Division by zero is an
error, right? So if we could detect that someone has divided by zero before
the program is even run, that could save some debugging time.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">DivisionByZeroVerifier</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ArithmeticsProcessor</span>
  <span class="ruby-keyword">class</span> <span class="ruby-constant">VerificationFailure</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Exception</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">on_divide</span>(<span class="ruby-identifier">node</span>)
    <span class="ruby-comment"># You need to process the children to handle nested divisions</span>
    <span class="ruby-comment"># such as:</span>
    <span class="ruby-comment"># (divide</span>
    <span class="ruby-comment">#   (integer 1)</span>
    <span class="ruby-comment">#   (divide (integer 1) (integer 0))</span>
    <span class="ruby-identifier">left</span>, <span class="ruby-identifier">right</span> = <span class="ruby-identifier">process_all</span>(<span class="ruby-identifier">node</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">right</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> :<span class="ruby-identifier">integer</span> <span class="ruby-operator">&amp;&amp;</span>
       <span class="ruby-identifier">right</span>.<span class="ruby-identifier">children</span>.<span class="ruby-identifier">first</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-constant">VerificationFailure</span>, <span class="ruby-string">&quot;Ouch! This code divides by zero.&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">divides_by_zero?</span>(<span class="ruby-identifier">ast</span>)
    <span class="ruby-identifier">process</span>(<span class="ruby-identifier">ast</span>)
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">rescue</span> <span class="ruby-constant">VerificationFailure</span>
    <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">nice_expr</span> =    <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">divide</span>,
    <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">add</span>, <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">integer</span>, <span class="ruby-value">10</span>), <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">integer</span>, <span class="ruby-value">2</span>)),
    <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">integer</span>, <span class="ruby-value">4</span>))

<span class="ruby-identifier">p</span> <span class="ruby-constant">DivisionByZeroVerifier</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">divides_by_zero?</span>(<span class="ruby-identifier">nice_expr</span>)
<span class="ruby-comment"># =&gt; false. Good.</span>

<span class="ruby-identifier">bad_expr</span> =    <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">add</span>, <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">integer</span>, <span class="ruby-value">10</span>),
    <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">divide</span>, <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">integer</span>, <span class="ruby-value">1</span>), <span class="ruby-identifier">s</span>(:<span class="ruby-identifier">integer</span>, <span class="ruby-value">0</span>)))

<span class="ruby-identifier">p</span> <span class="ruby-constant">DivisionByZeroVerifier</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">divides_by_zero?</span>(<span class="ruby-identifier">bad_expr</span>)
<span class="ruby-comment"># =&gt; true. WHOOPS. DO NOT RUN THIS.</span>
</pre>

<p>Of course, this won&#39;t detect more complex casesâ€¦ unless you use some
partial evaluation before! The possibilites are endless. Have fun.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-handler_missing" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">handler_missing</span><span
            class="method-args">(node)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Default handler. Does nothing.</p>

<p>@param  [AST::Node] node @return [AST::Node, nil]</p>
          
          

          
          <div class="method-source-code" id="handler_missing-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/ast-2.4.0/lib/ast/processor/mixin.rb, line 284</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">handler_missing</span>(<span class="ruby-identifier">node</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-process" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">process</span><span
            class="method-args">(node)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Dispatches `node`. If a node has type `:foo`, then a handler named `on_foo`
is invoked with one argument, the `node`; if there isn&#39;t such a
handler, {#handler_missing} is invoked with the same argument.</p>

<p>If the handler returns `nil`, `node` is returned; otherwise, the return
value of the handler is passed along.</p>

<p>@param  [AST::Node, nil] node @return [AST::Node, nil]</p>
          
          

          
          <div class="method-source-code" id="process-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/ast-2.4.0/lib/ast/processor/mixin.rb, line 251</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">process</span>(<span class="ruby-identifier">node</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">nil?</span>

  <span class="ruby-identifier">node</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">to_ast</span>

  <span class="ruby-comment"># Invoke a specific handler</span>
  <span class="ruby-identifier">on_handler</span> = <span class="ruby-value">:&quot;on_#{node.type}&quot;</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">respond_to?</span> <span class="ruby-identifier">on_handler</span>
    <span class="ruby-identifier">new_node</span> = <span class="ruby-identifier">send</span> <span class="ruby-identifier">on_handler</span>, <span class="ruby-identifier">node</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">new_node</span> = <span class="ruby-identifier">handler_missing</span>(<span class="ruby-identifier">node</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">node</span> = <span class="ruby-identifier">new_node</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">new_node</span>

  <span class="ruby-identifier">node</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-process_all" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">process_all</span><span
            class="method-args">(nodes)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>{#process}es each node from `nodes` and returns an array of results.</p>

<p>@param  [Array&lt;AST::Node&gt;] nodes @return [Array&lt;AST::Node&gt;]</p>
          
          

          
          <div class="method-source-code" id="process_all-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/ast-2.4.0/lib/ast/processor/mixin.rb, line 274</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">process_all</span>(<span class="ruby-identifier">nodes</span>)
  <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">to_a</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">process</span> <span class="ruby-identifier">node</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://rdoc.github.io/rdoc">RDoc</a> 5.0.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

