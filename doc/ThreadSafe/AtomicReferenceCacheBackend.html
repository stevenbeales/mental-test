<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class ThreadSafe::AtomicReferenceCacheBackend - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
  var index_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/darkfish.js"></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link"><a href="../Object.html">Object</a>
  
</div>

    
    <div id="extends-section" class="nav-section">
  <h3>Extended With Modules</h3>

  <ul class="link-list">
    
  
    <li><a class="extend" href="Util/Volatile.html">ThreadSafe::Util::Volatile</a>
  
  
  </ul>
</div>

    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li class="calls-super" ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-i-5B-5D">#[]</a>
    
    <li ><a href="#method-i-5B-5D-3D">#[]=</a>
    
    <li ><a href="#method-i-clear">#clear</a>
    
    <li ><a href="#method-i-compute">#compute</a>
    
    <li ><a href="#method-i-compute_if_absent">#compute_if_absent</a>
    
    <li ><a href="#method-i-compute_if_present">#compute_if_present</a>
    
    <li ><a href="#method-i-delete">#delete</a>
    
    <li ><a href="#method-i-delete_pair">#delete_pair</a>
    
    <li ><a href="#method-i-each_pair">#each_pair</a>
    
    <li ><a href="#method-i-empty-3F">#empty?</a>
    
    <li ><a href="#method-i-get_and_set">#get_and_set</a>
    
    <li ><a href="#method-i-get_or_default">#get_or_default</a>
    
    <li ><a href="#method-i-key-3F">#key?</a>
    
    <li ><a href="#method-i-merge_pair">#merge_pair</a>
    
    <li ><a href="#method-i-replace_if_exists">#replace_if_exists</a>
    
    <li ><a href="#method-i-replace_pair">#replace_pair</a>
    
    <li ><a href="#method-i-size">#size</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-ThreadSafe::AtomicReferenceCacheBackend">
  <h1 id="class-ThreadSafe::AtomicReferenceCacheBackend" class="class">
    class ThreadSafe::AtomicReferenceCacheBackend
  </h1>

  <section class="description">
    
<p>A Ruby port of the Doug Lea&#39;s jsr166e.ConcurrentHashMapV8 class version
1.59 available in public domain.</p>

<p>Original source code available here: <a
href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/ConcurrentHashMapV8.java?revision=1.59">gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/ConcurrentHashMapV8.java?revision=1.59</a></p>

<p>The Ruby port skips out the <code>TreeBin</code> (red-black trees for use
in bins whose size exceeds a threshold).</p>

<p>A hash table supporting full concurrency of retrievals and high expected
concurrency for updates. However, even though all operations are
thread-safe, retrieval operations do <em>not</em> entail locking, and there
is <em>not</em> any support for locking the entire table in a way that
prevents all access.</p>

<p>Retrieval operations generally do not block, so may overlap with update
operations. Retrievals reflect the results of the most recently
<em>completed</em> update operations holding upon their onset. (More
formally, an update operation for a given key bears a
<em>happens-before</em> relation with any (non <code>nil</code>) retrieval
for that key reporting the updated value.) For aggregate operations such as
+clear()+, concurrent retrievals may reflect insertion or removal of only
some entries. Similarly, the <code>each_pair</code> iterator yields
elements reflecting the state of the hash table at some point at or since
the start of the <code>each_pair</code>. Bear in mind that the results of
aggregate status methods including +size()+ and <code>empty?</code>} are
typically useful only when a map is not undergoing concurrent updates in
other threads. Otherwise the results of these methods reflect transient
states that may be adequate for monitoring or estimation purposes, but not
for program control.</p>

<p>The table is dynamically expanded when there are too many collisions (i.e.,
keys that have distinct hash codes but fall into the same slot modulo the
table size), with the expected average effect of maintaining roughly two
bins per mapping (corresponding to a 0.75 load factor threshold for
resizing). There may be much variance around this average as mappings are
added and removed, but overall, this maintains a commonly accepted
time/space tradeoff for hash tables. However, resizing this or any other
kind of hash table may be a relatively slow operation. When possible, it is
a good idea to provide a size estimate as an optional :initial_capacity
initializer argument. An additional optional :load_factor constructor
argument provides a further means of customizing initial table capacity by
specifying the table density to be used in calculating the amount of space
to allocate for the given number of elements. Note that using many keys
with exactly the same <code>hash</code> is a sure way to slow down
performance of any hash table.</p>

<p>## Design overview</p>

<p>The primary design goal of this hash table is to maintain concurrent
readability (typically method +[]+, but also iteration and related methods)
while minimizing update contention. Secondary goals are to keep space
consumption about the same or better than plain <code>Hash</code>, and to
support high initial insertion rates on an empty table by many threads.</p>

<p>Each key-value mapping is held in a <code>Node</code>. The validation-based
approach explained below leads to a lot of code sprawl because
retry-control precludes factoring into smaller methods.</p>

<p>The table is lazily initialized to a power-of-two size upon the first
insertion. Each bin in the table normally contains a list of +Node+s (most
often, the list has only zero or one <code>Node</code>). <a
href="AtomicReferenceCacheBackend/Table.html">Table</a> accesses require
volatile/atomic reads, writes, and CASes. The lists of nodes within bins
are always accurately traversable under volatile reads, so long as lookups
check hash code and non-nullness of value before checking key equality.</p>

<p>We use the top two bits of <code>Node</code> hash fields for control
purposes â€“ they are available anyway because of addressing constraints. As
explained further below, these top bits are used as follows:</p>

<pre>- 00 - Normal
- 01 - Locked
- 11 - Locked and may have a thread waiting for lock
- 10 - +Node+ is a forwarding node</pre>

<p>The lower 28 bits of each <code>Node</code>&#39;s hash field contain a the
key&#39;s hash code, except for forwarding nodes, for which the lower bits
are zero (and so always have hash field == <code>MOVED</code>).</p>

<p>Insertion (via +[]=+ or its variants) of the first node in an empty bin is
performed by just CASing it to the bin. This is by far the most common case
for put operations under most key/hash distributions. Other update
operations (insert, delete, and replace) require locks. We do not want to
waste the space required to associate a distinct lock object with each bin,
so instead use the first node of a bin list itself as a lock. Blocking
support for these locks relies +Util::CheapLockable. However, we also need
a <code>try_lock</code> construction, so we overlay these by using bits of
the <code>Node</code> hash field for lock control (see above), and so
normally use builtin monitors only for blocking and signalling using
<code>cheap_wait</code>/<code>cheap_broadcast</code> constructions. See
+Node#try_await_lock+.</p>

<p>Using the first node of a list as a lock does not by itself suffice though:
When a node is locked, any update must first validate that it is still the
first node after locking it, and retry if not. Because new nodes are always
appended to lists, once a node is first in a bin, it remains first until
deleted or the bin becomes invalidated (upon resizing). However, operations
that only conditionally update may inspect nodes until the point of update.
This is a converse of sorts to the lazy locking technique described by
Herlihy &amp; Shavit.</p>

<p>The main disadvantage of per-bin locks is that other update operations on
other nodes in a bin list protected by the same lock can stall, for example
when user <code>eql?</code> or mapping functions take a long time. However,
statistically, under random hash codes, this is not a common problem.
Ideally, the frequency of nodes in bins follows a Poisson distribution (<a
href="http://en.wikipedia.org/wiki/Poisson_distribution">en.wikipedia.org/wiki/Poisson_distribution</a>)
with a parameter of about 0.5 on average, given the resizing threshold of
0.75, although with a large variance because of resizing granularity.
Ignoring variance, the expected occurrences of list size k are (exp(-0.5) *
pow(0.5, k) / factorial(k)). The first values are:</p>

<pre>- 0:    0.60653066
- 1:    0.30326533
- 2:    0.07581633
- 3:    0.01263606
- 4:    0.00157952
- 5:    0.00015795
- 6:    0.00001316
- 7:    0.00000094
- 8:    0.00000006
- more: less than 1 in ten million</pre>

<p><a href="../Lock.html">Lock</a> contention probability for two threads
accessing distinct elements is roughly 1 / (8 * elements) under random
hashes.</p>

<p>The table is resized when occupancy exceeds a percentage threshold
(nominally, 0.75, but see below). Only a single thread performs the resize
(using field <code>size_control</code>, to arrange exclusion), but the
table otherwise remains usable for reads and updates. Resizing proceeds by
transferring bins, one by one, from the table to the next table. Because we
are using power-of-two expansion, the elements from each bin must either
stay at same index, or move with a power of two offset. We eliminate
unnecessary node creation by catching cases where old nodes can be reused
because their next fields won&#39;t change. On average, only about
one-sixth of them need cloning when a table doubles. The nodes they replace
will be garbage collectable as soon as they are no longer referenced by any
reader thread that may be in the midst of concurrently traversing table.
Upon transfer, the old table bin contains only a special forwarding node
(with hash field <code>MOVED</code>) that contains the next table as its
key. On encountering a forwarding node, access and update operations
restart, using the new table.</p>

<p>Each bin transfer requires its bin lock. However, unlike other cases, a
transfer can skip a bin if it fails to acquire its lock, and revisit it
later. <a href="../Method.html">Method</a> <code>rebuild</code> maintains a
buffer of <a
href="AtomicReferenceCacheBackend.html#TRANSFER_BUFFER_SIZE">TRANSFER_BUFFER_SIZE</a>
bins that have been skipped because of failure to acquire a lock, and
blocks only if none are available (i.e., only very rarely). The transfer
operation must also ensure that all accessible bins in both the old and new
table are usable by any traversal. When there are no lock acquisition
failures, this is arranged simply by proceeding from the last bin
(+table.size - 1+) up towards the first. Upon seeing a forwarding node,
traversals arrange to move to the new table without revisiting nodes.
However, when any node is skipped during a transfer, all earlier table bins
may have become visible, so are initialized with a reverse-forwarding node
back to the old table until the new ones are established. (This sometimes
requires transiently locking a forwarding node, which is possible under the
above encoding.) These more expensive mechanics trigger only when
necessary.</p>

<p>The traversal scheme also applies to partial traversals of ranges of bins
(via an alternate Traverser constructor) to support partitioned aggregate
operations.  Also, read-only operations give up if ever forwarded to a null
table, which provides support for shutdown-style clearing, which is also
not currently implemented.</p>

<p>Lazy table initialization minimizes footprint until first use.</p>

<p>The element count is maintained using a
<code>ThreadSafe::Util::Adder</code>, which avoids contention on updates
but can encounter cache thrashing if read too frequently during concurrent
access. To avoid reading so often, resizing is attempted either when a bin
lock is contended, or upon adding to a bin already holding two or more
nodes (checked before adding in the <code>x_if_absent</code> methods, after
adding in others). Under uniform hash distributions, the probability of
this occurring at threshold is around 13%, meaning that only about 1 in 8
puts check threshold (and after resizing, many fewer do so). But this
approximation has high variance for small table sizes, so we check on any
collision for sizes &lt;= 64. The bulk putAll operation further reduces
contention by only committing count updates upon these size checks.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="DEFAULT_CAPACITY">DEFAULT_CAPACITY
        
        <dd>
        
      
        <dt id="HASH_BITS">HASH_BITS
        
        <dd>
        
      
        <dt id="LOCKED">LOCKED
        
        <dd>
        
      
        <dt id="MAX_CAPACITY">MAX_CAPACITY
        
        <dd>
        
      
        <dt id="MOVED">MOVED
        
        <dd><p>shorthands</p>
        
      
        <dt id="NOW_RESIZING">NOW_RESIZING
        
        <dd>
        
      
        <dt id="TRANSFER_BUFFER_SIZE">TRANSFER_BUFFER_SIZE
        
        <dd><p>The buffer size for skipped bins during transfers. The value is arbitrary
but should be large enough to avoid most locking stalls during resizes.</p>
        
      
        <dt id="WAITING">WAITING
        
        <dd>
        
      
      </dl>
    </section>
    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">(options = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          
            <div class="method-calls-super">
              Calls superclass method
              <a href="../Object.html#method-c-new">Object.new</a>
            </div>
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 357</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">options</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">super</span>()
  <span class="ruby-ivar">@counter</span> = <span class="ruby-constant">Util</span><span class="ruby-operator">::</span><span class="ruby-constant">Adder</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">initial_capacity</span>  = <span class="ruby-identifier">options</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:initial_capacity</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">DEFAULT_CAPACITY</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">size_control</span> = (<span class="ruby-identifier">capacity</span> = <span class="ruby-identifier">table_size_for</span>(<span class="ruby-identifier">initial_capacity</span>)) <span class="ruby-operator">&gt;</span> <span class="ruby-constant">MAX_CAPACITY</span> <span class="ruby-operator">?</span> <span class="ruby-constant">MAX_CAPACITY</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">capacity</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-5B-5D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">[]</span><span
            class="method-args">(key)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="5B-5D-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 382</span>
<span class="ruby-keyword">def</span> <span class="ruby-operator">[]</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">get_or_default</span>(<span class="ruby-identifier">key</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-5B-5D-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">[]=</span><span
            class="method-args">(key, value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="5B-5D-3D-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 390</span>
<span class="ruby-keyword">def</span> <span class="ruby-operator">[]=</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">get_and_set</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">value</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-clear" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">clear</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Implementation for clear. Steps through each bin, removing all nodes.</p>
          
          

          
          <div class="method-source-code" id="clear-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 529</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">clear</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">current_table</span> = <span class="ruby-identifier">table</span>
  <span class="ruby-identifier">current_table_size</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-identifier">deleted_count</span> = <span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">current_table_size</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">node</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">volatile_get</span>(<span class="ruby-identifier">i</span>))
      <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">node_hash</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">hash</span>) <span class="ruby-operator">==</span> <span class="ruby-constant">MOVED</span>
      <span class="ruby-identifier">current_table</span>      = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>
      <span class="ruby-identifier">current_table_size</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">size</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-constant">Node</span>.<span class="ruby-identifier">locked_hash?</span>(<span class="ruby-identifier">node_hash</span>)
      <span class="ruby-identifier">decrement_size</span>(<span class="ruby-identifier">deleted_count</span>) <span class="ruby-comment"># opportunistically update count</span>
      <span class="ruby-identifier">deleted_count</span> = <span class="ruby-value">0</span>
      <span class="ruby-identifier">node</span>.<span class="ruby-identifier">try_await_lock</span>(<span class="ruby-identifier">current_table</span>, <span class="ruby-identifier">i</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">try_lock_via_hash</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">node_hash</span>) <span class="ruby-keyword">do</span>
        <span class="ruby-keyword">begin</span>
          <span class="ruby-identifier">deleted_count</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> <span class="ruby-keyword">if</span> <span class="ruby-constant">NULL</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span> <span class="ruby-comment"># recheck under lock</span>
          <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span> = <span class="ruby-keyword">nil</span>
        <span class="ruby-keyword">end</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">node</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">next</span>
        <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">volatile_set</span>(<span class="ruby-identifier">i</span>, <span class="ruby-keyword">nil</span>)
        <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">decrement_size</span>(<span class="ruby-identifier">deleted_count</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-compute" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">compute</span><span
            class="method-args">(key) { |NULL == old_value ? nil : old_value| ... }</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="compute-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 430</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">compute</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">internal_compute</span>(<span class="ruby-identifier">key</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">old_value</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">new_value</span> = <span class="ruby-keyword">yield</span>(<span class="ruby-constant">NULL</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">old_value</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">old_value</span>)).<span class="ruby-identifier">nil?</span>
      <span class="ruby-constant">NULL</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">new_value</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-compute_if_absent" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">compute_if_absent</span><span
            class="method-args">(key) { || ... }</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="compute_if_absent-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 395</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">compute_if_absent</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">hash</span>          = <span class="ruby-identifier">key_hash</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">current_table</span> = <span class="ruby-identifier">table</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">initialize_table</span>
  <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">node</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">volatile_get</span>(<span class="ruby-identifier">i</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">hash_to_index</span>(<span class="ruby-identifier">hash</span>)))
      <span class="ruby-identifier">succeeded</span>, <span class="ruby-identifier">new_value</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">try_to_cas_in_computed</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span>) { <span class="ruby-keyword">yield</span> }
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">succeeded</span>
        <span class="ruby-identifier">increment_size</span>
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">new_value</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">node_hash</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">hash</span>) <span class="ruby-operator">==</span> <span class="ruby-constant">MOVED</span>
      <span class="ruby-identifier">current_table</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-constant">NULL</span> <span class="ruby-operator">!=</span> (<span class="ruby-identifier">current_value</span> = <span class="ruby-identifier">find_value_in_node_list</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">key</span>, <span class="ruby-identifier">hash</span>, <span class="ruby-identifier">node_hash</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">HASH_BITS</span>))
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">current_value</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-constant">Node</span>.<span class="ruby-identifier">locked_hash?</span>(<span class="ruby-identifier">node_hash</span>)
      <span class="ruby-identifier">try_await_lock</span>(<span class="ruby-identifier">current_table</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">node</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">succeeded</span>, <span class="ruby-identifier">value</span> = <span class="ruby-identifier">attempt_internal_compute_if_absent</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">hash</span>, <span class="ruby-identifier">current_table</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">node_hash</span>) { <span class="ruby-keyword">yield</span> }
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">succeeded</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-compute_if_present" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">compute_if_present</span><span
            class="method-args">(key) { |NULL == old_value ? nil : old_value| ... }</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="compute_if_present-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 418</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">compute_if_present</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">new_value</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">internal_replace</span>(<span class="ruby-identifier">key</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">old_value</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">new_value</span> = <span class="ruby-keyword">yield</span>(<span class="ruby-constant">NULL</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">old_value</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">old_value</span>)).<span class="ruby-identifier">nil?</span>
      <span class="ruby-constant">NULL</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">new_value</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">new_value</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-delete" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">delete</span><span
            class="method-args">(key)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="delete-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 480</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">delete</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">replace_if_exists</span>(<span class="ruby-identifier">key</span>, <span class="ruby-constant">NULL</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-delete_pair" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">delete_pair</span><span
            class="method-args">(key, value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="delete_pair-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 484</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">delete_pair</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">result</span> = <span class="ruby-identifier">internal_replace</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>) { <span class="ruby-constant">NULL</span> }
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">result</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">NULL</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">result</span>
    <span class="ruby-operator">!</span><span class="ruby-operator">!</span><span class="ruby-identifier">result</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_pair" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">each_pair</span><span
            class="method-args">() { |key, value| ... }</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="each_pair-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 493</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_pair</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">current_table</span> = <span class="ruby-identifier">table</span>
  <span class="ruby-identifier">current_table_size</span> = <span class="ruby-identifier">base_size</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-identifier">i</span> = <span class="ruby-identifier">base_index</span> = <span class="ruby-value">0</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">base_index</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">base_size</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">node</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">volatile_get</span>(<span class="ruby-identifier">i</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">hash</span> <span class="ruby-operator">==</span> <span class="ruby-constant">MOVED</span>
        <span class="ruby-identifier">current_table</span>      = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>
        <span class="ruby-identifier">current_table_size</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">size</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">begin</span>
          <span class="ruby-keyword">if</span> <span class="ruby-constant">NULL</span> <span class="ruby-operator">!=</span> (<span class="ruby-identifier">value</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>) <span class="ruby-comment"># skip deleted or special nodes</span>
            <span class="ruby-keyword">yield</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">node</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">next</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i_with_base</span> = <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">base_size</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">current_table_size</span>
      <span class="ruby-identifier">i</span> = <span class="ruby-identifier">i_with_base</span> <span class="ruby-comment"># visit upper slots if present</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">i</span> = <span class="ruby-identifier">base_index</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-empty-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">empty?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="empty-3F-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 524</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">empty?</span>
  <span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-get_and_set" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_and_set</span><span
            class="method-args">(key, value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="get_and_set-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 460</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_and_set</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>) <span class="ruby-comment"># internalPut in the original CHMV8</span>
  <span class="ruby-identifier">hash</span>          = <span class="ruby-identifier">key_hash</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">current_table</span> = <span class="ruby-identifier">table</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">initialize_table</span>
  <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">node</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">volatile_get</span>(<span class="ruby-identifier">i</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">hash_to_index</span>(<span class="ruby-identifier">hash</span>)))
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">cas_new_node</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>)
        <span class="ruby-identifier">increment_size</span>
        <span class="ruby-keyword">break</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">node_hash</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">hash</span>) <span class="ruby-operator">==</span> <span class="ruby-constant">MOVED</span>
      <span class="ruby-identifier">current_table</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-constant">Node</span>.<span class="ruby-identifier">locked_hash?</span>(<span class="ruby-identifier">node_hash</span>)
      <span class="ruby-identifier">try_await_lock</span>(<span class="ruby-identifier">current_table</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">node</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">succeeded</span>, <span class="ruby-identifier">old_value</span> = <span class="ruby-identifier">attempt_get_and_set</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">hash</span>, <span class="ruby-identifier">current_table</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">node_hash</span>)
      <span class="ruby-keyword">break</span> <span class="ruby-identifier">old_value</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">succeeded</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-get_or_default" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_or_default</span><span
            class="method-args">(key, else_value = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="get_or_default-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 364</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_or_default</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">else_value</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">hash</span>          = <span class="ruby-identifier">key_hash</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">current_table</span> = <span class="ruby-identifier">table</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">current_table</span>
    <span class="ruby-identifier">node</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">volatile_get_by_hash</span>(<span class="ruby-identifier">hash</span>)
    <span class="ruby-identifier">current_table</span> =
      <span class="ruby-keyword">while</span> <span class="ruby-identifier">node</span>
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">node_hash</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">hash</span>) <span class="ruby-operator">==</span> <span class="ruby-constant">MOVED</span>
          <span class="ruby-keyword">break</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>
        <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">node_hash</span> <span class="ruby-operator">&amp;</span> <span class="ruby-constant">HASH_BITS</span>) <span class="ruby-operator">==</span> <span class="ruby-identifier">hash</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-identifier">key</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">NULL</span> <span class="ruby-operator">!=</span> (<span class="ruby-identifier">value</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>)
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">node</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">next</span>
      <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">else_value</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-key-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">key?</span><span
            class="method-args">(key)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="key-3F-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 386</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">key?</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">get_or_default</span>(<span class="ruby-identifier">key</span>, <span class="ruby-constant">NULL</span>) <span class="ruby-operator">!=</span> <span class="ruby-constant">NULL</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-merge_pair" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">merge_pair</span><span
            class="method-args">(key, value) { |old_value| ... }</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="merge_pair-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 440</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">merge_pair</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">internal_compute</span>(<span class="ruby-identifier">key</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">old_value</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-constant">NULL</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">old_value</span> <span class="ruby-operator">||</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">value</span> = <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">old_value</span>)).<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">value</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-constant">NULL</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-replace_if_exists" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">replace_if_exists</span><span
            class="method-args">(key, new_value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="replace_if_exists-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 454</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">replace_if_exists</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">new_value</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">result</span> = <span class="ruby-identifier">internal_replace</span>(<span class="ruby-identifier">key</span>) { <span class="ruby-identifier">new_value</span> }) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">NULL</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">result</span>
    <span class="ruby-identifier">result</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-replace_pair" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">replace_pair</span><span
            class="method-args">(key, old_value, new_value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="replace_pair-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 450</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">replace_pair</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span>)
  <span class="ruby-constant">NULL</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">internal_replace</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>) { <span class="ruby-identifier">new_value</span> }
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-size" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">size</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="size-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/thread_safe-0.3.6/lib/thread_safe/atomic_reference_cache_backend.rb, line 520</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">size</span>
  (<span class="ruby-identifier">sum</span> = <span class="ruby-ivar">@counter</span>.<span class="ruby-identifier">sum</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">?</span> <span class="ruby-value">0</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">sum</span> <span class="ruby-comment"># ignore transient negative values</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://rdoc.github.io/rdoc">RDoc</a> 5.0.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

