<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class PG::Connection - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
  var index_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/darkfish.js"></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">rb_cObject 
  
</div>

    <div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
  
  
    <li><span class="include">rb_mPGconstants</span>
  
  
  </ul>
</div>

    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-conndefaults">::conndefaults</a>
    
    <li ><a href="#method-c-conndefaults_hash">::conndefaults_hash</a>
    
    <li ><a href="#method-c-connect_start">::connect_start</a>
    
    <li ><a href="#method-c-encrypt_password">::encrypt_password</a>
    
    <li ><a href="#method-c-escape_bytea">::escape_bytea</a>
    
    <li ><a href="#method-c-escape_string">::escape_string</a>
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-c-parse_connect_args">::parse_connect_args</a>
    
    <li ><a href="#method-c-ping">::ping</a>
    
    <li ><a href="#method-c-quote_connstr">::quote_connstr</a>
    
    <li ><a href="#method-c-quote_ident">::quote_ident</a>
    
    <li ><a href="#method-c-unescape_bytea">::unescape_bytea</a>
    
    <li ><a href="#method-i-async_exec">#async_exec</a>
    
    <li ><a href="#method-i-async_query">#async_query</a>
    
    <li ><a href="#method-i-backend_pid">#backend_pid</a>
    
    <li ><a href="#method-i-block">#block</a>
    
    <li ><a href="#method-i-cancel">#cancel</a>
    
    <li ><a href="#method-i-client_encoding-3D">#client_encoding=</a>
    
    <li ><a href="#method-i-close">#close</a>
    
    <li ><a href="#method-i-conndefaults">#conndefaults</a>
    
    <li ><a href="#method-i-conndefaults_hash">#conndefaults_hash</a>
    
    <li ><a href="#method-i-connect_poll">#connect_poll</a>
    
    <li ><a href="#method-i-connection_needs_password">#connection_needs_password</a>
    
    <li ><a href="#method-i-connection_used_password">#connection_used_password</a>
    
    <li ><a href="#method-i-conninfo">#conninfo</a>
    
    <li ><a href="#method-i-conninfo_hash">#conninfo_hash</a>
    
    <li ><a href="#method-i-consume_input">#consume_input</a>
    
    <li ><a href="#method-i-copy_data">#copy_data</a>
    
    <li ><a href="#method-i-db">#db</a>
    
    <li ><a href="#method-i-decoder_for_get_copy_data">#decoder_for_get_copy_data</a>
    
    <li ><a href="#method-i-decoder_for_get_copy_data-3D">#decoder_for_get_copy_data=</a>
    
    <li ><a href="#method-i-describe_portal">#describe_portal</a>
    
    <li ><a href="#method-i-describe_prepared">#describe_prepared</a>
    
    <li ><a href="#method-i-encoder_for_put_copy_data">#encoder_for_put_copy_data</a>
    
    <li ><a href="#method-i-encoder_for_put_copy_data-3D">#encoder_for_put_copy_data=</a>
    
    <li ><a href="#method-i-encrypt_password">#encrypt_password</a>
    
    <li ><a href="#method-i-error_message">#error_message</a>
    
    <li ><a href="#method-i-escape">#escape</a>
    
    <li ><a href="#method-i-escape_bytea">#escape_bytea</a>
    
    <li ><a href="#method-i-escape_identifier">#escape_identifier</a>
    
    <li ><a href="#method-i-escape_literal">#escape_literal</a>
    
    <li ><a href="#method-i-escape_string">#escape_string</a>
    
    <li ><a href="#method-i-exec">#exec</a>
    
    <li ><a href="#method-i-exec_params">#exec_params</a>
    
    <li ><a href="#method-i-exec_prepared">#exec_prepared</a>
    
    <li ><a href="#method-i-external_encoding">#external_encoding</a>
    
    <li ><a href="#method-i-finish">#finish</a>
    
    <li ><a href="#method-i-finished-3F">#finished?</a>
    
    <li ><a href="#method-i-flush">#flush</a>
    
    <li ><a href="#method-i-get_client_encoding">#get_client_encoding</a>
    
    <li ><a href="#method-i-get_copy_data">#get_copy_data</a>
    
    <li ><a href="#method-i-get_last_result">#get_last_result</a>
    
    <li ><a href="#method-i-get_result">#get_result</a>
    
    <li ><a href="#method-i-host">#host</a>
    
    <li ><a href="#method-i-internal_encoding">#internal_encoding</a>
    
    <li ><a href="#method-i-internal_encoding-3D">#internal_encoding=</a>
    
    <li ><a href="#method-i-is_busy">#is_busy</a>
    
    <li ><a href="#method-i-isnonblocking">#isnonblocking</a>
    
    <li ><a href="#method-i-lo_close">#lo_close</a>
    
    <li ><a href="#method-i-lo_creat">#lo_creat</a>
    
    <li ><a href="#method-i-lo_create">#lo_create</a>
    
    <li ><a href="#method-i-lo_export">#lo_export</a>
    
    <li ><a href="#method-i-lo_import">#lo_import</a>
    
    <li ><a href="#method-i-lo_lseek">#lo_lseek</a>
    
    <li ><a href="#method-i-lo_open">#lo_open</a>
    
    <li ><a href="#method-i-lo_read">#lo_read</a>
    
    <li ><a href="#method-i-lo_seek">#lo_seek</a>
    
    <li ><a href="#method-i-lo_tell">#lo_tell</a>
    
    <li ><a href="#method-i-lo_truncate">#lo_truncate</a>
    
    <li ><a href="#method-i-lo_unlink">#lo_unlink</a>
    
    <li ><a href="#method-i-lo_write">#lo_write</a>
    
    <li ><a href="#method-i-loclose">#loclose</a>
    
    <li ><a href="#method-i-locreat">#locreat</a>
    
    <li ><a href="#method-i-locreate">#locreate</a>
    
    <li ><a href="#method-i-loexport">#loexport</a>
    
    <li ><a href="#method-i-loimport">#loimport</a>
    
    <li ><a href="#method-i-lolseek">#lolseek</a>
    
    <li ><a href="#method-i-loopen">#loopen</a>
    
    <li ><a href="#method-i-loread">#loread</a>
    
    <li ><a href="#method-i-loseek">#loseek</a>
    
    <li ><a href="#method-i-lotell">#lotell</a>
    
    <li ><a href="#method-i-lotruncate">#lotruncate</a>
    
    <li ><a href="#method-i-lounlink">#lounlink</a>
    
    <li ><a href="#method-i-lowrite">#lowrite</a>
    
    <li ><a href="#method-i-make_empty_pgresult">#make_empty_pgresult</a>
    
    <li ><a href="#method-i-nonblocking-3F">#nonblocking?</a>
    
    <li ><a href="#method-i-notifies">#notifies</a>
    
    <li ><a href="#method-i-notifies_wait">#notifies_wait</a>
    
    <li ><a href="#method-i-options">#options</a>
    
    <li ><a href="#method-i-parameter_status">#parameter_status</a>
    
    <li ><a href="#method-i-pass">#pass</a>
    
    <li ><a href="#method-i-port">#port</a>
    
    <li ><a href="#method-i-prepare">#prepare</a>
    
    <li ><a href="#method-i-protocol_version">#protocol_version</a>
    
    <li ><a href="#method-i-put_copy_data">#put_copy_data</a>
    
    <li ><a href="#method-i-put_copy_end">#put_copy_end</a>
    
    <li ><a href="#method-i-query">#query</a>
    
    <li ><a href="#method-i-quote_ident">#quote_ident</a>
    
    <li ><a href="#method-i-reset">#reset</a>
    
    <li ><a href="#method-i-reset_poll">#reset_poll</a>
    
    <li ><a href="#method-i-reset_start">#reset_start</a>
    
    <li ><a href="#method-i-send_describe_portal">#send_describe_portal</a>
    
    <li ><a href="#method-i-send_describe_prepared">#send_describe_prepared</a>
    
    <li ><a href="#method-i-send_prepare">#send_prepare</a>
    
    <li ><a href="#method-i-send_query">#send_query</a>
    
    <li ><a href="#method-i-send_query_prepared">#send_query_prepared</a>
    
    <li ><a href="#method-i-server_version">#server_version</a>
    
    <li ><a href="#method-i-set_client_encoding">#set_client_encoding</a>
    
    <li ><a href="#method-i-set_default_encoding">#set_default_encoding</a>
    
    <li ><a href="#method-i-set_error_verbosity">#set_error_verbosity</a>
    
    <li ><a href="#method-i-set_notice_processor">#set_notice_processor</a>
    
    <li ><a href="#method-i-set_notice_receiver">#set_notice_receiver</a>
    
    <li ><a href="#method-i-set_single_row_mode">#set_single_row_mode</a>
    
    <li ><a href="#method-i-setnonblocking">#setnonblocking</a>
    
    <li ><a href="#method-i-socket">#socket</a>
    
    <li ><a href="#method-i-socket_io">#socket_io</a>
    
    <li ><a href="#method-i-ssl_attribute">#ssl_attribute</a>
    
    <li ><a href="#method-i-ssl_attribute_names">#ssl_attribute_names</a>
    
    <li ><a href="#method-i-ssl_attributes">#ssl_attributes</a>
    
    <li ><a href="#method-i-ssl_in_use-3F">#ssl_in_use?</a>
    
    <li ><a href="#method-i-status">#status</a>
    
    <li ><a href="#method-i-trace">#trace</a>
    
    <li ><a href="#method-i-transaction">#transaction</a>
    
    <li ><a href="#method-i-transaction_status">#transaction_status</a>
    
    <li ><a href="#method-i-tty">#tty</a>
    
    <li ><a href="#method-i-type_map_for_queries">#type_map_for_queries</a>
    
    <li ><a href="#method-i-type_map_for_queries-3D">#type_map_for_queries=</a>
    
    <li ><a href="#method-i-type_map_for_results">#type_map_for_results</a>
    
    <li ><a href="#method-i-type_map_for_results-3D">#type_map_for_results=</a>
    
    <li ><a href="#method-i-unescape_bytea">#unescape_bytea</a>
    
    <li ><a href="#method-i-untrace">#untrace</a>
    
    <li ><a href="#method-i-user">#user</a>
    
    <li ><a href="#method-i-wait_for_notify">#wait_for_notify</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-PG::Connection">
  <h1 id="class-PG::Connection" class="class">
    class PG::Connection
  </h1>

  <section class="description">
    
<p>The PostgreSQL connection class. The interface for this class is based on
<a
href="http://www.postgresql.org/docs/9.2/interactive/libpq.html">libpq</a>,
the C application programmer&#39;s interface to PostgreSQL. Some
familiarity with libpq is recommended, but not necessary.</p>

<p>For example, to send query to the database on the localhost:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;pg&#39;</span>
<span class="ruby-identifier">conn</span> = <span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">Connection</span>.<span class="ruby-identifier">open</span>(:<span class="ruby-identifier">dbname</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;test&#39;</span>)
<span class="ruby-identifier">res</span> = <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">exec_params</span>(<span class="ruby-string">&#39;SELECT $1 AS a, $2 AS b, $3 AS c&#39;</span>, [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-keyword">nil</span>])
<span class="ruby-comment"># Equivalent to:</span>
<span class="ruby-comment">#  res  = conn.exec(&#39;SELECT 1 AS a, 2 AS b, NULL AS c&#39;)</span>
</pre>

<p>See the <a href="Result.html">PG::Result</a> class for information on
working with the results of a query.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="CONNECT_ARGUMENT_ORDER">CONNECT_ARGUMENT_ORDER
        
        <dd><p>The order the options are passed to the ::connect method.</p>
        
      
      </dl>
    </section>
    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-conndefaults" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.conndefaults() &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array of hashes. Each hash has the keys:</p>
<dl class="rdoc-list label-list"><dt><code>:keyword</code>
<dd>
<p>the name of the option</p>
</dd><dt><code>:envvar</code>
<dd>
<p>the environment variable to fall back to</p>
</dd><dt><code>:compiled</code>
<dd>
<p>the compiled in option as a secondary fallback</p>
</dd><dt><code>:val</code>
<dd>
<p>the option&#39;s current value, or <code>nil</code> if not known</p>
</dd><dt><code>:label</code>
<dd>
<p>the label for the field</p>
</dd><dt><code>:dispchar</code>
<dd>
<p>“” for normal, “D” for debug, and “*” for password</p>
</dd><dt><code>:dispsize</code>
<dd>
<p>field size</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="conndefaults-source">
            <pre>static VALUE
pgconn_s_conndefaults(VALUE self)
{
        PQconninfoOption *options = PQconndefaults();
        VALUE array = pgconn_make_conninfo_array( options );

        PQconninfoFree(options);

        UNUSED( self );

        return array;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-conndefaults_hash" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">conndefaults_hash</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Return the Postgres connection defaults structure as a <a
href="../Hash.html">Hash</a> keyed by option keyword (as a <a
href="../Symbol.html">Symbol</a>).</p>

<p>See also <a href="Connection.html#method-i-conndefaults">conndefaults</a></p>
          
          

          
          <div class="method-source-code" id="conndefaults_hash-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/pg-1.0.0-x64-mingw32/lib/pg/connection.rb, line 227</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">conndefaults_hash</span>
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">conndefaults</span>.<span class="ruby-identifier">each_with_object</span>({}) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">info</span>, <span class="ruby-identifier">hash</span><span class="ruby-operator">|</span>
                <span class="ruby-identifier">hash</span>[ <span class="ruby-identifier">info</span>[<span class="ruby-value">:keyword</span>].<span class="ruby-identifier">to_sym</span> ] = <span class="ruby-identifier">info</span>[<span class="ruby-value">:val</span>]
        <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-connect_start" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.connect_start(connection_hash)       &rarr; conn
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.connect_start(connection_string)     &rarr; conn
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.connect_start(host, port, options, tty, dbname, login, password) &rarr;  conn
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This is an asynchronous version of PG::Connection.connect().</p>

<p>Use <a href="Connection.html#method-i-connect_poll">connect_poll</a> to
poll the status of the connection.</p>

<p>NOTE: this does <strong>not</strong> set the connection&#39;s
<code>client_encoding</code> for you if Encoding.default_internal is set.
To set it after the connection is established, call <a
href="Connection.html#method-i-internal_encoding-3D">internal_encoding=</a>.
You can also set it automatically by setting <a
href="'PGCLIENTENCODING'">ENV</a>, or include the &#39;options&#39;
connection parameter.</p>
          
          

          
          <div class="method-source-code" id="connect_start-source">
            <pre>static VALUE
pgconn_s_connect_start( int argc, VALUE *argv, VALUE klass )
{
        VALUE rb_conn;
        VALUE conninfo;
        VALUE error;
        t_pg_connection *this;

        /*
         * PG::Connection.connect_start must act as both alloc() and initialize()
         * because it is not invoked by calling new().
         */
        rb_conn  = pgconn_s_allocate( klass );
        this = pg_get_connection( rb_conn );
        conninfo = rb_funcall2( klass, rb_intern(&quot;parse_connect_args&quot;), argc, argv );
        this-&gt;pgconn = gvl_PQconnectStart( StringValueCStr(conninfo) );

        if( this-&gt;pgconn == NULL )
                rb_raise(rb_ePGerror, &quot;PQconnectStart() unable to allocate structure&quot;);

        if ( PQstatus(this-&gt;pgconn) == CONNECTION_BAD ) {
                error = rb_exc_new2(rb_eConnectionBad, PQerrorMessage(this-&gt;pgconn));
                rb_iv_set(error, &quot;@connection&quot;, rb_conn);
                rb_exc_raise(error);
        }

        if ( rb_block_given_p() ) {
                return rb_ensure( rb_yield, rb_conn, pgconn_finish, rb_conn );
        }
        return rb_conn;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-encrypt_password" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.encrypt_password( password, username ) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This is an older, deprecated version of <a
href="Connection.html#method-i-encrypt_password">encrypt_password</a>. The
difference is that this function always uses <code>md5</code> as the
encryption algorithm.</p>
          
          

          
          <div class="method-source-code" id="encrypt_password-source">
            <pre>static VALUE
pgconn_s_encrypt_password(VALUE self, VALUE password, VALUE username)
{
        char *encrypted = NULL;
        VALUE rval = Qnil;

        UNUSED( self );

        Check_Type(password, T_STRING);
        Check_Type(username, T_STRING);

        encrypted = PQencryptPassword(StringValueCStr(password), StringValueCStr(username));
        rval = rb_str_new2( encrypted );
        PQfreemem( encrypted );

        OBJ_INFECT( rval, password );
        OBJ_INFECT( rval, username );

        return rval;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-escape_bytea" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            escape_bytea( string ) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Escapes binary data for use within an SQL command with the type
<code>bytea</code>.</p>

<p>Certain byte values must be escaped (but all byte values may be escaped)
when used as part of a <code>bytea</code> literal in an SQL statement. In
general, to escape a byte, it is converted into the three digit octal
number equal to the octet value, and preceded by two backslashes. The
single quote (&#39;) and backslash () characters have special alternative
escape sequences. <a
href="Connection.html#method-i-escape_bytea">escape_bytea</a> performs this
operation, escaping only the minimally required bytes.</p>

<p>Consider using <a
href="Connection.html#method-i-exec_params">#exec_params</a>, which avoids
the need for passing values inside of SQL commands.</p>

<p>NOTE: This class version of this method can only be used safely in client
programs that use a single PostgreSQL connection at a time (in this case it
can find out what it needs to know “behind the scenes”). It might give the
wrong results if used in programs that use multiple database connections;
use the same method on the connection object in such cases.</p>
          
          

          
          <div class="method-source-code" id="escape_bytea-source">
            <pre>static VALUE
pgconn_s_escape_bytea(VALUE self, VALUE str)
{
        unsigned char *from, *to;
        size_t from_len, to_len;
        VALUE ret;

        Check_Type(str, T_STRING);
        from      = (unsigned char*)RSTRING_PTR(str);
        from_len  = RSTRING_LEN(str);

        if ( rb_obj_is_kind_of(self, rb_cPGconn) ) {
                to = PQescapeByteaConn(pg_get_pgconn(self), from, from_len, &amp;to_len);
        } else {
                to = PQescapeBytea( from, from_len, &amp;to_len);
        }

        ret = rb_str_new((char*)to, to_len - 1);
        OBJ_INFECT(ret, str);
        PQfreemem(to);
        return ret;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-escape_string" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            escape_string( str ) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a SQL-safe version of the <a href="../String.html">String</a>
<em>str</em>. This is the preferred way to make strings safe for inclusion
in SQL queries.</p>

<p>Consider using <a
href="Connection.html#method-i-exec_params">#exec_params</a>, which avoids
the need for passing values inside of SQL commands.</p>

<p><a href="../Encoding.html">Encoding</a> of escaped string will be equal to
client encoding of connection.</p>

<p>NOTE: This class version of this method can only be used safely in client
programs that use a single PostgreSQL connection at a time (in this case it
can find out what it needs to know “behind the scenes”). It might give the
wrong results if used in programs that use multiple database connections;
use the same method on the connection object in such cases.</p>
          
          

          
          <div class="method-source-code" id="escape_string-source">
            <pre>static VALUE
pgconn_s_escape(VALUE self, VALUE string)
{
        size_t size;
        int error;
        VALUE result;
        int enc_idx;
        int singleton = !rb_obj_is_kind_of(self, rb_cPGconn);

        Check_Type(string, T_STRING);
        enc_idx = ENCODING_GET( singleton ? string : self );
        if( ENCODING_GET(string) != enc_idx ){
                string = rb_str_export_to_enc(string, rb_enc_from_index(enc_idx));
        }

        result = rb_str_new(NULL, RSTRING_LEN(string) * 2 + 1);
        PG_ENCODING_SET_NOCHECK(result, enc_idx);
        if( !singleton ) {
                size = PQescapeStringConn(pg_get_pgconn(self), RSTRING_PTR(result),
                        RSTRING_PTR(string), RSTRING_LEN(string), &amp;error);
                if(error) {
                        rb_raise(rb_ePGerror, &quot;%s&quot;, PQerrorMessage(pg_get_pgconn(self)));
                }
        } else {
                size = PQescapeString(RSTRING_PTR(result), RSTRING_PTR(string), RSTRING_LEN(string));
        }
        rb_str_set_len(result, size);
        OBJ_INFECT(result, string);

        return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-new" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.new &rarr; conn
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.new(connection_hash) &rarr; conn
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.new(connection_string) &rarr; conn
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.new(host, port, options, tty, dbname, user, password) &rarr;  conn
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Create a connection to the specified server.</p>
<dl class="rdoc-list label-list"><dt><code>host</code>
<dd>
<p>server hostname</p>
</dd><dt><code>hostaddr</code>
<dd>
<p>server address (avoids hostname lookup, overrides <code>host</code>)</p>
</dd><dt><code>port</code>
<dd>
<p>server port number</p>
</dd><dt><code>dbname</code>
<dd>
<p>connecting database name</p>
</dd><dt><code>user</code>
<dd>
<p>login user name</p>
</dd><dt><code>password</code>
<dd>
<p>login password</p>
</dd><dt><code>connect_timeout</code>
<dd>
<p>maximum time to wait for connection to succeed</p>
</dd><dt><code>options</code>
<dd>
<p>backend options</p>
</dd><dt><code>tty</code>
<dd>
<p>(ignored in newer versions of PostgreSQL)</p>
</dd><dt><code>sslmode</code>
<dd>
<p>(disable|allow|prefer|require)</p>
</dd><dt><code>krbsrvname</code>
<dd>
<p>kerberos service name</p>
</dd><dt><code>gsslib</code>
<dd>
<p>GSS library to use for GSSAPI authentication</p>
</dd><dt><code>service</code>
<dd>
<p>service name to use for additional parameters</p>
</dd></dl>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-comment"># Connect using all defaults</span>
<span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">Connection</span>.<span class="ruby-identifier">new</span>

<span class="ruby-comment"># As a Hash</span>
<span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">Connection</span>.<span class="ruby-identifier">new</span>( :<span class="ruby-identifier">dbname</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;test&#39;</span>, :<span class="ruby-identifier">port</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">5432</span> )

<span class="ruby-comment"># As a String</span>
<span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">Connection</span>.<span class="ruby-identifier">new</span>( <span class="ruby-string">&quot;dbname=test port=5432&quot;</span> )

<span class="ruby-comment"># As an Array</span>
<span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">Connection</span>.<span class="ruby-identifier">new</span>( <span class="ruby-keyword">nil</span>, <span class="ruby-value">5432</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">&#39;test&#39;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">nil</span> )
</pre>

<p>If the Ruby default internal encoding is set (i.e.,
Encoding.default_internal != nil), the connection will have its
<code>client_encoding</code> set accordingly.</p>

<p>Raises a <a href="Error.html">PG::Error</a> if the connection fails.</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre>static VALUE
pgconn_init(int argc, VALUE *argv, VALUE self)
{
        t_pg_connection *this;
        VALUE conninfo;
        VALUE error;

        this = pg_get_connection( self );
        conninfo = rb_funcall2( rb_cPGconn, rb_intern(&quot;parse_connect_args&quot;), argc, argv );
        this-&gt;pgconn = gvl_PQconnectdb(StringValueCStr(conninfo));

        if(this-&gt;pgconn == NULL)
                rb_raise(rb_ePGerror, &quot;PQconnectdb() unable to allocate structure&quot;);

        if (PQstatus(this-&gt;pgconn) == CONNECTION_BAD) {
                error = rb_exc_new2(rb_eConnectionBad, PQerrorMessage(this-&gt;pgconn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
        }

        pgconn_set_default_encoding( self );

        if (rb_block_given_p()) {
                return rb_ensure(rb_yield, self, pgconn_finish, self);
        }
        return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-parse_connect_args" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_connect_args</span><span
            class="method-args">( *args )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Parse the connection <code>args</code> into a connection-parameter string.
See <a href="Connection.html#method-c-new">::new</a> for valid arguments.</p>
          
          

          
          <div class="method-source-code" id="parse_connect_args-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/pg-1.0.0-x64-mingw32/lib/pg/connection.rb, line 35</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span><span class="ruby-operator">::</span><span class="ruby-identifier">parse_connect_args</span>( <span class="ruby-operator">*</span><span class="ruby-identifier">args</span> )
        <span class="ruby-keyword">return</span> <span class="ruby-string">&#39;&#39;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">empty?</span>

        <span class="ruby-identifier">hash_arg</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-constant">Hash</span> ) <span class="ruby-operator">?</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">pop</span> <span class="ruby-operator">:</span> {}
        <span class="ruby-identifier">option_string</span> = <span class="ruby-string">&#39;&#39;</span>
        <span class="ruby-identifier">options</span> = {}

        <span class="ruby-comment"># Parameter &#39;fallback_application_name&#39; was introduced in PostgreSQL 9.0</span>
        <span class="ruby-comment"># together with PQescapeLiteral().</span>
        <span class="ruby-keyword">if</span> <span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">Connection</span>.<span class="ruby-identifier">instance_methods</span>.<span class="ruby-identifier">find</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">to_sym</span> <span class="ruby-operator">==</span> <span class="ruby-value">:escape_literal</span> }
                <span class="ruby-identifier">options</span>[<span class="ruby-value">:fallback_application_name</span>] = <span class="ruby-identifier">$0</span>.<span class="ruby-identifier">sub</span>( <span class="ruby-regexp">/^(.{30}).{4,}(.{30})$/</span> ){ <span class="ruby-node">$1</span><span class="ruby-operator">+</span><span class="ruby-string">&quot;...&quot;</span><span class="ruby-operator">+</span><span class="ruby-node">$2</span> }
        <span class="ruby-keyword">end</span>

        <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
                <span class="ruby-keyword">case</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">first</span>
                <span class="ruby-keyword">when</span> <span class="ruby-constant">URI</span>, <span class="ruby-node">/\A#{URI.regexp}\z/</span>
                        <span class="ruby-identifier">uri</span> = <span class="ruby-constant">URI</span>(<span class="ruby-identifier">args</span>.<span class="ruby-identifier">first</span>)
                        <span class="ruby-identifier">options</span>.<span class="ruby-identifier">merge!</span>( <span class="ruby-constant">Hash</span>[<span class="ruby-constant">URI</span>.<span class="ruby-identifier">decode_www_form</span>( <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">query</span> )] ) <span class="ruby-keyword">if</span> <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">query</span>
                <span class="ruby-keyword">when</span> <span class="ruby-regexp">/=/</span>
                        <span class="ruby-comment"># Option string style</span>
                        <span class="ruby-identifier">option_string</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">to_s</span>
                <span class="ruby-keyword">else</span>
                        <span class="ruby-comment"># Positional parameters</span>
                        <span class="ruby-identifier">options</span>[<span class="ruby-constant">CONNECT_ARGUMENT_ORDER</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">to_sym</span>] = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">first</span>
                <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">max</span> = <span class="ruby-constant">CONNECT_ARGUMENT_ORDER</span>.<span class="ruby-identifier">length</span>
                <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>,
                        <span class="ruby-string">&quot;Extra positional parameter %d: %p&quot;</span> <span class="ruby-operator">%</span> [ <span class="ruby-identifier">max</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>, <span class="ruby-identifier">args</span>[<span class="ruby-identifier">max</span>] ] <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">max</span>

                <span class="ruby-constant">CONNECT_ARGUMENT_ORDER</span>.<span class="ruby-identifier">zip</span>( <span class="ruby-identifier">args</span> ) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span>(<span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span>)<span class="ruby-operator">|</span>
                        <span class="ruby-identifier">options</span>[ <span class="ruby-identifier">k</span>.<span class="ruby-identifier">to_sym</span> ] = <span class="ruby-identifier">v</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">v</span>
                <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-identifier">options</span>.<span class="ruby-identifier">merge!</span>( <span class="ruby-identifier">hash_arg</span> )

        <span class="ruby-keyword">if</span> <span class="ruby-identifier">uri</span>
                <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">host</span>     = <span class="ruby-keyword">nil</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:host</span>]
                <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">port</span>     = <span class="ruby-keyword">nil</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:port</span>]
                <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">user</span>     = <span class="ruby-keyword">nil</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:user</span>]
                <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">password</span> = <span class="ruby-keyword">nil</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:password</span>]
                <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">path</span>     = <span class="ruby-string">&#39;&#39;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:dbname</span>]
                <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">query</span>    = <span class="ruby-constant">URI</span>.<span class="ruby-identifier">encode_www_form</span>( <span class="ruby-identifier">options</span> )
                <span class="ruby-keyword">return</span> <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">sub</span>( <span class="ruby-node">/^#{uri.scheme}:(?!\/\/)/</span>, <span class="ruby-node">&quot;#{uri.scheme}://&quot;</span> )
        <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">option_string</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&#39; &#39;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">option_string</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">empty?</span>
                <span class="ruby-keyword">return</span> <span class="ruby-identifier">option_string</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;#{k}=#{quote_connstr(v)}&quot;</span> }.<span class="ruby-identifier">join</span>( <span class="ruby-string">&#39; &#39;</span> )
        <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-ping" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.ping(connection_hash)       &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.ping(connection_string)     &rarr; Integer
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.ping(host, port, options, tty, dbname, login, password) &rarr;  Integer
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Check server status.</p>

<p>Returns one of:</p>
<dl class="rdoc-list label-list"><dt><code>PQPING_OK</code>
<dd>
<p>server is accepting connections</p>
</dd><dt><code>PQPING_REJECT</code>
<dd>
<p>server is alive but rejecting connections</p>
</dd><dt><code>PQPING_NO_RESPONSE</code>
<dd>
<p>could not establish connection</p>
</dd><dt><code>PQPING_NO_ATTEMPT</code>
<dd>
<p>connection not attempted (bad params)</p>
</dd></dl>

<p>Available since PostgreSQL-9.1</p>
          
          

          
          <div class="method-source-code" id="ping-source">
            <pre>static VALUE
pgconn_s_ping( int argc, VALUE *argv, VALUE klass )
{
        PGPing ping;
        VALUE conninfo;

        conninfo = rb_funcall2( klass, rb_intern(&quot;parse_connect_args&quot;), argc, argv );
        ping     = PQping( StringValueCStr(conninfo) );

        return INT2FIX((int)ping);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-quote_connstr" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">quote_connstr</span><span
            class="method-args">( value )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Quote the given <code>value</code> for use in a connection-parameter
string.</p>
          
          

          
          <div class="method-source-code" id="quote_connstr-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/pg-1.0.0-x64-mingw32/lib/pg/connection.rb, line 28</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span><span class="ruby-operator">::</span><span class="ruby-identifier">quote_connstr</span>( <span class="ruby-identifier">value</span> )
        <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;&#39;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">gsub</span>( <span class="ruby-regexp">/[\&#39;]/</span> ) {<span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-string">&#39;\&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">m</span> } <span class="ruby-operator">+</span> <span class="ruby-string">&quot;&#39;&quot;</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-quote_ident" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            quote_ident( str ) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            quote_ident( array ) &rarr; String
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a string that is safe for inclusion in a SQL query as an
identifier. Note: this is not a quote function for values, but for
identifiers.</p>

<p>For example, in a typical SQL query: <code>SELECT FOO FROM MYTABLE</code>
The identifier <code>FOO</code> is folded to lower case, so it actually
means <code>foo</code>. If you really want to access the case-sensitive
field name <code>FOO</code>, use this function like
<code>conn.quote_ident(&#39;FOO&#39;)</code>, which will return
<code>&quot;FOO&quot;</code> (with double-quotes). PostgreSQL will see the
double-quotes, and it will not fold to lower case.</p>

<p>Similarly, this function also protects against special characters, and
other things that might allow SQL injection if the identifier comes from an
untrusted source.</p>

<p>If the parameter is an <a href="../Array.html">Array</a>, then all it&#39;s
values are separately quoted and then joined by a “.” character. This can
be used for identifiers in the form “schema”.“table”.“column” .</p>

<p>This method is functional identical to the encoder <a
href="TextEncoder/Identifier.html">PG::TextEncoder::Identifier</a> .</p>

<p>If the instance method form is used and the input string character encoding
is different to the connection encoding, then the string is converted to
this encoding, so that the returned string is always encoded as <a
href="Connection.html#method-i-internal_encoding">#internal_encoding</a> .</p>

<p>In the singleton form (PG::Connection.quote_ident) the character encoding
of the result string is set to the character encoding of the input string.</p>
          
          

          
          <div class="method-source-code" id="quote_ident-source">
            <pre>static VALUE
pgconn_s_quote_ident(VALUE self, VALUE str_or_array)
{
        VALUE ret;
        int enc_idx;

        if( rb_obj_is_kind_of(self, rb_cPGconn) ){
                enc_idx = ENCODING_GET( self );
        }else{
                enc_idx = RB_TYPE_P(str_or_array, T_STRING) ? ENCODING_GET( str_or_array ) : rb_ascii8bit_encindex();
        }
        pg_text_enc_identifier(NULL, str_or_array, NULL, &amp;ret, enc_idx);

        OBJ_INFECT(ret, str_or_array);

        return ret;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-unescape_bytea" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.unescape_bytea( string )
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts an escaped string representation of binary data into binary data —
the reverse of <a
href="Connection.html#method-i-escape_bytea">escape_bytea</a>. This is
needed when retrieving <code>bytea</code> data in text format, but not when
retrieving it in binary format.</p>
          
          

          
          <div class="method-source-code" id="unescape_bytea-source">
            <pre>static VALUE
pgconn_s_unescape_bytea(VALUE self, VALUE str)
{
        unsigned char *from, *to;
        size_t to_len;
        VALUE ret;

        UNUSED( self );

        Check_Type(str, T_STRING);
        from = (unsigned char*)StringValueCStr(str);

        to = PQunescapeBytea(from, &amp;to_len);

        ret = rb_str_new((char*)to, to_len);
        OBJ_INFECT(ret, str);
        PQfreemem(to);
        return ret;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-async_exec" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            async_exec(sql [, params, result_format ] ) &rarr; PG::Result
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            async_exec(sql [, params, result_format ] ) {|pg_result| block }
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This function has the same behavior as <a
href="Connection.html#method-i-exec">exec</a>, but is implemented using the
asynchronous command processing API of libpq.</p>
          
          

          
          <div class="method-source-code" id="async_exec-source">
            <pre>static VALUE
pgconn_async_exec(int argc, VALUE *argv, VALUE self)
{
        VALUE rb_pgresult = Qnil;

        /* remove any remaining results from the queue */
        pgconn_block( 0, NULL, self ); /* wait for input (without blocking) before reading the last result */
        pgconn_get_last_result( self );

        pgconn_send_query( argc, argv, self );
        pgconn_block( 0, NULL, self );
        rb_pgresult = pgconn_get_last_result( self );

        if ( rb_block_given_p() ) {
                return rb_ensure( rb_yield, rb_pgresult, pg_result_clear, rb_pgresult );
        }
        return rb_pgresult;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-async_query">async_query</a>
        </div>
        

        
      </div>

    
      <div id="method-i-async_query" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">async_query</span><span
            class="method-args">(*args)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-async_exec">async_exec</a>
        </div>
        
      </div>

    
      <div id="method-i-backend_pid" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            backend_pid() &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the process ID of the backend server process for this connection.
Note that this is a PID on database server host.</p>
          
          

          
          <div class="method-source-code" id="backend_pid-source">
            <pre>static VALUE
pgconn_backend_pid(VALUE self)
{
        return INT2NUM(PQbackendPID(pg_get_pgconn(self)));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-block" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            block( [ timeout ] ) &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Blocks until the server is no longer busy, or until the optional
<em>timeout</em> is reached, whichever comes first. <em>timeout</em> is
measured in seconds and can be fractional.</p>

<p>Returns <code>false</code> if <em>timeout</em> is reached,
<code>true</code> otherwise.</p>

<p>If <code>true</code> is returned, <code>conn.is_busy</code> will return
<code>false</code> and <code>conn.get_result</code> will not block.</p>
          
          

          
          <div class="method-source-code" id="block-source">
            <pre>static VALUE
pgconn_block( int argc, VALUE *argv, VALUE self ) {
        PGconn *conn = pg_get_pgconn( self );

        /* If WIN32 and Ruby 1.9 do not use rb_thread_select() which sometimes hangs
         * and does not wait (nor sleep) any time even if timeout is given.
         * Instead use the Winsock events and rb_w32_wait_events(). */

        struct timeval timeout;
        struct timeval *ptimeout = NULL;
        VALUE timeout_in;
        double timeout_sec;
        void *ret;

        if ( rb_scan_args(argc, argv, &quot;01&quot;, &amp;timeout_in) == 1 ) {
                timeout_sec = NUM2DBL( timeout_in );
                timeout.tv_sec = (time_t)timeout_sec;
                timeout.tv_usec = (suseconds_t)((timeout_sec - (long)timeout_sec) * 1e6);
                ptimeout = &amp;timeout;
        }

        ret = wait_socket_readable( conn, ptimeout, get_result_readable);

        if( !ret )
                return Qfalse;

        return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cancel" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cancel() &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Requests cancellation of the command currently being processed. (Only
implemented in PostgreSQL &gt;= 8.0)</p>

<p>Returns <code>nil</code> on success, or a string containing the error
message if a failure occurs.</p>
          
          

          
          <div class="method-source-code" id="cancel-source">
            <pre>static VALUE
pgconn_cancel(VALUE self)
{
        char errbuf[256];
        PGcancel *cancel;
        VALUE retval;
        int ret;

        cancel = PQgetCancel(pg_get_pgconn(self));
        if(cancel == NULL)
                rb_raise(rb_ePGerror,&quot;Invalid connection!&quot;);

        ret = gvl_PQcancel(cancel, errbuf, 256);
        if(ret == 1)
                retval = Qnil;
        else
                retval = rb_str_new2(errbuf);

        PQfreeCancel(cancel);
        return retval;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-client_encoding-3D" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">client_encoding=</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-set_client_encoding">set_client_encoding</a>
        </div>
        
      </div>

    
      <div id="method-i-close" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">close</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-finish">finish</a>
        </div>
        
      </div>

    
      <div id="method-i-conndefaults" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">conndefaults</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns an array of Hashes with connection defaults. See <a
href="Connection.html#method-c-conndefaults">::conndefaults</a> for
details.</p>
          
          

          
          <div class="method-source-code" id="conndefaults-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/pg-1.0.0-x64-mingw32/lib/pg/connection.rb, line 219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">conndefaults</span>
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">conndefaults</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-conndefaults_hash" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">conndefaults_hash</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a <a href="../Hash.html">Hash</a> with connection defaults. See <a
href="Connection.html#method-c-conndefaults_hash">::conndefaults_hash</a>
for details.</p>
          
          

          
          <div class="method-source-code" id="conndefaults_hash-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/pg-1.0.0-x64-mingw32/lib/pg/connection.rb, line 235</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">conndefaults_hash</span>
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">conndefaults_hash</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-connect_poll" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            connect_poll() &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns one of:</p>
<dl class="rdoc-list label-list"><dt><code>PGRES_POLLING_READING</code>
<dd>
<p>wait until the socket is ready to read</p>
</dd><dt><code>PGRES_POLLING_WRITING</code>
<dd>
<p>wait until the socket is ready to write</p>
</dd><dt><code>PGRES_POLLING_FAILED</code>
<dd>
<p>the asynchronous connection has failed</p>
</dd><dt><code>PGRES_POLLING_OK</code>
<dd>
<p>the asynchronous connection is ready</p>
</dd></dl>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">conn</span> = <span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">Connection</span>.<span class="ruby-identifier">connect_start</span>(<span class="ruby-string">&quot;dbname=mydatabase&quot;</span>)
<span class="ruby-identifier">socket</span> = <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">socket_io</span>
<span class="ruby-identifier">status</span> = <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">connect_poll</span>
<span class="ruby-keyword">while</span>(<span class="ruby-identifier">status</span> <span class="ruby-operator">!=</span> <span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">PGRES_POLLING_OK</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-comment"># do some work while waiting for the connection to complete</span>
  <span class="ruby-keyword">if</span>(<span class="ruby-identifier">status</span> <span class="ruby-operator">==</span> <span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">PGRES_POLLING_READING</span>)
    <span class="ruby-keyword">if</span>(<span class="ruby-keyword">not</span> <span class="ruby-identifier">select</span>([<span class="ruby-identifier">socket</span>], [], [], <span class="ruby-value">10.0</span>))
      <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Asynchronous connection timed out!&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span>(<span class="ruby-identifier">status</span> <span class="ruby-operator">==</span> <span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">PGRES_POLLING_WRITING</span>)
    <span class="ruby-keyword">if</span>(<span class="ruby-keyword">not</span> <span class="ruby-identifier">select</span>([], [<span class="ruby-identifier">socket</span>], [], <span class="ruby-value">10.0</span>))
      <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Asynchronous connection timed out!&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">status</span> = <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">connect_poll</span>
<span class="ruby-keyword">end</span>
<span class="ruby-comment"># now conn.status == CONNECTION_OK, and connection</span>
<span class="ruby-comment"># is ready.</span>
</pre>
          
          

          
          <div class="method-source-code" id="connect_poll-source">
            <pre>static VALUE
pgconn_connect_poll(VALUE self)
{
        PostgresPollingStatusType status;
        status = gvl_PQconnectPoll(pg_get_pgconn(self));
        return INT2FIX((int)status);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-connection_needs_password" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            connection_needs_password() &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if the authentication method required a password,
but none was available. <code>false</code> otherwise.</p>
          
          

          
          <div class="method-source-code" id="connection_needs_password-source">
            <pre>static VALUE
pgconn_connection_needs_password(VALUE self)
{
        return PQconnectionNeedsPassword(pg_get_pgconn(self)) ? Qtrue : Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-connection_used_password" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            connection_used_password() &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if the authentication method used a
caller-supplied password, <code>false</code> otherwise.</p>
          
          

          
          <div class="method-source-code" id="connection_used_password-source">
            <pre>static VALUE
pgconn_connection_used_password(VALUE self)
{
        return PQconnectionUsedPassword(pg_get_pgconn(self)) ? Qtrue : Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-conninfo" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            conninfo   &rarr; hash
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the connection options used by a live connection.</p>

<p>Available since PostgreSQL-9.3</p>
          
          

          
          <div class="method-source-code" id="conninfo-source">
            <pre>static VALUE
pgconn_conninfo( VALUE self )
{
        PGconn *conn = pg_get_pgconn(self);
        PQconninfoOption *options = PQconninfo( conn );
        VALUE array = pgconn_make_conninfo_array( options );

        PQconninfoFree(options);

        return array;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-conninfo_hash" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">conninfo_hash</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Return the Postgres connection info structure as a <a
href="../Hash.html">Hash</a> keyed by option keyword (as a <a
href="../Symbol.html">Symbol</a>).</p>

<p>See also <a href="Connection.html#method-i-conninfo">conninfo</a></p>
          
          

          
          <div class="method-source-code" id="conninfo_hash-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/pg-1.0.0-x64-mingw32/lib/pg/connection.rb, line 246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">conninfo_hash</span>
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">conninfo</span>.<span class="ruby-identifier">each_with_object</span>({}) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">info</span>, <span class="ruby-identifier">hash</span><span class="ruby-operator">|</span>
                <span class="ruby-identifier">hash</span>[ <span class="ruby-identifier">info</span>[<span class="ruby-value">:keyword</span>].<span class="ruby-identifier">to_sym</span> ] = <span class="ruby-identifier">info</span>[<span class="ruby-value">:val</span>]
        <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-consume_input" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            consume_input()
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>If input is available from the server, consume it. After calling
<code>consume_input</code>, you can check <code>is_busy</code> or
<strong>notifies</strong> to see if the state has changed.</p>
          
          

          
          <div class="method-source-code" id="consume_input-source">
            <pre>static VALUE
pgconn_consume_input(self)
        VALUE self;
{
        VALUE error;
        PGconn *conn = pg_get_pgconn(self);
        /* returns 0 on error */
        if(PQconsumeInput(conn) == 0) {
                error = rb_exc_new2(rb_eConnectionBad, PQerrorMessage(conn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
        }
        return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-copy_data" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            copy_data( sql [, coder] ) {|sql_result| ... } &rarr; PG::Result
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Execute a copy process for transfering data to or from the server.</p>

<p>This issues the SQL COPY command via <a
href="Connection.html#method-i-exec">exec</a>. The response to this (if
there is no error in the command) is a <a href="Result.html">PG::Result</a>
object that is passed to the block, bearing a status code of PGRES_COPY_OUT
or PGRES_COPY_IN (depending on the specified copy direction). The
application should then use <a
href="Connection.html#method-i-put_copy_data">put_copy_data</a> or <a
href="Connection.html#method-i-get_copy_data">get_copy_data</a> to receive
or transmit data rows and should return from the block when finished.</p>

<p><a href="Connection.html#method-i-copy_data">copy_data</a> returns another
<a href="Result.html">PG::Result</a> object when the data transfer is
complete. An exception is raised if some problem was encountered, so it
isn&#39;t required to make use of any of them. At this point further SQL
commands can be issued via <a
href="Connection.html#method-i-exec">exec</a>. (It is not possible to
execute other SQL commands using the same connection while the COPY
operation is in progress.)</p>

<p>This method ensures, that the copy process is properly terminated in case
of client side or server side failures. Therefore, in case of blocking mode
of operation, <a href="Connection.html#method-i-copy_data">copy_data</a> is
preferred to raw calls of <a
href="Connection.html#method-i-put_copy_data">put_copy_data</a>, <a
href="Connection.html#method-i-get_copy_data">get_copy_data</a> and <a
href="Connection.html#method-i-put_copy_end">put_copy_end</a>.</p>

<p><em>coder</em> can be a <a href="Coder.html">PG::Coder</a> derivation
(typically <a href="TextEncoder/CopyRow.html">PG::TextEncoder::CopyRow</a>
or <a href="TextDecoder/CopyRow.html">PG::TextDecoder::CopyRow</a>). This
enables encoding of data fields given to <a
href="Connection.html#method-i-put_copy_data">put_copy_data</a> or decoding
of fields received by <a
href="Connection.html#method-i-get_copy_data">get_copy_data</a>.</p>

<p>Example with CSV input format:</p>

<pre class="ruby"><span class="ruby-identifier">conn</span>.<span class="ruby-identifier">exec</span> <span class="ruby-string">&quot;create table my_table (a text,b text,c text,d text)&quot;</span>
<span class="ruby-identifier">conn</span>.<span class="ruby-identifier">copy_data</span> <span class="ruby-string">&quot;COPY my_table FROM STDIN CSV&quot;</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">put_copy_data</span> <span class="ruby-string">&quot;some,data,to,copy\n&quot;</span>
  <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">put_copy_data</span> <span class="ruby-string">&quot;more,data,to,copy\n&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This creates <code>my_table</code> and inserts two CSV rows.</p>

<p>The same with text format encoder <a
href="TextEncoder/CopyRow.html">PG::TextEncoder::CopyRow</a> and <a
href="../Array.html">Array</a> input:</p>

<pre class="ruby"><span class="ruby-identifier">enco</span> = <span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">TextEncoder</span><span class="ruby-operator">::</span><span class="ruby-constant">CopyRow</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">conn</span>.<span class="ruby-identifier">copy_data</span> <span class="ruby-string">&quot;COPY my_table FROM STDIN&quot;</span>, <span class="ruby-identifier">enco</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">put_copy_data</span> [<span class="ruby-string">&#39;some&#39;</span>, <span class="ruby-string">&#39;data&#39;</span>, <span class="ruby-string">&#39;to&#39;</span>, <span class="ruby-string">&#39;copy&#39;</span>]
  <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">put_copy_data</span> [<span class="ruby-string">&#39;more&#39;</span>, <span class="ruby-string">&#39;data&#39;</span>, <span class="ruby-string">&#39;to&#39;</span>, <span class="ruby-string">&#39;copy&#39;</span>]
<span class="ruby-keyword">end</span>
</pre>

<p>Example with CSV output format:</p>

<pre class="ruby"><span class="ruby-identifier">conn</span>.<span class="ruby-identifier">copy_data</span> <span class="ruby-string">&quot;COPY my_table TO STDOUT CSV&quot;</span> <span class="ruby-keyword">do</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">row</span>=<span class="ruby-identifier">conn</span>.<span class="ruby-identifier">get_copy_data</span>
    <span class="ruby-identifier">p</span> <span class="ruby-identifier">row</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This prints all rows of <code>my_table</code> to stdout:</p>

<pre class="ruby"><span class="ruby-string">&quot;some,data,to,copy\n&quot;</span>
<span class="ruby-string">&quot;more,data,to,copy\n&quot;</span>
</pre>

<p>The same with text format decoder <a
href="TextDecoder/CopyRow.html">PG::TextDecoder::CopyRow</a> and <a
href="../Array.html">Array</a> output:</p>

<pre class="ruby"><span class="ruby-identifier">deco</span> = <span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">TextDecoder</span><span class="ruby-operator">::</span><span class="ruby-constant">CopyRow</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">conn</span>.<span class="ruby-identifier">copy_data</span> <span class="ruby-string">&quot;COPY my_table TO STDOUT&quot;</span>, <span class="ruby-identifier">deco</span> <span class="ruby-keyword">do</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">row</span>=<span class="ruby-identifier">conn</span>.<span class="ruby-identifier">get_copy_data</span>
    <span class="ruby-identifier">p</span> <span class="ruby-identifier">row</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This receives all rows of <code>my_table</code> as ruby array:</p>

<pre class="ruby">[<span class="ruby-string">&quot;some&quot;</span>, <span class="ruby-string">&quot;data&quot;</span>, <span class="ruby-string">&quot;to&quot;</span>, <span class="ruby-string">&quot;copy&quot;</span>]
[<span class="ruby-string">&quot;more&quot;</span>, <span class="ruby-string">&quot;data&quot;</span>, <span class="ruby-string">&quot;to&quot;</span>, <span class="ruby-string">&quot;copy&quot;</span>]
</pre>
          
          

          
          <div class="method-source-code" id="copy_data-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/pg-1.0.0-x64-mingw32/lib/pg/connection.rb, line 155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">copy_data</span>( <span class="ruby-identifier">sql</span>, <span class="ruby-identifier">coder</span>=<span class="ruby-keyword">nil</span> )
        <span class="ruby-identifier">res</span> = <span class="ruby-identifier">exec</span>( <span class="ruby-identifier">sql</span> )

        <span class="ruby-keyword">case</span> <span class="ruby-identifier">res</span>.<span class="ruby-identifier">result_status</span>
        <span class="ruby-keyword">when</span> <span class="ruby-constant">PGRES_COPY_IN</span>
                <span class="ruby-keyword">begin</span>
                        <span class="ruby-keyword">if</span> <span class="ruby-identifier">coder</span>
                                <span class="ruby-identifier">old_coder</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">encoder_for_put_copy_data</span>
                                <span class="ruby-keyword">self</span>.<span class="ruby-identifier">encoder_for_put_copy_data</span> = <span class="ruby-identifier">coder</span>
                        <span class="ruby-keyword">end</span>
                        <span class="ruby-keyword">yield</span> <span class="ruby-identifier">res</span>
                <span class="ruby-keyword">rescue</span> <span class="ruby-constant">Exception</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">err</span>
                        <span class="ruby-identifier">errmsg</span> = <span class="ruby-string">&quot;%s while copy data: %s&quot;</span> <span class="ruby-operator">%</span> [ <span class="ruby-identifier">err</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">err</span>.<span class="ruby-identifier">message</span> ]
                        <span class="ruby-identifier">put_copy_end</span>( <span class="ruby-identifier">errmsg</span> )
                        <span class="ruby-identifier">get_result</span>
                        <span class="ruby-identifier">raise</span>
                <span class="ruby-keyword">else</span>
                        <span class="ruby-identifier">put_copy_end</span>
                        <span class="ruby-identifier">get_last_result</span>
                <span class="ruby-keyword">ensure</span>
                        <span class="ruby-keyword">self</span>.<span class="ruby-identifier">encoder_for_put_copy_data</span> = <span class="ruby-identifier">old_coder</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">coder</span>
                <span class="ruby-keyword">end</span>

        <span class="ruby-keyword">when</span> <span class="ruby-constant">PGRES_COPY_OUT</span>
                <span class="ruby-keyword">begin</span>
                        <span class="ruby-keyword">if</span> <span class="ruby-identifier">coder</span>
                                <span class="ruby-identifier">old_coder</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">decoder_for_get_copy_data</span>
                                <span class="ruby-keyword">self</span>.<span class="ruby-identifier">decoder_for_get_copy_data</span> = <span class="ruby-identifier">coder</span>
                        <span class="ruby-keyword">end</span>
                        <span class="ruby-keyword">yield</span> <span class="ruby-identifier">res</span>
                <span class="ruby-keyword">rescue</span> <span class="ruby-constant">Exception</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">err</span>
                        <span class="ruby-identifier">cancel</span>
                        <span class="ruby-keyword">while</span> <span class="ruby-identifier">get_copy_data</span>
                        <span class="ruby-keyword">end</span>
                        <span class="ruby-keyword">while</span> <span class="ruby-identifier">get_result</span>
                        <span class="ruby-keyword">end</span>
                        <span class="ruby-identifier">raise</span>
                <span class="ruby-keyword">else</span>
                        <span class="ruby-identifier">res</span> = <span class="ruby-identifier">get_last_result</span>
                        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">res</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">res</span>.<span class="ruby-identifier">result_status</span> <span class="ruby-operator">!=</span> <span class="ruby-constant">PGRES_COMMAND_OK</span>
                                <span class="ruby-keyword">while</span> <span class="ruby-identifier">get_copy_data</span>
                                <span class="ruby-keyword">end</span>
                                <span class="ruby-keyword">while</span> <span class="ruby-identifier">get_result</span>
                                <span class="ruby-keyword">end</span>
                                <span class="ruby-identifier">raise</span> <span class="ruby-constant">PG</span><span class="ruby-operator">::</span><span class="ruby-constant">NotAllCopyDataRetrieved</span>, <span class="ruby-string">&quot;Not all COPY data retrieved&quot;</span>
                        <span class="ruby-keyword">end</span>
                        <span class="ruby-identifier">res</span>
                <span class="ruby-keyword">ensure</span>
                        <span class="ruby-keyword">self</span>.<span class="ruby-identifier">decoder_for_get_copy_data</span> = <span class="ruby-identifier">old_coder</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">coder</span>
                <span class="ruby-keyword">end</span>

        <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-node">&quot;SQL command is no COPY statement: #{sql}&quot;</span>
        <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-db" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            db()
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the connected database name.</p>
          
          

          
          <div class="method-source-code" id="db-source">
            <pre>static VALUE
pgconn_db(VALUE self)
{
        char *db = PQdb(pg_get_pgconn(self));
        if (!db) return Qnil;
        return rb_tainted_str_new2(db);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-decoder_for_get_copy_data" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            decoder_for_get_copy_data &rarr; PG::Coder
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the default coder object that is currently set for type casting of
received data by <a
href="Connection.html#method-i-get_copy_data">get_copy_data</a> .</p>

<p>Returns either:</p>
<ul><li>
<p>a kind of <a href="Coder.html">PG::Coder</a></p>
</li><li>
<p><code>nil</code> - type encoding is disabled, returned data will be a <a
href="../String.html">String</a>.</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="decoder_for_get_copy_data-source">
            <pre>static VALUE
pgconn_decoder_for_get_copy_data_get(VALUE self)
{
        t_pg_connection *this = pg_get_connection( self );

        return this-&gt;decoder_for_get_copy_data;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-decoder_for_get_copy_data-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            decoder_for_get_copy_data = decoder
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the default coder that is used for type casting of received data by <a
href="Connection.html#method-i-get_copy_data">get_copy_data</a> .</p>

<p><code>decoder</code> can be:</p>
<ul><li>
<p>a kind of <a href="Coder.html">PG::Coder</a></p>
</li><li>
<p><code>nil</code> - disable type decoding, returned data will be a <a
href="../String.html">String</a>.</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="decoder_for_get_copy_data-3D-source">
            <pre>static VALUE
pgconn_decoder_for_get_copy_data_set(VALUE self, VALUE typemap)
{
        t_pg_connection *this = pg_get_connection( self );

        if( typemap != Qnil ){
                if ( !rb_obj_is_kind_of(typemap, rb_cPG_Coder) ) {
                        rb_raise( rb_eTypeError, &quot;wrong argument type %s (expected kind of PG::Coder)&quot;,
                                        rb_obj_classname( typemap ) );
                }
                Check_Type(typemap, T_DATA);
        }
        this-&gt;decoder_for_get_copy_data = typemap;

        return typemap;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-describe_portal" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            describe_portal( portal_name ) &rarr; PG::Result
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve information about the portal <em>portal_name</em>.</p>
          
          

          
          <div class="method-source-code" id="describe_portal-source">
            <pre>static VALUE
pgconn_describe_portal(self, stmt_name)
        VALUE self, stmt_name;
{
        PGresult *result;
        VALUE rb_pgresult;
        PGconn *conn = pg_get_pgconn(self);
        const char *stmt;
        if(NIL_P(stmt_name)) {
                stmt = NULL;
        }
        else {
                stmt = pg_cstr_enc(stmt_name, ENCODING_GET(self));
        }
        result = gvl_PQdescribePortal(conn, stmt);
        rb_pgresult = pg_new_result(result, self);
        pg_result_check(rb_pgresult);
        return rb_pgresult;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-describe_prepared" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            describe_prepared( statement_name ) &rarr; PG::Result
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve information about the prepared statement <em>statement_name</em>.</p>
          
          

          
          <div class="method-source-code" id="describe_prepared-source">
            <pre>static VALUE
pgconn_describe_prepared(VALUE self, VALUE stmt_name)
{
        PGresult *result;
        VALUE rb_pgresult;
        PGconn *conn = pg_get_pgconn(self);
        const char *stmt;
        if(NIL_P(stmt_name)) {
                stmt = NULL;
        }
        else {
                stmt = pg_cstr_enc(stmt_name, ENCODING_GET(self));
        }
        result = gvl_PQdescribePrepared(conn, stmt);
        rb_pgresult = pg_new_result(result, self);
        pg_result_check(rb_pgresult);
        return rb_pgresult;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-encoder_for_put_copy_data" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            encoder_for_put_copy_data &rarr; PG::Coder
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the default coder object that is currently set for type casting of
parameters to <a
href="Connection.html#method-i-put_copy_data">put_copy_data</a> .</p>

<p>Returns either:</p>
<ul><li>
<p>a kind of <a href="Coder.html">PG::Coder</a></p>
</li><li>
<p><code>nil</code> - type encoding is disabled, data must be a <a
href="../String.html">String</a>.</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="encoder_for_put_copy_data-source">
            <pre>static VALUE
pgconn_encoder_for_put_copy_data_get(VALUE self)
{
        t_pg_connection *this = pg_get_connection( self );

        return this-&gt;encoder_for_put_copy_data;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-encoder_for_put_copy_data-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            encoder_for_put_copy_data = encoder
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the default coder that is used for type casting of parameters to <a
href="Connection.html#method-i-put_copy_data">put_copy_data</a> .</p>

<p><code>encoder</code> can be:</p>
<ul><li>
<p>a kind of <a href="Coder.html">PG::Coder</a></p>
</li><li>
<p><code>nil</code> - disable type encoding, data must be a <a
href="../String.html">String</a>.</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="encoder_for_put_copy_data-3D-source">
            <pre>static VALUE
pgconn_encoder_for_put_copy_data_set(VALUE self, VALUE typemap)
{
        t_pg_connection *this = pg_get_connection( self );

        if( typemap != Qnil ){
                if ( !rb_obj_is_kind_of(typemap, rb_cPG_Coder) ) {
                        rb_raise( rb_eTypeError, &quot;wrong argument type %s (expected kind of PG::Coder)&quot;,
                                        rb_obj_classname( typemap ) );
                }
                Check_Type(typemap, T_DATA);
        }
        this-&gt;encoder_for_put_copy_data = typemap;

        return typemap;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-encrypt_password" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            encrypt_password( password, username, algorithm=nil ) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This function is intended to be used by client applications that wish to
send commands like <code>ALTER USER joe PASSWORD &#39;pwd&#39;</code>. It
is good practice not to send the original cleartext password in such a
command, because it might be exposed in command logs, activity displays,
and so on. Instead, use this function to convert the password to encrypted
form before it is sent.</p>

<p>The <code>password</code> and <code>username</code> arguments are the
cleartext password, and the SQL name of the user it is for.
<code>algorithm</code> specifies the encryption algorithm to use to encrypt
the password. Currently supported algorithms are <code>md5</code> and
<code>scram-sha-256</code> (<code>on</code> and <code>off</code> are also
accepted as aliases for <code>md5</code>, for compatibility with older
server versions). Note that support for <code>scram-sha-256</code> was
introduced in PostgreSQL version 10, and will not work correctly with older
server versions. If algorithm is omitted or <code>nil</code>, this function
will query the server for the current value of the
<code>password_encryption</code> setting. That can block, and will fail if
the current transaction is aborted, or if the connection is busy executing
another query. If you wish to use the default algorithm for the server but
want to avoid blocking, query <code>password_encryption</code> yourself
before calling <a
href="Connection.html#method-i-encrypt_password">encrypt_password</a>, and
pass that value as the algorithm.</p>

<p>Return value is the encrypted password. The caller can assume the string
doesn&#39;t contain any special characters that would require escaping.</p>

<p>Available since PostgreSQL-10</p>
          
          

          
          <div class="method-source-code" id="encrypt_password-source">
            <pre>static VALUE
pgconn_encrypt_password(int argc, VALUE *argv, VALUE self)
{
        char *encrypted = NULL;
        VALUE rval = Qnil;
        VALUE password, username, algorithm;
        PGconn *conn = pg_get_pgconn(self);

        rb_scan_args( argc, argv, &quot;21&quot;, &amp;password, &amp;username, &amp;algorithm );

        Check_Type(password, T_STRING);
        Check_Type(username, T_STRING);

        encrypted = gvl_PQencryptPasswordConn(conn, StringValueCStr(password), StringValueCStr(username), RTEST(algorithm) ? StringValueCStr(algorithm) : NULL);
        if ( encrypted ) {
                rval = rb_str_new2( encrypted );
                PQfreemem( encrypted );

                OBJ_INFECT( rval, password );
                OBJ_INFECT( rval, username );
                OBJ_INFECT( rval, algorithm );
        } else {
                rb_raise(rb_ePGerror, &quot;%s&quot;, PQerrorMessage(conn));
        }

        return rval;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-error_message" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            error_message &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the error message about connection.</p>
          
          

          
          <div class="method-source-code" id="error_message-source">
            <pre>static VALUE
pgconn_error_message(VALUE self)
{
        char *error = PQerrorMessage(pg_get_pgconn(self));
        if (!error) return Qnil;
        return rb_tainted_str_new2(error);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-escape" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">escape</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-escape_string">escape_string</a>
        </div>
        
      </div>

    
      <div id="method-i-escape_bytea" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            escape_bytea( string ) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Escapes binary data for use within an SQL command with the type
<code>bytea</code>.</p>

<p>Certain byte values must be escaped (but all byte values may be escaped)
when used as part of a <code>bytea</code> literal in an SQL statement. In
general, to escape a byte, it is converted into the three digit octal
number equal to the octet value, and preceded by two backslashes. The
single quote (&#39;) and backslash () characters have special alternative
escape sequences. <a
href="Connection.html#method-i-escape_bytea">escape_bytea</a> performs this
operation, escaping only the minimally required bytes.</p>

<p>Consider using <a
href="Connection.html#method-i-exec_params">#exec_params</a>, which avoids
the need for passing values inside of SQL commands.</p>

<p>NOTE: This class version of this method can only be used safely in client
programs that use a single PostgreSQL connection at a time (in this case it
can find out what it needs to know “behind the scenes”). It might give the
wrong results if used in programs that use multiple database connections;
use the same method on the connection object in such cases.</p>
          
          

          
          <div class="method-source-code" id="escape_bytea-source">
            <pre>static VALUE
pgconn_s_escape_bytea(VALUE self, VALUE str)
{
        unsigned char *from, *to;
        size_t from_len, to_len;
        VALUE ret;

        Check_Type(str, T_STRING);
        from      = (unsigned char*)RSTRING_PTR(str);
        from_len  = RSTRING_LEN(str);

        if ( rb_obj_is_kind_of(self, rb_cPGconn) ) {
                to = PQescapeByteaConn(pg_get_pgconn(self), from, from_len, &amp;to_len);
        } else {
                to = PQescapeBytea( from, from_len, &amp;to_len);
        }

        ret = rb_str_new((char*)to, to_len - 1);
        OBJ_INFECT(ret, str);
        PQfreemem(to);
        return ret;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-escape_identifier" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            escape_identifier( str ) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Escape an arbitrary <a href="../String.html">String</a> <code>str</code> as
an identifier.</p>

<p>This method does the same as <a
href="Connection.html#method-i-quote_ident">quote_ident</a> with a <a
href="../String.html">String</a> argument, but it doesn&#39;t support an <a
href="../Array.html">Array</a> argument and it makes use of libpq to
process the string.</p>

<p>Available since PostgreSQL-9.0</p>
          
          

          
          <div class="method-source-code" id="escape_identifier-source">
            <pre>static VALUE
pgconn_escape_identifier(VALUE self, VALUE string)
{
        PGconn *conn = pg_get_pgconn(self);
        char *escaped = NULL;
        VALUE error;
        VALUE result = Qnil;
        int enc_idx = ENCODING_GET(self);

        Check_Type(string, T_STRING);
        if( ENCODING_GET(string) != enc_idx ){
                string = rb_str_export_to_enc(string, rb_enc_from_index(enc_idx));
        }

        escaped = PQescapeIdentifier(conn, RSTRING_PTR(string), RSTRING_LEN(string));
        if (escaped == NULL)
        {
                error = rb_exc_new2(rb_ePGerror, PQerrorMessage(conn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
                return Qnil;
        }
        result = rb_str_new2(escaped);
        PQfreemem(escaped);
        OBJ_INFECT(result, string);
        PG_ENCODING_SET_NOCHECK(result, enc_idx);

        return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-escape_literal" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            escape_literal( str ) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Escape an arbitrary <a href="../String.html">String</a> <code>str</code> as
a literal.</p>

<p>Available since PostgreSQL-9.0</p>
          
          

          
          <div class="method-source-code" id="escape_literal-source">
            <pre>static VALUE
pgconn_escape_literal(VALUE self, VALUE string)
{
        PGconn *conn = pg_get_pgconn(self);
        char *escaped = NULL;
        VALUE error;
        VALUE result = Qnil;
        int enc_idx = ENCODING_GET(self);

        Check_Type(string, T_STRING);
        if( ENCODING_GET(string) != enc_idx ){
                string = rb_str_export_to_enc(string, rb_enc_from_index(enc_idx));
        }

        escaped = PQescapeLiteral(conn, RSTRING_PTR(string), RSTRING_LEN(string));
        if (escaped == NULL)
        {
                error = rb_exc_new2(rb_ePGerror, PQerrorMessage(conn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
                return Qnil;
        }
        result = rb_str_new2(escaped);
        PQfreemem(escaped);
        OBJ_INFECT(result, string);
        PG_ENCODING_SET_NOCHECK(result, enc_idx);

        return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-escape_string" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            escape_string( str ) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a SQL-safe version of the <a href="../String.html">String</a>
<em>str</em>. This is the preferred way to make strings safe for inclusion
in SQL queries.</p>

<p>Consider using <a
href="Connection.html#method-i-exec_params">#exec_params</a>, which avoids
the need for passing values inside of SQL commands.</p>

<p><a href="../Encoding.html">Encoding</a> of escaped string will be equal to
client encoding of connection.</p>

<p>NOTE: This class version of this method can only be used safely in client
programs that use a single PostgreSQL connection at a time (in this case it
can find out what it needs to know “behind the scenes”). It might give the
wrong results if used in programs that use multiple database connections;
use the same method on the connection object in such cases.</p>
          
          

          
          <div class="method-source-code" id="escape_string-source">
            <pre>static VALUE
pgconn_s_escape(VALUE self, VALUE string)
{
        size_t size;
        int error;
        VALUE result;
        int enc_idx;
        int singleton = !rb_obj_is_kind_of(self, rb_cPGconn);

        Check_Type(string, T_STRING);
        enc_idx = ENCODING_GET( singleton ? string : self );
        if( ENCODING_GET(string) != enc_idx ){
                string = rb_str_export_to_enc(string, rb_enc_from_index(enc_idx));
        }

        result = rb_str_new(NULL, RSTRING_LEN(string) * 2 + 1);
        PG_ENCODING_SET_NOCHECK(result, enc_idx);
        if( !singleton ) {
                size = PQescapeStringConn(pg_get_pgconn(self), RSTRING_PTR(result),
                        RSTRING_PTR(string), RSTRING_LEN(string), &amp;error);
                if(error) {
                        rb_raise(rb_ePGerror, &quot;%s&quot;, PQerrorMessage(pg_get_pgconn(self)));
                }
        } else {
                size = PQescapeString(RSTRING_PTR(result), RSTRING_PTR(string), RSTRING_LEN(string));
        }
        rb_str_set_len(result, size);
        OBJ_INFECT(result, string);

        return result;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-escape">escape</a>
        </div>
        

        
      </div>

    
      <div id="method-i-exec" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            exec(sql) &rarr; PG::Result
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            exec(sql) {|pg_result| block }
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sends SQL query request specified by <em>sql</em> to PostgreSQL. Returns a
<a href="Result.html">PG::Result</a> instance on success. On failure, it
raises a <a href="Error.html">PG::Error</a>.</p>

<p>For backward compatibility, if you pass more than one parameter to this
method, it will call <a
href="Connection.html#method-i-exec_params">exec_params</a> for you. New
code should explicitly use <a
href="Connection.html#method-i-exec_params">exec_params</a> if argument
placeholders are used.</p>

<p>If the optional code block is given, it will be passed <em>result</em> as
an argument, and the <a href="Result.html">PG::Result</a> object will 
automatically be cleared when the block terminates. In this instance,
<code>conn.exec</code> returns the value of the block.</p>

<p><a href="Connection.html#method-i-exec">exec</a> is implemented on the
synchronous command processing API of libpq, whereas <a
href="Connection.html#method-i-async_exec">async_exec</a> is implemented on
the asynchronous API. <a href="Connection.html#method-i-exec">exec</a> is
somewhat faster that <a
href="Connection.html#method-i-async_exec">async_exec</a>, but blocks any
signals to be processed until the query is finished. This is most notably
visible by a delayed reaction to Control+C. Both methods ensure that other
threads can process while waiting for the server to complete the request.</p>
          
          

          
          <div class="method-source-code" id="exec-source">
            <pre>static VALUE
pgconn_exec(int argc, VALUE *argv, VALUE self)
{
        PGconn *conn = pg_get_pgconn(self);
        PGresult *result = NULL;
        VALUE rb_pgresult;

        /* If called with no parameters, use PQexec */
        if ( argc == 1 ) {
                VALUE query_str = argv[0];

                result = gvl_PQexec(conn, pg_cstr_enc(query_str, ENCODING_GET(self)));
                rb_pgresult = pg_new_result(result, self);
                pg_result_check(rb_pgresult);
                if (rb_block_given_p()) {
                        return rb_ensure(rb_yield, rb_pgresult, pg_result_clear, rb_pgresult);
                }
                return rb_pgresult;
        }

        /* Otherwise, just call #exec_params instead for backward-compatibility */
        else {
                return pgconn_exec_params( argc, argv, self );
        }

}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-query">query</a>
        </div>
        

        
      </div>

    
      <div id="method-i-exec_params" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            exec_params(sql, params[, result_format[, type_map]] ) &rarr; PG::Result
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            exec_params(sql, params[, result_format[, type_map]] ) {|pg_result| block }
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sends SQL query request specified by <code>sql</code> to PostgreSQL using
placeholders for parameters.</p>

<p>Returns a <a href="Result.html">PG::Result</a> instance on success. On
failure, it raises a <a href="Error.html">PG::Error</a>.</p>

<p><code>params</code> is an array of the bind parameters for the SQL query.
Each element of the <code>params</code> array may be either:</p>

<pre>a hash of the form:
  {:value  =&gt; String (value of bind parameter)
   :type   =&gt; Integer (oid of type of bind parameter)
   :format =&gt; Integer (0 for text, 1 for binary)
  }
or, it may be a String. If it is a string, that is equivalent to the hash:
  { :value =&gt; &lt;string value&gt;, :type =&gt; 0, :format =&gt; 0 }</pre>

<p>PostgreSQL bind parameters are represented as $1, $1, $2, etc., inside the
SQL query. The 0th element of the <code>params</code> array is bound to $1,
the 1st element is bound to $2, etc. <code>nil</code> is treated as
<code>NULL</code>.</p>

<p>If the types are not specified, they will be inferred by PostgreSQL.
Instead of specifying type oids, it&#39;s recommended to simply add
explicit casts in the query to ensure that the right type is used.</p>

<p>For example: “SELECT $1::int”</p>

<p>The optional <code>result_format</code> should be 0 for text results, 1 for
binary.</p>

<p>type_map can be a <a href="TypeMap.html">PG::TypeMap</a> derivation (such
as <a href="BasicTypeMapForQueries.html">PG::BasicTypeMapForQueries</a>).
This will type cast the params from various Ruby types before transmission
based on the encoders defined by the type map. When a type encoder is used
the format and oid of a given bind parameter are retrieved from the encoder
instead out of the hash form described above.</p>

<p>If the optional code block is given, it will be passed <em>result</em> as
an argument, and the <a href="Result.html">PG::Result</a> object will 
automatically be cleared when the block terminates. In this instance,
<code>conn.exec</code> returns the value of the block.</p>
          
          

          
          <div class="method-source-code" id="exec_params-source">
            <pre>static VALUE
pgconn_exec_params( int argc, VALUE *argv, VALUE self )
{
        PGconn *conn = pg_get_pgconn(self);
        PGresult *result = NULL;
        VALUE rb_pgresult;
        VALUE command, in_res_fmt;
        int nParams;
        int resultFormat;
        struct query_params_data paramsData = { ENCODING_GET(self) };

        rb_scan_args(argc, argv, &quot;13&quot;, &amp;command, &amp;paramsData.params, &amp;in_res_fmt, &amp;paramsData.typemap);
        paramsData.with_types = 1;

        /*
         * Handle the edge-case where the caller is coming from #exec, but passed an explict +nil+
         * for the second parameter.
         */
        if ( NIL_P(paramsData.params) ) {
                return pgconn_exec( 1, argv, self );
        }
        pgconn_query_assign_typemap( self, &amp;paramsData );

        resultFormat = NIL_P(in_res_fmt) ? 0 : NUM2INT(in_res_fmt);
        nParams = alloc_query_params( &amp;paramsData );

        result = gvl_PQexecParams(conn, pg_cstr_enc(command, paramsData.enc_idx), nParams, paramsData.types,
                (const char * const *)paramsData.values, paramsData.lengths, paramsData.formats, resultFormat);

        free_query_params( &amp;paramsData );

        rb_pgresult = pg_new_result(result, self);
        pg_result_check(rb_pgresult);

        if (rb_block_given_p()) {
                return rb_ensure(rb_yield, rb_pgresult, pg_result_clear, rb_pgresult);
        }

        return rb_pgresult;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-exec_prepared" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            exec_prepared(statement_name [, params, result_format[, type_map]] ) &rarr; PG::Result
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            exec_prepared(statement_name [, params, result_format[, type_map]] ) {|pg_result| block }
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Execute prepared named statement specified by <em>statement_name</em>.
Returns a <a href="Result.html">PG::Result</a> instance on success. On
failure, it raises a <a href="Error.html">PG::Error</a>.</p>

<p><code>params</code> is an array of the optional bind parameters for the SQL
query. Each element of the <code>params</code> array may be either:</p>

<pre>a hash of the form:
  {:value  =&gt; String (value of bind parameter)
   :format =&gt; Integer (0 for text, 1 for binary)
  }
or, it may be a String. If it is a string, that is equivalent to the hash:
  { :value =&gt; &lt;string value&gt;, :format =&gt; 0 }</pre>

<p>PostgreSQL bind parameters are represented as $1, $1, $2, etc., inside the
SQL query. The 0th element of the <code>params</code> array is bound to $1,
the 1st element is bound to $2, etc. <code>nil</code> is treated as
<code>NULL</code>.</p>

<p>The optional <code>result_format</code> should be 0 for text results, 1 for
binary.</p>

<p>type_map can be a <a href="TypeMap.html">PG::TypeMap</a> derivation (such
as <a href="BasicTypeMapForQueries.html">PG::BasicTypeMapForQueries</a>).
This will type cast the params from various Ruby types before transmission
based on the encoders defined by the type map. When a type encoder is used
the format and oid of a given bind parameter are retrieved from the encoder
instead out of the hash form described above.</p>

<p>If the optional code block is given, it will be passed <em>result</em> as
an argument, and the <a href="Result.html">PG::Result</a> object will 
automatically be cleared when the block terminates. In this instance,
<code>conn.exec_prepared</code> returns the value of the block.</p>
          
          

          
          <div class="method-source-code" id="exec_prepared-source">
            <pre>static VALUE
pgconn_exec_prepared(int argc, VALUE *argv, VALUE self)
{
        PGconn *conn = pg_get_pgconn(self);
        PGresult *result = NULL;
        VALUE rb_pgresult;
        VALUE name, in_res_fmt;
        int nParams;
        int resultFormat;
        struct query_params_data paramsData = { ENCODING_GET(self) };

        rb_scan_args(argc, argv, &quot;13&quot;, &amp;name, &amp;paramsData.params, &amp;in_res_fmt, &amp;paramsData.typemap);
        paramsData.with_types = 0;

        if(NIL_P(paramsData.params)) {
                paramsData.params = rb_ary_new2(0);
        }
        pgconn_query_assign_typemap( self, &amp;paramsData );

        resultFormat = NIL_P(in_res_fmt) ? 0 : NUM2INT(in_res_fmt);
        nParams = alloc_query_params( &amp;paramsData );

        result = gvl_PQexecPrepared(conn, pg_cstr_enc(name, paramsData.enc_idx), nParams,
                (const char * const *)paramsData.values, paramsData.lengths, paramsData.formats,
                resultFormat);

        free_query_params( &amp;paramsData );

        rb_pgresult = pg_new_result(result, self);
        pg_result_check(rb_pgresult);
        if (rb_block_given_p()) {
                return rb_ensure(rb_yield, rb_pgresult,
                        pg_result_clear, rb_pgresult);
        }
        return rb_pgresult;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-external_encoding" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            external_encoding() &rarr; Encoding
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Return the <code>server_encoding</code> of the connected database as a Ruby
<a href="../Encoding.html">Encoding</a> object. The <code>SQL_ASCII</code>
encoding is mapped to to <code>ASCII_8BIT</code>.</p>
          
          

          
          <div class="method-source-code" id="external_encoding-source">
            <pre>static VALUE
pgconn_external_encoding(VALUE self)
{
        t_pg_connection *this = pg_get_connection_safe( self );
        rb_encoding *enc = NULL;
        const char *pg_encname = NULL;

        /* Use cached value if found */
        if ( RTEST(this-&gt;external_encoding) ) return this-&gt;external_encoding;

        pg_encname = PQparameterStatus( this-&gt;pgconn, &quot;server_encoding&quot; );
        enc = pg_get_pg_encname_as_rb_encoding( pg_encname );
        this-&gt;external_encoding = rb_enc_from_encoding( enc );

        return this-&gt;external_encoding;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-finish" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            finish
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Closes the backend connection.</p>
          
          

          
          <div class="method-source-code" id="finish-source">
            <pre>static VALUE
pgconn_finish( VALUE self )
{
        t_pg_connection *this = pg_get_connection_safe( self );

        pgconn_close_socket_io( self );
        PQfinish( this-&gt;pgconn );
        this-&gt;pgconn = NULL;
        return Qnil;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-close">close</a>
        </div>
        

        
      </div>

    
      <div id="method-i-finished-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            finished?      &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if the backend connection has been closed.</p>
          
          

          
          <div class="method-source-code" id="finished-3F-source">
            <pre>static VALUE
pgconn_finished_p( VALUE self )
{
        t_pg_connection *this = pg_get_connection( self );
        if ( this-&gt;pgconn ) return Qfalse;
        return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-flush" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            flush() &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Attempts to flush any queued output data to the server. Returns
<code>true</code> if data is successfully flushed, <code>false</code> if
not (can only return <code>false</code> if connection is nonblocking.
Raises <a href="Error.html">PG::Error</a> if some other failure occurred.</p>
          
          

          
          <div class="method-source-code" id="flush-source">
            <pre>static VALUE
pgconn_flush(self)
        VALUE self;
{
        PGconn *conn = pg_get_pgconn(self);
        int ret;
        VALUE error;
        ret = PQflush(conn);
        if(ret == -1) {
                error = rb_exc_new2(rb_ePGerror, PQerrorMessage(conn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
        }
        return (ret) ? Qfalse : Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-get_client_encoding" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            get_client_encoding() &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the client encoding as a <a href="../String.html">String</a>.</p>
          
          

          
          <div class="method-source-code" id="get_client_encoding-source">
            <pre>static VALUE
pgconn_get_client_encoding(VALUE self)
{
        char *encoding = (char *)pg_encoding_to_char(PQclientEncoding(pg_get_pgconn(self)));
        return rb_tainted_str_new2(encoding);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-get_copy_data" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            get_copy_data( [ async = false [, decoder = nil ]] ) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Return a string containing one row of data, <code>nil</code> if the copy is
done, or <code>false</code> if the call would block (only possible if
<em>async</em> is true).</p>

<p><em>decoder</em> can be a <a href="Coder.html">PG::Coder</a> derivation
(typically <a
href="TextDecoder/CopyRow.html">PG::TextDecoder::CopyRow</a>). This decodes
the received data fields from PostgreSQL&#39;s COPY text format to an <a
href="../Array.html">Array</a> of Strings. Optionally the decoder can type
cast the fields to various Ruby types in one step, if <a
href="CopyCoder.html#method-i-type_map">PG::CopyCoder#type_map</a> is set
accordingly.</p>

<p>See also <a href="Connection.html#method-i-copy_data">copy_data</a>.</p>
          
          

          
          <div class="method-source-code" id="get_copy_data-source">
            <pre>static VALUE
pgconn_get_copy_data(int argc, VALUE *argv, VALUE self )
{
        VALUE async_in;
        VALUE error;
        VALUE result;
        int ret;
        char *buffer;
        VALUE decoder;
        t_pg_coder *p_coder = NULL;
        t_pg_connection *this = pg_get_connection_safe( self );

        rb_scan_args(argc, argv, &quot;02&quot;, &amp;async_in, &amp;decoder);

        if( NIL_P(decoder) ){
                if( !NIL_P(this-&gt;decoder_for_get_copy_data) ){
                        p_coder = DATA_PTR( this-&gt;decoder_for_get_copy_data );
                }
        } else if( rb_obj_is_kind_of(decoder, rb_cPG_Coder) ) {
                Data_Get_Struct( decoder, t_pg_coder, p_coder );
        } else {
                rb_raise( rb_eTypeError, &quot;wrong decoder type %s (expected some kind of PG::Coder)&quot;,
                                rb_obj_classname( decoder ) );
        }

        ret = gvl_PQgetCopyData(this-&gt;pgconn, &amp;buffer, RTEST(async_in));
        if(ret == -2) { /* error */
                error = rb_exc_new2(rb_ePGerror, PQerrorMessage(this-&gt;pgconn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
        }
        if(ret == -1) { /* No data left */
                return Qnil;
        }
        if(ret == 0) { /* would block */
                return Qfalse;
        }

        if( p_coder ){
                t_pg_coder_dec_func dec_func = pg_coder_dec_func( p_coder, p_coder-&gt;format );
                result =  dec_func( p_coder, buffer, ret, 0, 0, ENCODING_GET(self) );
        } else {
                result = rb_tainted_str_new(buffer, ret);
        }

        PQfreemem(buffer);
        return result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-get_last_result" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            get_last_result( ) &rarr; PG::Result
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This function retrieves all available results on the current connection
(from previously issued asynchronous commands like +send_query()+) and
returns the last non-NULL result, or <code>nil</code> if no results are
available.</p>

<p>This function is similar to <a
href="Connection.html#method-i-get_result">get_result</a> except that it is
designed to get one and only one result.</p>
          
          

          
          <div class="method-source-code" id="get_last_result-source">
            <pre>static VALUE
pgconn_get_last_result(VALUE self)
{
        PGconn *conn = pg_get_pgconn(self);
        VALUE rb_pgresult = Qnil;
        PGresult *cur, *prev;


        cur = prev = NULL;
        while ((cur = gvl_PQgetResult(conn)) != NULL) {
                int status;

                if (prev) PQclear(prev);
                prev = cur;

                status = PQresultStatus(cur);
                if (status == PGRES_COPY_OUT || status == PGRES_COPY_IN)
                        break;
        }

        if (prev) {
                rb_pgresult = pg_new_result( prev, self );
                pg_result_check(rb_pgresult);
        }

        return rb_pgresult;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-get_result" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            get_result() &rarr; PG::Result
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            get_result() {|pg_result| block }
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Blocks waiting for the next result from a call to <a
href="Connection.html#method-i-send_query">send_query</a> (or another
asynchronous command), and returns it. Returns <code>nil</code> if no more
results are available.</p>

<p>Note: call this function repeatedly until it returns <code>nil</code>, or
else you will not be able to issue further commands.</p>

<p>If the optional code block is given, it will be passed <em>result</em> as
an argument, and the <a href="Result.html">PG::Result</a> object will 
automatically be cleared when the block terminates. In this instance,
<code>conn.exec</code> returns the value of the block.</p>
          
          

          
          <div class="method-source-code" id="get_result-source">
            <pre>static VALUE
pgconn_get_result(VALUE self)
{
        PGconn *conn = pg_get_pgconn(self);
        PGresult *result;
        VALUE rb_pgresult;

        result = gvl_PQgetResult(conn);
        if(result == NULL)
                return Qnil;
        rb_pgresult = pg_new_result(result, self);
        if (rb_block_given_p()) {
                return rb_ensure(rb_yield, rb_pgresult,
                        pg_result_clear, rb_pgresult);
        }
        return rb_pgresult;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-host" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            host()
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the connected server name.</p>
          
          

          
          <div class="method-source-code" id="host-source">
            <pre>static VALUE
pgconn_host(VALUE self)
{
        char *host = PQhost(pg_get_pgconn(self));
        if (!host) return Qnil;
        return rb_tainted_str_new2(host);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-internal_encoding" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            internal_encoding &rarr; Encoding
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>defined in Ruby 1.9 or later.</p>

<p>Returns:</p>
<ul><li>
<p>an <a href="../Encoding.html">Encoding</a> - client_encoding of the
connection as a Ruby <a href="../Encoding.html">Encoding</a> object.</p>
</li><li>
<p>nil - the client_encoding is &#39;SQL_ASCII&#39;</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="internal_encoding-source">
            <pre>static VALUE
pgconn_internal_encoding(VALUE self)
{
        PGconn *conn = pg_get_pgconn( self );
        rb_encoding *enc = pg_conn_enc_get( conn );

        if ( enc ) {
                return rb_enc_from_encoding( enc );
        } else {
                return Qnil;
        }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-internal_encoding-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            internal_encoding = value
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>A wrapper of <a
href="Connection.html#method-i-set_client_encoding">set_client_encoding</a>.
defined in Ruby 1.9 or later.</p>

<p><code>value</code> can be one of:</p>
<ul><li>
<p>an <a href="../Encoding.html">Encoding</a></p>
</li><li>
<p>a <a href="../String.html">String</a> - a name of <a
href="../Encoding.html">Encoding</a></p>
</li><li>
<p><code>nil</code> - sets the client_encoding to SQL_ASCII.</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="internal_encoding-3D-source">
            <pre>static VALUE
pgconn_internal_encoding_set(VALUE self, VALUE enc)
{
        VALUE enc_inspect;
        if (NIL_P(enc)) {
                pgconn_set_client_encoding( self, rb_usascii_str_new_cstr(&quot;SQL_ASCII&quot;) );
                return enc;
        }
        else if ( TYPE(enc) == T_STRING &amp;&amp; strcasecmp(&quot;JOHAB&quot;, StringValueCStr(enc)) == 0 ) {
                pgconn_set_client_encoding(self, rb_usascii_str_new_cstr(&quot;JOHAB&quot;));
                return enc;
        }
        else {
                rb_encoding *rbenc = rb_to_encoding( enc );
                const char *name = pg_get_rb_encoding_as_pg_encoding( rbenc );

                if ( gvl_PQsetClientEncoding(pg_get_pgconn( self ), name) == -1 ) {
                        VALUE server_encoding = pgconn_external_encoding( self );
                        rb_raise( rb_eEncCompatError, &quot;incompatible character encodings: %s and %s&quot;,
                                          rb_enc_name(rb_to_encoding(server_encoding)), name );
                }
                pgconn_set_internal_encoding_index( self );
                return enc;
        }

        enc_inspect = rb_inspect(enc);
        rb_raise( rb_ePGerror, &quot;unknown encoding: %s&quot;, StringValueCStr(enc_inspect) );

        return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-is_busy" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            is_busy() &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if a command is busy, that is, if PQgetResult
would block. Otherwise returns <code>false</code>.</p>
          
          

          
          <div class="method-source-code" id="is_busy-source">
            <pre>static VALUE
pgconn_is_busy(self)
        VALUE self;
{
        return gvl_PQisBusy(pg_get_pgconn(self)) ? Qtrue : Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-isnonblocking" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            isnonblocking() &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if a command is busy, that is, if PQgetResult
would block. Otherwise returns <code>false</code>.</p>
          
          

          
          <div class="method-source-code" id="isnonblocking-source">
            <pre>static VALUE
pgconn_isnonblocking(self)
        VALUE self;
{
        return PQisnonblocking(pg_get_pgconn(self)) ? Qtrue : Qfalse;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-nonblocking-3F">nonblocking?</a>
        </div>
        

        
      </div>

    
      <div id="method-i-lo_close" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lo_close( lo_desc ) &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Closes the postgres large object of <em>lo_desc</em>.</p>
          
          

          
          <div class="method-source-code" id="lo_close-source">
            <pre>static VALUE
pgconn_loclose(VALUE self, VALUE in_lo_desc)
{
        PGconn *conn = pg_get_pgconn(self);
        int lo_desc = NUM2INT(in_lo_desc);

        if(lo_close(conn,lo_desc) &lt; 0)
                rb_raise(rb_ePGerror,&quot;lo_close failed&quot;);

        return Qnil;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-loclose">loclose</a>
        </div>
        

        
      </div>

    
      <div id="method-i-lo_creat" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lo_creat( [mode] ) &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a large object with mode <em>mode</em>. Returns a large object Oid.
On failure, it raises <a href="Error.html">PG::Error</a>.</p>
          
          

          
          <div class="method-source-code" id="lo_creat-source">
            <pre>static VALUE
pgconn_locreat(int argc, VALUE *argv, VALUE self)
{
        Oid lo_oid;
        int mode;
        VALUE nmode;
        PGconn *conn = pg_get_pgconn(self);

        if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;nmode) == 0)
                mode = INV_READ;
        else
                mode = NUM2INT(nmode);

        lo_oid = lo_creat(conn, mode);
        if (lo_oid == 0)
                rb_raise(rb_ePGerror, &quot;lo_creat failed&quot;);

        return UINT2NUM(lo_oid);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-locreat">locreat</a>
        </div>
        

        
      </div>

    
      <div id="method-i-lo_create" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lo_create( oid ) &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a large object with oid <em>oid</em>. Returns the large object Oid.
On failure, it raises <a href="Error.html">PG::Error</a>.</p>
          
          

          
          <div class="method-source-code" id="lo_create-source">
            <pre>static VALUE
pgconn_locreate(VALUE self, VALUE in_lo_oid)
{
        Oid ret, lo_oid;
        PGconn *conn = pg_get_pgconn(self);
        lo_oid = NUM2UINT(in_lo_oid);

        ret = lo_create(conn, lo_oid);
        if (ret == InvalidOid)
                rb_raise(rb_ePGerror, &quot;lo_create failed&quot;);

        return UINT2NUM(ret);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-locreate">locreate</a>
        </div>
        

        
      </div>

    
      <div id="method-i-lo_export" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lo_export( oid, file ) &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Saves a large object of <em>oid</em> to a <em>file</em>.</p>
          
          

          
          <div class="method-source-code" id="lo_export-source">
            <pre>static VALUE
pgconn_loexport(VALUE self, VALUE lo_oid, VALUE filename)
{
        PGconn *conn = pg_get_pgconn(self);
        Oid oid;
        Check_Type(filename, T_STRING);

        oid = NUM2UINT(lo_oid);

        if (lo_export(conn, oid, StringValueCStr(filename)) &lt; 0) {
                rb_raise(rb_ePGerror, &quot;%s&quot;, PQerrorMessage(conn));
        }
        return Qnil;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-loexport">loexport</a>
        </div>
        

        
      </div>

    
      <div id="method-i-lo_import" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lo_import(file) &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Import a file to a large object. Returns a large object Oid.</p>

<p>On failure, it raises a <a href="Error.html">PG::Error</a>.</p>
          
          

          
          <div class="method-source-code" id="lo_import-source">
            <pre>static VALUE
pgconn_loimport(VALUE self, VALUE filename)
{
        Oid lo_oid;

        PGconn *conn = pg_get_pgconn(self);

        Check_Type(filename, T_STRING);

        lo_oid = lo_import(conn, StringValueCStr(filename));
        if (lo_oid == 0) {
                rb_raise(rb_ePGerror, &quot;%s&quot;, PQerrorMessage(conn));
        }
        return UINT2NUM(lo_oid);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-loimport">loimport</a>
        </div>
        

        
      </div>

    
      <div id="method-i-lo_lseek" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lo_lseek( lo_desc, offset, whence ) &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Move the large object pointer <em>lo_desc</em> to offset <em>offset</em>.
Valid values for <em>whence</em> are <code>SEEK_SET</code>,
<code>SEEK_CUR</code>, and <code>SEEK_END</code>. (Or 0, 1, or 2.)</p>
          
          

          
          <div class="method-source-code" id="lo_lseek-source">
            <pre>static VALUE
pgconn_lolseek(VALUE self, VALUE in_lo_desc, VALUE offset, VALUE whence)
{
        PGconn *conn = pg_get_pgconn(self);
        int lo_desc = NUM2INT(in_lo_desc);
        int ret;

        if((ret = lo_lseek(conn, lo_desc, NUM2INT(offset), NUM2INT(whence))) &lt; 0) {
                rb_raise(rb_ePGerror, &quot;lo_lseek failed&quot;);
        }

        return INT2FIX(ret);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-lolseek">lolseek</a>, <a href="Connection.html#method-i-lo_seek">lo_seek</a>, <a href="Connection.html#method-i-loseek">loseek</a>
        </div>
        

        
      </div>

    
      <div id="method-i-lo_open" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lo_open( oid, [mode] ) &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Open a large object of <em>oid</em>. Returns a large object descriptor
instance on success. The <em>mode</em> argument specifies the mode for the
opened large object,which is either <code>INV_READ</code>, or
<code>INV_WRITE</code>.</p>

<p>If <em>mode</em> is omitted, the default is <code>INV_READ</code>.</p>
          
          

          
          <div class="method-source-code" id="lo_open-source">
            <pre>static VALUE
pgconn_loopen(int argc, VALUE *argv, VALUE self)
{
        Oid lo_oid;
        int fd, mode;
        VALUE nmode, selfid;
        PGconn *conn = pg_get_pgconn(self);

        rb_scan_args(argc, argv, &quot;11&quot;, &amp;selfid, &amp;nmode);
        lo_oid = NUM2UINT(selfid);
        if(NIL_P(nmode))
                mode = INV_READ;
        else
                mode = NUM2INT(nmode);

        if((fd = lo_open(conn, lo_oid, mode)) &lt; 0) {
                rb_raise(rb_ePGerror, &quot;can&#39;t open large object: %s&quot;, PQerrorMessage(conn));
        }
        return INT2FIX(fd);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-loopen">loopen</a>
        </div>
        

        
      </div>

    
      <div id="method-i-lo_read" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lo_read( lo_desc, len ) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Attempts to read <em>len</em> bytes from large object <em>lo_desc</em>,
returns resulting data.</p>
          
          

          
          <div class="method-source-code" id="lo_read-source">
            <pre>static VALUE
pgconn_loread(VALUE self, VALUE in_lo_desc, VALUE in_len)
{
        int ret;
  PGconn *conn = pg_get_pgconn(self);
        int len = NUM2INT(in_len);
        int lo_desc = NUM2INT(in_lo_desc);
        VALUE str;
        char *buffer;

  buffer = ALLOC_N(char, len);
        if(buffer == NULL)
                rb_raise(rb_eNoMemError, &quot;ALLOC failed!&quot;);

        if (len &lt; 0){
                rb_raise(rb_ePGerror,&quot;nagative length %d given&quot;, len);
        }

        if((ret = lo_read(conn, lo_desc, buffer, len)) &lt; 0)
                rb_raise(rb_ePGerror, &quot;lo_read failed&quot;);

        if(ret == 0) {
                xfree(buffer);
                return Qnil;
        }

        str = rb_tainted_str_new(buffer, ret);
        xfree(buffer);

        return str;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-loread">loread</a>
        </div>
        

        
      </div>

    
      <div id="method-i-lo_seek" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">lo_seek</span><span
            class="method-args">(p1, p2, p3)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-lo_lseek">lo_lseek</a>
        </div>
        
      </div>

    
      <div id="method-i-lo_tell" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lo_tell( lo_desc ) &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the current position of the large object <em>lo_desc</em>.</p>
          
          

          
          <div class="method-source-code" id="lo_tell-source">
            <pre>static VALUE
pgconn_lotell(VALUE self, VALUE in_lo_desc)
{
        int position;
        PGconn *conn = pg_get_pgconn(self);
        int lo_desc = NUM2INT(in_lo_desc);

        if((position = lo_tell(conn, lo_desc)) &lt; 0)
                rb_raise(rb_ePGerror,&quot;lo_tell failed&quot;);

        return INT2FIX(position);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-lotell">lotell</a>
        </div>
        

        
      </div>

    
      <div id="method-i-lo_truncate" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lo_truncate( lo_desc, len ) &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Truncates the large object <em>lo_desc</em> to size <em>len</em>.</p>
          
          

          
          <div class="method-source-code" id="lo_truncate-source">
            <pre>static VALUE
pgconn_lotruncate(VALUE self, VALUE in_lo_desc, VALUE in_len)
{
        PGconn *conn = pg_get_pgconn(self);
        int lo_desc = NUM2INT(in_lo_desc);
        size_t len = NUM2INT(in_len);

        if(lo_truncate(conn,lo_desc,len) &lt; 0)
                rb_raise(rb_ePGerror,&quot;lo_truncate failed&quot;);

        return Qnil;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-lotruncate">lotruncate</a>
        </div>
        

        
      </div>

    
      <div id="method-i-lo_unlink" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lo_unlink( oid ) &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Unlinks (deletes) the postgres large object of <em>oid</em>.</p>
          
          

          
          <div class="method-source-code" id="lo_unlink-source">
            <pre>static VALUE
pgconn_lounlink(VALUE self, VALUE in_oid)
{
        PGconn *conn = pg_get_pgconn(self);
        Oid oid = NUM2UINT(in_oid);

        if(lo_unlink(conn,oid) &lt; 0)
                rb_raise(rb_ePGerror,&quot;lo_unlink failed&quot;);

        return Qnil;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-lounlink">lounlink</a>
        </div>
        

        
      </div>

    
      <div id="method-i-lo_write" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lo_write( lo_desc, buffer ) &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Writes the string <em>buffer</em> to the large object <em>lo_desc</em>.
Returns the number of bytes written.</p>
          
          

          
          <div class="method-source-code" id="lo_write-source">
            <pre>static VALUE
pgconn_lowrite(VALUE self, VALUE in_lo_desc, VALUE buffer)
{
        int n;
        PGconn *conn = pg_get_pgconn(self);
        int fd = NUM2INT(in_lo_desc);

        Check_Type(buffer, T_STRING);

        if( RSTRING_LEN(buffer) &lt; 0) {
                rb_raise(rb_ePGerror, &quot;write buffer zero string&quot;);
        }
        if((n = lo_write(conn, fd, StringValuePtr(buffer),
                                RSTRING_LEN(buffer))) &lt; 0) {
                rb_raise(rb_ePGerror, &quot;lo_write failed: %s&quot;, PQerrorMessage(conn));
        }

        return INT2FIX(n);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-lowrite">lowrite</a>
        </div>
        

        
      </div>

    
      <div id="method-i-loclose" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">loclose</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-lo_close">lo_close</a>
        </div>
        
      </div>

    
      <div id="method-i-locreat" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">locreat</span><span
            class="method-args">(p1 = v1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-lo_creat">lo_creat</a>
        </div>
        
      </div>

    
      <div id="method-i-locreate" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">locreate</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-lo_create">lo_create</a>
        </div>
        
      </div>

    
      <div id="method-i-loexport" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">loexport</span><span
            class="method-args">(p1, p2)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-lo_export">lo_export</a>
        </div>
        
      </div>

    
      <div id="method-i-loimport" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">loimport</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-lo_import">lo_import</a>
        </div>
        
      </div>

    
      <div id="method-i-lolseek" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">lolseek</span><span
            class="method-args">(p1, p2, p3)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-lo_lseek">lo_lseek</a>
        </div>
        
      </div>

    
      <div id="method-i-loopen" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">loopen</span><span
            class="method-args">(p1, p2 = v2)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-lo_open">lo_open</a>
        </div>
        
      </div>

    
      <div id="method-i-loread" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">loread</span><span
            class="method-args">(p1, p2)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-lo_read">lo_read</a>
        </div>
        
      </div>

    
      <div id="method-i-loseek" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">loseek</span><span
            class="method-args">(p1, p2, p3)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-lo_lseek">lo_lseek</a>
        </div>
        
      </div>

    
      <div id="method-i-lotell" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">lotell</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-lo_tell">lo_tell</a>
        </div>
        
      </div>

    
      <div id="method-i-lotruncate" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">lotruncate</span><span
            class="method-args">(p1, p2)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-lo_truncate">lo_truncate</a>
        </div>
        
      </div>

    
      <div id="method-i-lounlink" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">lounlink</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-lo_unlink">lo_unlink</a>
        </div>
        
      </div>

    
      <div id="method-i-lowrite" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">lowrite</span><span
            class="method-args">(p1, p2)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-lo_write">lo_write</a>
        </div>
        
      </div>

    
      <div id="method-i-make_empty_pgresult" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            make_empty_pgresult( status ) &rarr; PG::Result
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Constructs and empty <a href="Result.html">PG::Result</a> with status
<em>status</em>. <em>status</em> may be one of:</p>
<ul><li>
<p><code>PGRES_EMPTY_QUERY</code></p>
</li><li>
<p><code>PGRES_COMMAND_OK</code></p>
</li><li>
<p><code>PGRES_TUPLES_OK</code></p>
</li><li>
<p><code>PGRES_COPY_OUT</code></p>
</li><li>
<p><code>PGRES_COPY_IN</code></p>
</li><li>
<p><code>PGRES_BAD_RESPONSE</code></p>
</li><li>
<p><code>PGRES_NONFATAL_ERROR</code></p>
</li><li>
<p><code>PGRES_FATAL_ERROR</code></p>
</li><li>
<p><code>PGRES_COPY_BOTH</code></p>
</li></ul>
          
          

          
          <div class="method-source-code" id="make_empty_pgresult-source">
            <pre>static VALUE
pgconn_make_empty_pgresult(VALUE self, VALUE status)
{
        PGresult *result;
        VALUE rb_pgresult;
        PGconn *conn = pg_get_pgconn(self);
        result = PQmakeEmptyPGresult(conn, NUM2INT(status));
        rb_pgresult = pg_new_result(result, self);
        pg_result_check(rb_pgresult);
        return rb_pgresult;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-nonblocking-3F" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">nonblocking?</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-isnonblocking">isnonblocking</a>
        </div>
        
      </div>

    
      <div id="method-i-notifies" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            notifies()
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a hash of the unprocessed notifications. If there is no unprocessed
notifier, it returns <code>nil</code>.</p>
          
          

          
          <div class="method-source-code" id="notifies-source">
            <pre>static VALUE
pgconn_notifies(VALUE self)
{
        PGconn* conn = pg_get_pgconn(self);
        PGnotify *notification;
        VALUE hash;
        VALUE sym_relname, sym_be_pid, sym_extra;
        VALUE relname, be_pid, extra;

        sym_relname = ID2SYM(rb_intern(&quot;relname&quot;));
        sym_be_pid = ID2SYM(rb_intern(&quot;be_pid&quot;));
        sym_extra = ID2SYM(rb_intern(&quot;extra&quot;));

        notification = gvl_PQnotifies(conn);
        if (notification == NULL) {
                return Qnil;
        }

        hash = rb_hash_new();
        relname = rb_tainted_str_new2(notification-&gt;relname);
        be_pid = INT2NUM(notification-&gt;be_pid);
        extra = rb_tainted_str_new2(notification-&gt;extra);
        PG_ENCODING_SET_NOCHECK( relname, ENCODING_GET(self) );
        PG_ENCODING_SET_NOCHECK( extra, ENCODING_GET(self) );

        rb_hash_aset(hash, sym_relname, relname);
        rb_hash_aset(hash, sym_be_pid, be_pid);
        rb_hash_aset(hash, sym_extra, extra);

        PQfreemem(notification);
        return hash;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-notifies_wait" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">notifies_wait</span><span
            class="method-args">(p1 = v1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-wait_for_notify">wait_for_notify</a>
        </div>
        
      </div>

    
      <div id="method-i-options" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            options()
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns backend option string.</p>
          
          

          
          <div class="method-source-code" id="options-source">
            <pre>static VALUE
pgconn_options(VALUE self)
{
        char *options = PQoptions(pg_get_pgconn(self));
        if (!options) return Qnil;
        return rb_tainted_str_new2(options);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-parameter_status" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            parameter_status( param_name ) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the setting of parameter <em>param_name</em>, where
<em>param_name</em> is one of</p>
<ul><li>
<p><code>server_version</code></p>
</li><li>
<p><code>server_encoding</code></p>
</li><li>
<p><code>client_encoding</code></p>
</li><li>
<p><code>is_superuser</code></p>
</li><li>
<p><code>session_authorization</code></p>
</li><li>
<p><code>DateStyle</code></p>
</li><li>
<p><code>TimeZone</code></p>
</li><li>
<p><code>integer_datetimes</code></p>
</li><li>
<p><code>standard_conforming_strings</code></p>
</li></ul>

<p>Returns nil if the value of the parameter is not known.</p>
          
          

          
          <div class="method-source-code" id="parameter_status-source">
            <pre>static VALUE
pgconn_parameter_status(VALUE self, VALUE param_name)
{
        const char *ret = PQparameterStatus(pg_get_pgconn(self), StringValueCStr(param_name));
        if(ret == NULL)
                return Qnil;
        else
                return rb_tainted_str_new2(ret);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-pass" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            pass()
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the authenticated password.</p>
          
          

          
          <div class="method-source-code" id="pass-source">
            <pre>static VALUE
pgconn_pass(VALUE self)
{
        char *user = PQpass(pg_get_pgconn(self));
        if (!user) return Qnil;
        return rb_tainted_str_new2(user);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-port" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            port()
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the connected server port number.</p>
          
          

          
          <div class="method-source-code" id="port-source">
            <pre>static VALUE
pgconn_port(VALUE self)
{
        char* port = PQport(pg_get_pgconn(self));
        return INT2NUM(atol(port));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-prepare" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            prepare(stmt_name, sql [, param_types ] ) &rarr; PG::Result
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Prepares statement <em>sql</em> with name <em>name</em> to be executed
later. Returns a <a href="Result.html">PG::Result</a> instance on success.
On failure, it raises a <a href="Error.html">PG::Error</a>.</p>

<p><code>param_types</code> is an optional parameter to specify the Oids of
the types of the parameters.</p>

<p>If the types are not specified, they will be inferred by PostgreSQL.
Instead of specifying type oids, it&#39;s recommended to simply add
explicit casts in the query to ensure that the right type is used.</p>

<p>For example: “SELECT $1::int”</p>

<p>PostgreSQL bind parameters are represented as $1, $1, $2, etc., inside the
SQL query.</p>
          
          

          
          <div class="method-source-code" id="prepare-source">
            <pre>static VALUE
pgconn_prepare(int argc, VALUE *argv, VALUE self)
{
        PGconn *conn = pg_get_pgconn(self);
        PGresult *result = NULL;
        VALUE rb_pgresult;
        VALUE name, command, in_paramtypes;
        VALUE param;
        int i = 0;
        int nParams = 0;
        Oid *paramTypes = NULL;
        const char *name_cstr;
        const char *command_cstr;
        int enc_idx = ENCODING_GET(self);

        rb_scan_args(argc, argv, &quot;21&quot;, &amp;name, &amp;command, &amp;in_paramtypes);
        name_cstr = pg_cstr_enc(name, enc_idx);
        command_cstr = pg_cstr_enc(command, enc_idx);

        if(! NIL_P(in_paramtypes)) {
                Check_Type(in_paramtypes, T_ARRAY);
                nParams = (int)RARRAY_LEN(in_paramtypes);
                paramTypes = ALLOC_N(Oid, nParams);
                for(i = 0; i &lt; nParams; i++) {
                        param = rb_ary_entry(in_paramtypes, i);
                        if(param == Qnil)
                                paramTypes[i] = 0;
                        else
                                paramTypes[i] = NUM2UINT(param);
                }
        }
        result = gvl_PQprepare(conn, name_cstr, command_cstr, nParams, paramTypes);

        xfree(paramTypes);

        rb_pgresult = pg_new_result(result, self);
        pg_result_check(rb_pgresult);
        return rb_pgresult;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-protocol_version" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            protocol_version &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>The 3.0 protocol will normally be used when communicating with PostgreSQL
7.4 or later servers; pre-7.4 servers support only protocol 2.0. (Protocol
1.0 is obsolete and not supported by libpq.)</p>
          
          

          
          <div class="method-source-code" id="protocol_version-source">
            <pre>static VALUE
pgconn_protocol_version(VALUE self)
{
        return INT2NUM(PQprotocolVersion(pg_get_pgconn(self)));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-put_copy_data" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            put_copy_data( buffer [, encoder] ) &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Transmits <em>buffer</em> as copy data to the server. Returns true if the
data was sent, false if it was not sent (false is only possible if the
connection is in nonblocking mode, and this command would block).</p>

<p><em>encoder</em> can be a <a href="Coder.html">PG::Coder</a> derivation
(typically <a
href="TextEncoder/CopyRow.html">PG::TextEncoder::CopyRow</a>). This encodes
the data fields given as <em>buffer</em> from an <a
href="../Array.html">Array</a> of Strings to PostgreSQL&#39;s COPY text
format inclusive proper escaping. Optionally the encoder can type cast the
fields from various Ruby types in one step, if <a
href="CopyCoder.html#method-i-type_map">PG::CopyCoder#type_map</a> is set
accordingly.</p>

<p>Raises an exception if an error occurs.</p>

<p>See also <a href="Connection.html#method-i-copy_data">copy_data</a>.</p>
          
          

          
          <div class="method-source-code" id="put_copy_data-source">
            <pre>static VALUE
pgconn_put_copy_data(int argc, VALUE *argv, VALUE self)
{
        int ret;
        int len;
        t_pg_connection *this = pg_get_connection_safe( self );
        VALUE value;
        VALUE buffer = Qnil;
        VALUE encoder;
        VALUE intermediate;
        t_pg_coder *p_coder = NULL;

        rb_scan_args( argc, argv, &quot;11&quot;, &amp;value, &amp;encoder );

        if( NIL_P(encoder) ){
                if( NIL_P(this-&gt;encoder_for_put_copy_data) ){
                        buffer = value;
                } else {
                        p_coder = DATA_PTR( this-&gt;encoder_for_put_copy_data );
                }
        } else if( rb_obj_is_kind_of(encoder, rb_cPG_Coder) ) {
                Data_Get_Struct( encoder, t_pg_coder, p_coder );
        } else {
                rb_raise( rb_eTypeError, &quot;wrong encoder type %s (expected some kind of PG::Coder)&quot;,
                                rb_obj_classname( encoder ) );
        }

        if( p_coder ){
                t_pg_coder_enc_func enc_func;
                int enc_idx = ENCODING_GET(self);

                enc_func = pg_coder_enc_func( p_coder );
                len = enc_func( p_coder, value, NULL, &amp;intermediate, enc_idx);

                if( len == -1 ){
                        /* The intermediate value is a String that can be used directly. */
                        buffer = intermediate;
                } else {
                        buffer = rb_str_new(NULL, len);
                        len = enc_func( p_coder, value, RSTRING_PTR(buffer), &amp;intermediate, enc_idx);
                        rb_str_set_len( buffer, len );
                }
        }

        Check_Type(buffer, T_STRING);

        ret = gvl_PQputCopyData(this-&gt;pgconn, RSTRING_PTR(buffer), RSTRING_LENINT(buffer));
        if(ret == -1) {
                VALUE error = rb_exc_new2(rb_ePGerror, PQerrorMessage(this-&gt;pgconn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
        }
        RB_GC_GUARD(intermediate);
        RB_GC_GUARD(buffer);

        return (ret) ? Qtrue : Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-put_copy_end" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            put_copy_end( [ error_message ] ) &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sends end-of-data indication to the server.</p>

<p><em>error_message</em> is an optional parameter, and if set, forces the
COPY command to fail with the string <em>error_message</em>.</p>

<p>Returns true if the end-of-data was sent, false if it was not sent (false
is only possible if the connection is in nonblocking mode, and this command
would block).</p>
          
          

          
          <div class="method-source-code" id="put_copy_end-source">
            <pre>static VALUE
pgconn_put_copy_end(int argc, VALUE *argv, VALUE self)
{
        VALUE str;
        VALUE error;
        int ret;
        const char *error_message = NULL;
        PGconn *conn = pg_get_pgconn(self);

        if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;str) == 0)
                error_message = NULL;
        else
                error_message = pg_cstr_enc(str, ENCODING_GET(self));

        ret = gvl_PQputCopyEnd(conn, error_message);
        if(ret == -1) {
                error = rb_exc_new2(rb_ePGerror, PQerrorMessage(conn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
        }
        return (ret) ? Qtrue : Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-query" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">query</span><span
            class="method-args">(*args)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Connection.html#method-i-exec">exec</a>
        </div>
        
      </div>

    
      <div id="method-i-quote_ident" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            quote_ident( str ) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            quote_ident( array ) &rarr; String
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.quote_ident( str ) &rarr; String
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.quote_ident( array ) &rarr; String
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a string that is safe for inclusion in a SQL query as an
identifier. Note: this is not a quote function for values, but for
identifiers.</p>

<p>For example, in a typical SQL query: <code>SELECT FOO FROM MYTABLE</code>
The identifier <code>FOO</code> is folded to lower case, so it actually
means <code>foo</code>. If you really want to access the case-sensitive
field name <code>FOO</code>, use this function like
<code>conn.quote_ident(&#39;FOO&#39;)</code>, which will return
<code>&quot;FOO&quot;</code> (with double-quotes). PostgreSQL will see the
double-quotes, and it will not fold to lower case.</p>

<p>Similarly, this function also protects against special characters, and
other things that might allow SQL injection if the identifier comes from an
untrusted source.</p>

<p>If the parameter is an <a href="../Array.html">Array</a>, then all it&#39;s
values are separately quoted and then joined by a “.” character. This can
be used for identifiers in the form “schema”.“table”.“column” .</p>

<p>This method is functional identical to the encoder <a
href="TextEncoder/Identifier.html">PG::TextEncoder::Identifier</a> .</p>

<p>If the instance method form is used and the input string character encoding
is different to the connection encoding, then the string is converted to
this encoding, so that the returned string is always encoded as <a
href="Connection.html#method-i-internal_encoding">#internal_encoding</a> .</p>

<p>In the singleton form (PG::Connection.quote_ident) the character encoding
of the result string is set to the character encoding of the input string.</p>
          
          

          
          <div class="method-source-code" id="quote_ident-source">
            <pre>static VALUE
pgconn_s_quote_ident(VALUE self, VALUE str_or_array)
{
        VALUE ret;
        int enc_idx;

        if( rb_obj_is_kind_of(self, rb_cPGconn) ){
                enc_idx = ENCODING_GET( self );
        }else{
                enc_idx = RB_TYPE_P(str_or_array, T_STRING) ? ENCODING_GET( str_or_array ) : rb_ascii8bit_encindex();
        }
        pg_text_enc_identifier(NULL, str_or_array, NULL, &amp;ret, enc_idx);

        OBJ_INFECT(ret, str_or_array);

        return ret;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reset" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reset()
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Resets the backend connection. This method closes the backend connection
and tries to re-connect.</p>
          
          

          
          <div class="method-source-code" id="reset-source">
            <pre>static VALUE
pgconn_reset( VALUE self )
{
        pgconn_close_socket_io( self );
        gvl_PQreset( pg_get_pgconn(self) );
        return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reset_poll" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reset_poll &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Checks the status of a connection reset operation. See connect_start and <a
href="Connection.html#method-i-connect_poll">connect_poll</a> for usage
information and return values.</p>
          
          

          
          <div class="method-source-code" id="reset_poll-source">
            <pre>static VALUE
pgconn_reset_poll(VALUE self)
{
        PostgresPollingStatusType status;
        status = gvl_PQresetPoll(pg_get_pgconn(self));
        return INT2FIX((int)status);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reset_start" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reset_start() &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Initiate a connection reset in a nonblocking manner. This will close the
current connection and attempt to reconnect using the same connection
parameters. Use <a
href="Connection.html#method-i-reset_poll">reset_poll</a> to check the
status of the connection reset.</p>
          
          

          
          <div class="method-source-code" id="reset_start-source">
            <pre>static VALUE
pgconn_reset_start(VALUE self)
{
        pgconn_close_socket_io( self );
        if(gvl_PQresetStart(pg_get_pgconn(self)) == 0)
                rb_raise(rb_eUnableToSend, &quot;reset has failed&quot;);
        return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-send_describe_portal" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            send_describe_portal( portal_name ) &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Asynchronously send <em>command</em> to the server. Does not block. Use in
combination with <code>conn.get_result</code>.</p>
          
          

          
          <div class="method-source-code" id="send_describe_portal-source">
            <pre>static VALUE
pgconn_send_describe_portal(VALUE self, VALUE portal)
{
        VALUE error;
        PGconn *conn = pg_get_pgconn(self);
        /* returns 0 on failure */
        if(gvl_PQsendDescribePortal(conn, pg_cstr_enc(portal, ENCODING_GET(self))) == 0) {
                error = rb_exc_new2(rb_eUnableToSend, PQerrorMessage(conn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
        }
        return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-send_describe_prepared" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            send_describe_prepared( statement_name ) &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Asynchronously send <em>command</em> to the server. Does not block. Use in
combination with <code>conn.get_result</code>.</p>
          
          

          
          <div class="method-source-code" id="send_describe_prepared-source">
            <pre>static VALUE
pgconn_send_describe_prepared(VALUE self, VALUE stmt_name)
{
        VALUE error;
        PGconn *conn = pg_get_pgconn(self);
        /* returns 0 on failure */
        if(gvl_PQsendDescribePrepared(conn, pg_cstr_enc(stmt_name, ENCODING_GET(self))) == 0) {
                error = rb_exc_new2(rb_eUnableToSend, PQerrorMessage(conn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
        }
        return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-send_prepare" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            send_prepare( stmt_name, sql [, param_types ] ) &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Prepares statement <em>sql</em> with name <em>name</em> to be executed
later. Sends prepare command asynchronously, and returns immediately. On
failure, it raises a <a href="Error.html">PG::Error</a>.</p>

<p><code>param_types</code> is an optional parameter to specify the Oids of
the types of the parameters.</p>

<p>If the types are not specified, they will be inferred by PostgreSQL.
Instead of specifying type oids, it&#39;s recommended to simply add
explicit casts in the query to ensure that the right type is used.</p>

<p>For example: “SELECT $1::int”</p>

<p>PostgreSQL bind parameters are represented as $1, $1, $2, etc., inside the
SQL query.</p>
          
          

          
          <div class="method-source-code" id="send_prepare-source">
            <pre>static VALUE
pgconn_send_prepare(int argc, VALUE *argv, VALUE self)
{
        PGconn *conn = pg_get_pgconn(self);
        int result;
        VALUE name, command, in_paramtypes;
        VALUE param;
        VALUE error;
        int i = 0;
        int nParams = 0;
        Oid *paramTypes = NULL;
        const char *name_cstr;
        const char *command_cstr;
        int enc_idx = ENCODING_GET(self);

        rb_scan_args(argc, argv, &quot;21&quot;, &amp;name, &amp;command, &amp;in_paramtypes);
        name_cstr = pg_cstr_enc(name, enc_idx);
        command_cstr = pg_cstr_enc(command, enc_idx);

        if(! NIL_P(in_paramtypes)) {
                Check_Type(in_paramtypes, T_ARRAY);
                nParams = (int)RARRAY_LEN(in_paramtypes);
                paramTypes = ALLOC_N(Oid, nParams);
                for(i = 0; i &lt; nParams; i++) {
                        param = rb_ary_entry(in_paramtypes, i);
                        if(param == Qnil)
                                paramTypes[i] = 0;
                        else
                                paramTypes[i] = NUM2UINT(param);
                }
        }
        result = gvl_PQsendPrepare(conn, name_cstr, command_cstr, nParams, paramTypes);

        xfree(paramTypes);

        if(result == 0) {
                error = rb_exc_new2(rb_eUnableToSend, PQerrorMessage(conn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
        }
        return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-send_query" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            send_query(sql [, params, result_format[, type_map ]] ) &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sends SQL query request specified by <em>sql</em> to PostgreSQL for
asynchronous processing, and immediately returns. On failure, it raises a
<a href="Error.html">PG::Error</a>.</p>

<p><code>params</code> is an optional array of the bind parameters for the SQL
query. Each element of the <code>params</code> array may be either:</p>

<pre>a hash of the form:
  {:value  =&gt; String (value of bind parameter)
   :type   =&gt; Integer (oid of type of bind parameter)
   :format =&gt; Integer (0 for text, 1 for binary)
  }
or, it may be a String. If it is a string, that is equivalent to the hash:
  { :value =&gt; &lt;string value&gt;, :type =&gt; 0, :format =&gt; 0 }</pre>

<p>PostgreSQL bind parameters are represented as $1, $1, $2, etc., inside the
SQL query. The 0th element of the <code>params</code> array is bound to $1,
the 1st element is bound to $2, etc. <code>nil</code> is treated as
<code>NULL</code>.</p>

<p>If the types are not specified, they will be inferred by PostgreSQL.
Instead of specifying type oids, it&#39;s recommended to simply add
explicit casts in the query to ensure that the right type is used.</p>

<p>For example: “SELECT $1::int”</p>

<p>The optional <code>result_format</code> should be 0 for text results, 1 for
binary.</p>

<p>type_map can be a <a href="TypeMap.html">PG::TypeMap</a> derivation (such
as <a href="BasicTypeMapForQueries.html">PG::BasicTypeMapForQueries</a>).
This will type cast the params from various Ruby types before transmission
based on the encoders defined by the type map. When a type encoder is used
the format and oid of a given bind parameter are retrieved from the encoder
instead out of the hash form described above.</p>
          
          

          
          <div class="method-source-code" id="send_query-source">
            <pre>static VALUE
pgconn_send_query(int argc, VALUE *argv, VALUE self)
{
        PGconn *conn = pg_get_pgconn(self);
        int result;
        VALUE command, in_res_fmt;
        VALUE error;
        int nParams;
        int resultFormat;
        struct query_params_data paramsData = { ENCODING_GET(self) };

        rb_scan_args(argc, argv, &quot;13&quot;, &amp;command, &amp;paramsData.params, &amp;in_res_fmt, &amp;paramsData.typemap);
        paramsData.with_types = 1;

        /* If called with no parameters, use PQsendQuery */
        if(NIL_P(paramsData.params)) {
                if(gvl_PQsendQuery(conn, pg_cstr_enc(command, paramsData.enc_idx)) == 0) {
                        error = rb_exc_new2(rb_eUnableToSend, PQerrorMessage(conn));
                        rb_iv_set(error, &quot;@connection&quot;, self);
                        rb_exc_raise(error);
                }
                return Qnil;
        }

        /* If called with parameters, and optionally result_format,
         * use PQsendQueryParams
         */

        pgconn_query_assign_typemap( self, &amp;paramsData );
        resultFormat = NIL_P(in_res_fmt) ? 0 : NUM2INT(in_res_fmt);
        nParams = alloc_query_params( &amp;paramsData );

        result = gvl_PQsendQueryParams(conn, pg_cstr_enc(command, paramsData.enc_idx), nParams, paramsData.types,
                (const char * const *)paramsData.values, paramsData.lengths, paramsData.formats, resultFormat);

        free_query_params( &amp;paramsData );

        if(result == 0) {
                error = rb_exc_new2(rb_eUnableToSend, PQerrorMessage(conn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
        }
        return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-send_query_prepared" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            send_query_prepared( statement_name [, params, result_format[, type_map ]] )
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            &rarr; nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Execute prepared named statement specified by <em>statement_name</em>
asynchronously, and returns immediately. On failure, it raises a <a
href="Error.html">PG::Error</a>.</p>

<p><code>params</code> is an array of the optional bind parameters for the SQL
query. Each element of the <code>params</code> array may be either:</p>

<pre>a hash of the form:
  {:value  =&gt; String (value of bind parameter)
   :format =&gt; Integer (0 for text, 1 for binary)
  }
or, it may be a String. If it is a string, that is equivalent to the hash:
  { :value =&gt; &lt;string value&gt;, :format =&gt; 0 }</pre>

<p>PostgreSQL bind parameters are represented as $1, $1, $2, etc., inside the
SQL query. The 0th element of the <code>params</code> array is bound to $1,
the 1st element is bound to $2, etc. <code>nil</code> is treated as
<code>NULL</code>.</p>

<p>The optional <code>result_format</code> should be 0 for text results, 1 for
binary.</p>

<p>type_map can be a <a href="TypeMap.html">PG::TypeMap</a> derivation (such
as <a href="BasicTypeMapForQueries.html">PG::BasicTypeMapForQueries</a>).
This will type cast the params from various Ruby types before transmission
based on the encoders defined by the type map. When a type encoder is used
the format and oid of a given bind parameter are retrieved from the encoder
instead out of the hash form described above.</p>
          
          

          
          <div class="method-source-code" id="send_query_prepared-source">
            <pre>static VALUE
pgconn_send_query_prepared(int argc, VALUE *argv, VALUE self)
{
        PGconn *conn = pg_get_pgconn(self);
        int result;
        VALUE name, in_res_fmt;
        VALUE error;
        int nParams;
        int resultFormat;
        struct query_params_data paramsData = { ENCODING_GET(self) };

        rb_scan_args(argc, argv, &quot;13&quot;, &amp;name, &amp;paramsData.params, &amp;in_res_fmt, &amp;paramsData.typemap);
        paramsData.with_types = 0;

        if(NIL_P(paramsData.params)) {
                paramsData.params = rb_ary_new2(0);
                resultFormat = 0;
        }
        pgconn_query_assign_typemap( self, &amp;paramsData );

        resultFormat = NIL_P(in_res_fmt) ? 0 : NUM2INT(in_res_fmt);
        nParams = alloc_query_params( &amp;paramsData );

        result = gvl_PQsendQueryPrepared(conn, pg_cstr_enc(name, paramsData.enc_idx), nParams,
                (const char * const *)paramsData.values, paramsData.lengths, paramsData.formats,
                resultFormat);

        free_query_params( &amp;paramsData );

        if(result == 0) {
                error = rb_exc_new2(rb_eUnableToSend, PQerrorMessage(conn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
        }
        return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-server_version" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            server_version &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>The number is formed by converting the major, minor, and revision numbers
into two-decimal-digit numbers and appending them together. For example,
version 7.4.2 will be returned as 70402, and version 8.1 will be returned
as 80100 (leading zeroes are not shown). Zero is returned if the connection
is bad.</p>
          
          

          
          <div class="method-source-code" id="server_version-source">
            <pre>static VALUE
pgconn_server_version(VALUE self)
{
        return INT2NUM(PQserverVersion(pg_get_pgconn(self)));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-set_client_encoding" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            set_client_encoding( encoding )
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sets the client encoding to the <em>encoding</em> <a
href="../String.html">String</a>.</p>
          
          

          
          <div class="method-source-code" id="set_client_encoding-source">
            <pre>static VALUE
pgconn_set_client_encoding(VALUE self, VALUE str)
{
        PGconn *conn = pg_get_pgconn( self );

        Check_Type(str, T_STRING);

        if ( (gvl_PQsetClientEncoding(conn, StringValueCStr(str))) == -1 ) {
                rb_raise(rb_ePGerror, &quot;%s&quot;, PQerrorMessage(conn));
        }
        pgconn_set_internal_encoding_index( self );

        return Qnil;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-client_encoding-3D">client_encoding=</a>
        </div>
        

        
      </div>

    
      <div id="method-i-set_default_encoding" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            set_default_encoding() &rarr; Encoding
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>If Ruby has its Encoding.default_internal set, set PostgreSQL&#39;s
client_encoding to match. Returns the new <a
href="../Encoding.html">Encoding</a>, or <code>nil</code> if the default
internal encoding wasn&#39;t set.</p>
          
          

          
          <div class="method-source-code" id="set_default_encoding-source">
            <pre>static VALUE
pgconn_set_default_encoding( VALUE self )
{
        PGconn *conn = pg_get_pgconn( self );
        rb_encoding *enc;
        const char *encname;

        if (( enc = rb_default_internal_encoding() )) {
                encname = pg_get_rb_encoding_as_pg_encoding( enc );
                if ( pgconn_set_client_encoding_async(self, encname) != 0 )
                        rb_warn( &quot;Failed to set the default_internal encoding to %s: &#39;%s&#39;&quot;,
                                 encname, PQerrorMessage(conn) );
                pgconn_set_internal_encoding_index( self );
                return rb_enc_from_encoding( enc );
        } else {
                pgconn_set_internal_encoding_index( self );
                return Qnil;
        }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-set_error_verbosity" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            set_error_verbosity( verbosity ) &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sets connection&#39;s verbosity to <em>verbosity</em> and returns the
previous setting. Available settings are:</p>
<ul><li>
<p>PQERRORS_TERSE</p>
</li><li>
<p>PQERRORS_DEFAULT</p>
</li><li>
<p>PQERRORS_VERBOSE</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="set_error_verbosity-source">
            <pre>static VALUE
pgconn_set_error_verbosity(VALUE self, VALUE in_verbosity)
{
        PGconn *conn = pg_get_pgconn(self);
        PGVerbosity verbosity = NUM2INT(in_verbosity);
        return INT2FIX(PQsetErrorVerbosity(conn, verbosity));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-set_notice_processor" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            set_notice_processor {|message| ... } &rarr; Proc
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>See <a
href="Connection.html#method-i-set_notice_receiver">set_notice_receiver</a>
for the desription of what this and the notice_processor methods do.</p>

<p>This function takes a new block to act as the notice processor and returns
the <a href="../Proc.html">Proc</a> object previously set, or
<code>nil</code> if it was previously the default. The block should accept
a single <a href="../String.html">String</a> object.</p>

<p>If you pass no arguments, it will reset the handler to the default.</p>
          
          

          
          <div class="method-source-code" id="set_notice_processor-source">
            <pre>static VALUE
pgconn_set_notice_processor(VALUE self)
{
        VALUE proc, old_proc;
        t_pg_connection *this = pg_get_connection_safe( self );

        /* If default_notice_processor is unset, assume that the current
         * notice processor is the default, and save it to a global variable.
         * This should not be a problem because the default processor is
         * always the same, so won&#39;t vary among connections.
         */
        if(default_notice_processor == NULL)
                default_notice_processor = PQsetNoticeProcessor(this-&gt;pgconn, NULL, NULL);

        old_proc = this-&gt;notice_receiver;
        if( rb_block_given_p() ) {
                proc = rb_block_proc();
                PQsetNoticeProcessor(this-&gt;pgconn, gvl_notice_processor_proxy, (void *)self);
        } else {
                /* if no block is given, set back to default */
                proc = Qnil;
                PQsetNoticeProcessor(this-&gt;pgconn, default_notice_processor, NULL);
        }

        this-&gt;notice_receiver = proc;
        return old_proc;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-set_notice_receiver" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            set_notice_receiver {|result| ... } &rarr; Proc
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Notice and warning messages generated by the server are not returned by the
query execution functions, since they do not imply failure of the query.
Instead they are passed to a notice handling function, and execution
continues normally after the handler returns. The default notice handling
function prints the message on <code>stderr</code>, but the application can
override this behavior by supplying its own handling function.</p>

<p>For historical reasons, there are two levels of notice handling, called the
notice receiver and notice processor. The default behavior is for the
notice receiver to format the notice and pass a string to the notice
processor for printing. However, an application that chooses to provide its
own notice receiver will typically ignore the notice processor layer and
just do all the work in the notice receiver.</p>

<p>This function takes a new block to act as the handler, which should accept
a single parameter that will be a <a href="Result.html">PG::Result</a>
object, and returns the <a href="../Proc.html">Proc</a> object previously
set, or <code>nil</code> if it was previously the default.</p>

<p>If you pass no arguments, it will reset the handler to the default.</p>

<p><strong>Note:</strong> The <code>result</code> passed to the block should
not be used outside of the block, since the corresponding C object could be
freed after the block finishes.</p>
          
          

          
          <div class="method-source-code" id="set_notice_receiver-source">
            <pre>static VALUE
pgconn_set_notice_receiver(VALUE self)
{
        VALUE proc, old_proc;
        t_pg_connection *this = pg_get_connection_safe( self );

        /* If default_notice_receiver is unset, assume that the current
         * notice receiver is the default, and save it to a global variable.
         * This should not be a problem because the default receiver is
         * always the same, so won&#39;t vary among connections.
         */
        if(default_notice_receiver == NULL)
                default_notice_receiver = PQsetNoticeReceiver(this-&gt;pgconn, NULL, NULL);

        old_proc = this-&gt;notice_receiver;
        if( rb_block_given_p() ) {
                proc = rb_block_proc();
                PQsetNoticeReceiver(this-&gt;pgconn, gvl_notice_receiver_proxy, (void *)self);
        } else {
                /* if no block is given, set back to default */
                proc = Qnil;
                PQsetNoticeReceiver(this-&gt;pgconn, default_notice_receiver, NULL);
        }

        this-&gt;notice_receiver = proc;
        return old_proc;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-set_single_row_mode" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            set_single_row_mode &rarr; self
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>To enter single-row mode, call this method immediately after a successful
call of <a href="Connection.html#method-i-send_query">#send_query</a> (or a
sibling function). This mode selection is effective only for the currently
executing query. Then call <a
href="Connection.html#method-i-get_result">#get_result</a> repeatedly,
until it returns nil.</p>

<p>Each (but the last) received Result has exactly one row and a
Result#result_status of PGRES_SINGLE_TUPLE. The last Result has zero rows
and is used to indicate a successful execution of the query. All of these
Result objects will contain the same row description data (column names,
types, etc) that an ordinary Result object for the query would have.</p>

<p><strong>Caution:</strong> While processing a query, the server may return
some rows and then encounter an error, causing the query to be aborted.
Ordinarily, pg discards any such rows and reports only the error. But in
single-row mode, those rows will have already been returned to the
application. Hence, the application will see some Result objects followed
by an <a href="../Error.html">Error</a> raised in get_result. For proper
transactional behavior, the application must be designed to discard or undo
whatever has been done with the previously-processed rows, if the query
ultimately fails.</p>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">conn</span>.<span class="ruby-identifier">send_query</span>( <span class="ruby-string">&quot;your SQL command&quot;</span> )
<span class="ruby-identifier">conn</span>.<span class="ruby-identifier">set_single_row_mode</span>
<span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">res</span> = <span class="ruby-identifier">conn</span>.<span class="ruby-identifier">get_result</span> <span class="ruby-keyword">or</span> <span class="ruby-keyword">break</span>
  <span class="ruby-identifier">res</span>.<span class="ruby-identifier">check</span>
  <span class="ruby-identifier">res</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># do something with the received row</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Available since PostgreSQL-9.2</p>
          
          

          
          <div class="method-source-code" id="set_single_row_mode-source">
            <pre>static VALUE
pgconn_set_single_row_mode(VALUE self)
{
        PGconn *conn = pg_get_pgconn(self);
        VALUE error;

        if( PQsetSingleRowMode(conn) == 0 )
        {
                error = rb_exc_new2(rb_ePGerror, PQerrorMessage(conn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
        }

        return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-setnonblocking" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            setnonblocking(Boolean) &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sets the nonblocking status of the connection. In the blocking state, calls
to <a href="Connection.html#method-i-send_query">send_query</a> will block
until the message is sent to the server, but will not wait for the query
results. In the nonblocking state, calls to <a
href="Connection.html#method-i-send_query">send_query</a> will return an
error if the socket is not ready for writing. Note: This function does not
affect <a href="Connection.html#method-i-exec">exec</a>, because that
function doesn&#39;t return until the server has processed the query and
returned the results. Returns <code>nil</code>.</p>
          
          

          
          <div class="method-source-code" id="setnonblocking-source">
            <pre>static VALUE
pgconn_setnonblocking(self, state)
        VALUE self, state;
{
        int arg;
        VALUE error;
        PGconn *conn = pg_get_pgconn(self);
        if(state == Qtrue)
                arg = 1;
        else if (state == Qfalse)
                arg = 0;
        else
                rb_raise(rb_eArgError, &quot;Boolean value expected&quot;);

        if(PQsetnonblocking(conn, arg) == -1) {
                error = rb_exc_new2(rb_ePGerror, PQerrorMessage(conn));
                rb_iv_set(error, &quot;@connection&quot;, self);
                rb_exc_raise(error);
        }
        return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-socket" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            socket() &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This method is deprecated. Please use the more portable method <a
href="Connection.html#method-i-socket_io">socket_io</a> .</p>

<p>Returns the socket&#39;s file descriptor for this connection.
<code>IO.for_fd()</code> can be used to build a proper IO object to the
socket. If you do so, you will likely also want to set
<code>autoclose=false</code> on it to prevent Ruby from closing the socket
to PostgreSQL if it goes out of scope. Alternatively, you can use <a
href="Connection.html#method-i-socket_io">socket_io</a>, which creates an
IO that&#39;s associated with the connection object itself, and so
won&#39;t go out of scope until the connection does.</p>

<p><strong>Note:</strong> On Windows the file descriptor is not usable, since
it can not be used to build a Ruby IO object.</p>
          
          

          
          <div class="method-source-code" id="socket-source">
            <pre>static VALUE
pgconn_socket(VALUE self)
{
        int sd;
        if( (sd = PQsocket(pg_get_pgconn(self))) &lt; 0)
                rb_raise(rb_eConnectionBad, &quot;PQsocket() can&#39;t get socket descriptor&quot;);
        return INT2NUM(sd);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-socket_io" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            socket_io() &rarr; IO
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Fetch a memorized IO object created from the Connection&#39;s underlying
socket. This object can be used for IO.select to wait for events while
running asynchronous API calls.</p>

<p>Using this instead of <a href="Connection.html#method-i-socket">socket</a>
avoids the problem of the underlying connection being closed by Ruby when
an IO created using <code>IO.for_fd(conn.socket)</code> goes out of scope.
In contrast to <a href="Connection.html#method-i-socket">socket</a>, it
also works on Windows.</p>
          
          

          
          <div class="method-source-code" id="socket_io-source">
            <pre>static VALUE
pgconn_socket_io(VALUE self)
{
        int sd;
        int ruby_sd;
        ID id_autoclose = rb_intern(&quot;autoclose=&quot;);
        t_pg_connection *this = pg_get_connection_safe( self );
        VALUE socket_io = this-&gt;socket_io;

        if ( !RTEST(socket_io) ) {
                if( (sd = PQsocket(this-&gt;pgconn)) &lt; 0)
                        rb_raise(rb_eConnectionBad, &quot;PQsocket() can&#39;t get socket descriptor&quot;);

                #ifdef _WIN32
                        ruby_sd = rb_w32_wrap_io_handle((HANDLE)(intptr_t)sd, O_RDWR|O_BINARY|O_NOINHERIT);
                #else
                        ruby_sd = sd;
                #endif

                socket_io = rb_funcall( rb_cIO, rb_intern(&quot;for_fd&quot;), 1, INT2NUM(ruby_sd) );

                /* Disable autoclose feature, when supported */
                if( rb_respond_to(socket_io, id_autoclose) ){
                        rb_funcall( socket_io, id_autoclose, 1, Qfalse );
                }

                this-&gt;socket_io = socket_io;
        }

        return socket_io;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ssl_attribute" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ssl_attribute(attribute_name) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns SSL-related information about the connection.</p>

<p>The list of available attributes varies depending on the SSL library being
used, and the type of connection. If an attribute is not available, returns
nil.</p>

<p>The following attributes are commonly available:</p>
<dl class="rdoc-list label-list"><dt><code>library</code>
<dd>
<p>Name of the SSL implementation in use. (Currently, only “OpenSSL” is
implemented)</p>
</dd><dt><code>protocol</code>
<dd>
<p>SSL/TLS version in use. Common values are “SSLv2”, “SSLv3”, “TLSv1”,
“TLSv1.1” and “TLSv1.2”, but an implementation may return other strings if
some other protocol is used.</p>
</dd><dt><code>key_bits</code>
<dd>
<p>Number of key bits used by the encryption algorithm.</p>
</dd><dt><code>cipher</code>
<dd>
<p>A short name of the ciphersuite used, e.g. “DHE-RSA-DES-CBC3-SHA”. The
names are specific to each SSL implementation.</p>
</dd><dt><code>compression</code>
<dd>
<p>If SSL compression is in use, returns the name of the compression
algorithm, or “on” if compression is used but the algorithm is not known.
If compression is not in use, returns “off”.</p>
</dd></dl>

<p>See also <a
href="Connection.html#method-i-ssl_attribute_names">ssl_attribute_names</a>
and <a
href="http://www.postgresql.org/docs/current/interactive/libpq-status.html#LIBPQ-PQSSLATTRIBUTE">www.postgresql.org/docs/current/interactive/libpq-status.html#LIBPQ-PQSSLATTRIBUTE</a></p>

<p>Available since PostgreSQL-9.5</p>
          
          

          
          <div class="method-source-code" id="ssl_attribute-source">
            <pre>static VALUE
pgconn_ssl_attribute(VALUE self, VALUE attribute_name)
{
        const char *p_attr;

        p_attr = PQsslAttribute(pg_get_pgconn(self), StringValueCStr(attribute_name));
        return p_attr ? rb_str_new_cstr(p_attr) : Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ssl_attribute_names" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ssl_attribute_names &rarr; Array&lt;String&gt;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Return an array of SSL attribute names available.</p>

<p>See also <a href="Connection.html#method-i-ssl_attribute">ssl_attribute</a></p>

<p>Available since PostgreSQL-9.5</p>
          
          

          
          <div class="method-source-code" id="ssl_attribute_names-source">
            <pre>static VALUE
pgconn_ssl_attribute_names(VALUE self)
{
        int i;
        const char * const * p_list = PQsslAttributeNames(pg_get_pgconn(self));
        VALUE ary = rb_ary_new();

        for ( i = 0; p_list[i]; i++ ) {
                rb_ary_push( ary, rb_str_new_cstr( p_list[i] ));
        }
        return ary;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ssl_attributes" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ssl_attributes &rarr; Hash&lt;String,String&gt;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns SSL-related information about the connection as key/value pairs</p>

<p>The available attributes varies depending on the SSL library being used,
and the type of connection.</p>

<p>See also <a href="Connection.html#method-i-ssl_attribute">ssl_attribute</a></p>
          
          

          
          <div class="method-source-code" id="ssl_attributes-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/pg-1.0.0-x64-mingw32/lib/pg/connection.rb, line 264</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ssl_attributes</span>
        <span class="ruby-identifier">ssl_attribute_names</span>.<span class="ruby-identifier">each</span>.<span class="ruby-identifier">with_object</span>({}) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">n</span>,<span class="ruby-identifier">h</span><span class="ruby-operator">|</span>
                <span class="ruby-identifier">h</span>[<span class="ruby-identifier">n</span>] = <span class="ruby-identifier">ssl_attribute</span>(<span class="ruby-identifier">n</span>)
        <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ssl_in_use-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ssl_in_use? &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if the connection uses SSL, <code>false</code> if
not.</p>

<p>Available since PostgreSQL-9.5</p>
          
          

          
          <div class="method-source-code" id="ssl_in_use-3F-source">
            <pre>static VALUE
pgconn_ssl_in_use(VALUE self)
{
        return PQsslInUse(pg_get_pgconn(self)) ? Qtrue : Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-status" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            status()
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns status of connection : CONNECTION_OK or CONNECTION_BAD</p>
          
          

          
          <div class="method-source-code" id="status-source">
            <pre>static VALUE
pgconn_status(VALUE self)
{
        return INT2NUM(PQstatus(pg_get_pgconn(self)));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-trace" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            trace( stream ) &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Enables tracing message passing between backend. The trace message will be
written to the stream <em>stream</em>, which must implement a method
<code>fileno</code> that returns a writable file descriptor.</p>
          
          

          
          <div class="method-source-code" id="trace-source">
            <pre>static VALUE
pgconn_trace(VALUE self, VALUE stream)
{
        VALUE fileno;
        FILE *new_fp;
        int old_fd, new_fd;
        VALUE new_file;
        t_pg_connection *this = pg_get_connection_safe( self );

        if(rb_respond_to(stream,rb_intern(&quot;fileno&quot;)) == Qfalse)
                rb_raise(rb_eArgError, &quot;stream does not respond to method: fileno&quot;);

        fileno = rb_funcall(stream, rb_intern(&quot;fileno&quot;), 0);
        if(fileno == Qnil)
                rb_raise(rb_eArgError, &quot;can&#39;t get file descriptor from stream&quot;);

        /* Duplicate the file descriptor and re-open
         * it. Then, make it into a ruby File object
         * and assign it to an instance variable.
         * This prevents a problem when the File
         * object passed to this function is closed
         * before the connection object is. */
        old_fd = NUM2INT(fileno);
        new_fd = dup(old_fd);
        new_fp = fdopen(new_fd, &quot;w&quot;);

        if(new_fp == NULL)
                rb_raise(rb_eArgError, &quot;stream is not writable&quot;);

        new_file = rb_funcall(rb_cIO, rb_intern(&quot;new&quot;), 1, INT2NUM(new_fd));
        this-&gt;trace_stream = new_file;

        PQtrace(this-&gt;pgconn, new_fp);
        return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-transaction" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            transaction { |conn| ... } &rarr; result of the block
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Executes a <code>BEGIN</code> at the start of the block, and a
<code>COMMIT</code> at the end of the block, or <code>ROLLBACK</code> if
any exception occurs.</p>
          
          

          
          <div class="method-source-code" id="transaction-source">
            <pre>static VALUE
pgconn_transaction(VALUE self)
{
        PGconn *conn = pg_get_pgconn(self);
        PGresult *result;
        VALUE rb_pgresult;
        VALUE block_result = Qnil;
        int status;

        if (rb_block_given_p()) {
                result = gvl_PQexec(conn, &quot;BEGIN&quot;);
                rb_pgresult = pg_new_result(result, self);
                pg_result_check(rb_pgresult);
                block_result = rb_protect(rb_yield, self, &amp;status);
                if(status == 0) {
                        result = gvl_PQexec(conn, &quot;COMMIT&quot;);
                        rb_pgresult = pg_new_result(result, self);
                        pg_result_check(rb_pgresult);
                }
                else {
                        /* exception occurred, ROLLBACK and re-raise */
                        result = gvl_PQexec(conn, &quot;ROLLBACK&quot;);
                        rb_pgresult = pg_new_result(result, self);
                        pg_result_check(rb_pgresult);
                        rb_jump_tag(status);
                }

        }
        else {
                /* no block supplied? */
                rb_raise(rb_eArgError, &quot;Must supply block for PG::Connection#transaction&quot;);
        }
        return block_result;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-transaction_status" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            transaction_status()
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>returns one of the following statuses:</p>

<pre>PQTRANS_IDLE    = 0 (connection idle)
PQTRANS_ACTIVE  = 1 (command in progress)
PQTRANS_INTRANS = 2 (idle, within transaction block)
PQTRANS_INERROR = 3 (idle, within failed transaction)
PQTRANS_UNKNOWN = 4 (cannot determine status)</pre>
          
          

          
          <div class="method-source-code" id="transaction_status-source">
            <pre>static VALUE
pgconn_transaction_status(VALUE self)
{
        return INT2NUM(PQtransactionStatus(pg_get_pgconn(self)));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-tty" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            tty()
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the connected pgtty. (Obsolete)</p>
          
          

          
          <div class="method-source-code" id="tty-source">
            <pre>static VALUE
pgconn_tty(VALUE self)
{
        char *tty = PQtty(pg_get_pgconn(self));
        if (!tty) return Qnil;
        return rb_tainted_str_new2(tty);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-type_map_for_queries" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            type_map_for_queries &rarr; TypeMap
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the default TypeMap that is currently set for type casts of query
bind parameters.</p>
          
          

          
          <div class="method-source-code" id="type_map_for_queries-source">
            <pre>static VALUE
pgconn_type_map_for_queries_get(VALUE self)
{
        t_pg_connection *this = pg_get_connection( self );

        return this-&gt;type_map_for_queries;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-type_map_for_queries-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            type_map_for_queries = typemap
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the default TypeMap that is used for type casts of query bind
parameters.</p>

<p><code>typemap</code> must be a kind of <a
href="TypeMap.html">PG::TypeMap</a> .</p>
          
          

          
          <div class="method-source-code" id="type_map_for_queries-3D-source">
            <pre>static VALUE
pgconn_type_map_for_queries_set(VALUE self, VALUE typemap)
{
        t_pg_connection *this = pg_get_connection( self );

        if ( !rb_obj_is_kind_of(typemap, rb_cTypeMap) ) {
                rb_raise( rb_eTypeError, &quot;wrong argument type %s (expected kind of PG::TypeMap)&quot;,
                                rb_obj_classname( typemap ) );
        }
        Check_Type(typemap, T_DATA);
        this-&gt;type_map_for_queries = typemap;

        return typemap;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-type_map_for_results" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            type_map_for_results &rarr; TypeMap
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the default TypeMap that is currently set for type casts of result
values.</p>
          
          

          
          <div class="method-source-code" id="type_map_for_results-source">
            <pre>static VALUE
pgconn_type_map_for_results_get(VALUE self)
{
        t_pg_connection *this = pg_get_connection( self );

        return this-&gt;type_map_for_results;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-type_map_for_results-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            type_map_for_results = typemap
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the default TypeMap that is used for type casts of result values.</p>

<p><code>typemap</code> must be a kind of <a
href="TypeMap.html">PG::TypeMap</a> .</p>
          
          

          
          <div class="method-source-code" id="type_map_for_results-3D-source">
            <pre>static VALUE
pgconn_type_map_for_results_set(VALUE self, VALUE typemap)
{
        t_pg_connection *this = pg_get_connection( self );

        if ( !rb_obj_is_kind_of(typemap, rb_cTypeMap) ) {
                rb_raise( rb_eTypeError, &quot;wrong argument type %s (expected kind of PG::TypeMap)&quot;,
                                rb_obj_classname( typemap ) );
        }
        Check_Type(typemap, T_DATA);
        this-&gt;type_map_for_results = typemap;

        return typemap;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-unescape_bytea" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            PG::Connection.unescape_bytea( string )
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts an escaped string representation of binary data into binary data —
the reverse of <a
href="Connection.html#method-i-escape_bytea">escape_bytea</a>. This is
needed when retrieving <code>bytea</code> data in text format, but not when
retrieving it in binary format.</p>
          
          

          
          <div class="method-source-code" id="unescape_bytea-source">
            <pre>static VALUE
pgconn_s_unescape_bytea(VALUE self, VALUE str)
{
        unsigned char *from, *to;
        size_t to_len;
        VALUE ret;

        UNUSED( self );

        Check_Type(str, T_STRING);
        from = (unsigned char*)StringValueCStr(str);

        to = PQunescapeBytea(from, &amp;to_len);

        ret = rb_str_new((char*)to, to_len);
        OBJ_INFECT(ret, str);
        PQfreemem(to);
        return ret;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-untrace" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            untrace() &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Disables the message tracing.</p>
          
          

          
          <div class="method-source-code" id="untrace-source">
            <pre>static VALUE
pgconn_untrace(VALUE self)
{
        t_pg_connection *this = pg_get_connection_safe( self );

        PQuntrace(this-&gt;pgconn);
        rb_funcall(this-&gt;trace_stream, rb_intern(&quot;close&quot;), 0);
        this-&gt;trace_stream = Qnil;
        return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-user" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            user()
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the authenticated user name.</p>
          
          

          
          <div class="method-source-code" id="user-source">
            <pre>static VALUE
pgconn_user(VALUE self)
{
        char *user = PQuser(pg_get_pgconn(self));
        if (!user) return Qnil;
        return rb_tainted_str_new2(user);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-wait_for_notify" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            wait_for_notify( [ timeout ] ) &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            wait_for_notify( [ timeout ] ) { |event, pid| block }
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            wait_for_notify( [ timeout ] ) { |event, pid, payload| block } # PostgreSQL 9.0
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Blocks while waiting for notification(s), or until the optional
<em>timeout</em> is reached, whichever comes first.  <em>timeout</em> is
measured in seconds and can be fractional.</p>

<p>Returns <code>nil</code> if <em>timeout</em> is reached, the name of the
NOTIFY event otherwise.  If used in block form, passes the name of the
NOTIFY <code>event</code> and the generating <code>pid</code> into the
block.</p>

<p>Under PostgreSQL 9.0 and later, if the notification is sent with the
optional <code>payload</code> string, it will be given to the block as the
third argument.</p>
          
          

          
          <div class="method-source-code" id="wait_for_notify-source">
            <pre>static VALUE
pgconn_wait_for_notify(int argc, VALUE *argv, VALUE self)
{
        PGconn *conn = pg_get_pgconn( self );
        PGnotify *pnotification;
        struct timeval timeout;
        struct timeval *ptimeout = NULL;
        VALUE timeout_in = Qnil, relname = Qnil, be_pid = Qnil, extra = Qnil;
        double timeout_sec;

        rb_scan_args( argc, argv, &quot;01&quot;, &amp;timeout_in );

        if ( RTEST(timeout_in) ) {
                timeout_sec = NUM2DBL( timeout_in );
                timeout.tv_sec = (time_t)timeout_sec;
                timeout.tv_usec = (suseconds_t)( (timeout_sec - (long)timeout_sec) * 1e6 );
                ptimeout = &amp;timeout;
        }

        pnotification = (PGnotify*) wait_socket_readable( conn, ptimeout, notify_readable);

        /* Return nil if the select timed out */
        if ( !pnotification ) return Qnil;

        relname = rb_tainted_str_new2( pnotification-&gt;relname );
        PG_ENCODING_SET_NOCHECK( relname, ENCODING_GET(self) );
        be_pid = INT2NUM( pnotification-&gt;be_pid );
        if ( *pnotification-&gt;extra ) {
                extra = rb_tainted_str_new2( pnotification-&gt;extra );
                PG_ENCODING_SET_NOCHECK( extra, ENCODING_GET(self) );
        }
        PQfreemem( pnotification );

        if ( rb_block_given_p() )
                rb_yield_values( 3, relname, be_pid, extra );

        return relname;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Connection.html#method-i-notifies_wait">notifies_wait</a>
        </div>
        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://rdoc.github.io/rdoc">RDoc</a> 5.0.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

