<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class CodeRay::Scanners::Lua - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/jquery.js"></script>
<script src="../../js/darkfish.js"></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">Scanner
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-i-scan_tokens">#scan_tokens</a>
    
    <li ><a href="#method-i-setup">#setup</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-CodeRay::Scanners::Lua">
  <h1 id="class-CodeRay::Scanners::Lua" class="class">
    class CodeRay::Scanners::Lua
  </h1>

  <section class="description">
    
<p><a href="Scanner.html">Scanner</a> for the <a href="http://lua.org">Lua</a>
programming lanuage.</p>

<p>The language’s complete syntax is defined in <a
href="http://www.lua.org/manual/5.2/manual.html">the Lua manual</a>, which
is what this scanner tries to conform to.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="IDENT_KIND">IDENT_KIND
        
        <dd><p>Automatic token kind selection for normal words.</p>
        
      
        <dt id="KEYWORDS">KEYWORDS
        
        <dd><p>Keywords used in <a href="Lua.html">Lua</a>.</p>
        
      
        <dt id="PREDEFINED_CONSTANTS">PREDEFINED_CONSTANTS
        
        <dd><p>Constants set by the <a href="Lua.html">Lua</a> core.</p>
        
      
        <dt id="PREDEFINED_EXPRESSIONS">PREDEFINED_EXPRESSIONS
        
        <dd><p>The expressions contained in this array are parts of Lua’s `basic&#39;
library. Although it’s not entirely necessary to load that library, it is
highly recommended and one would have to provide own implementations of
some of these expressions if one does not do so. They however aren’t
keywords, neither are they constants, but nearly predefined, so they get
tagged as `predefined&#39; rather than anything else.</p>

<p>This list excludes values of form `_UPPERCASE&#39; because the <a
href="Lua.html">Lua</a> manual requires such identifiers to be reserved by
<a href="Lua.html">Lua</a> anyway and they are highlighted directly
accordingly, without the need for specific identifiers to be listed here.</p>
        
      
      </dl>
    </section>
    

    

    
     <section id="protected-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Protected Instance Methods</h3>
       </header>

    
      <div id="method-i-scan_tokens" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">scan_tokens</span><span
            class="method-args">(encoder, options)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p><a href="../../CodeRay.html">CodeRay</a> entry hook. Starts parsing.</p>
          
          

          
          <div class="method-source-code" id="scan_tokens-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/coderay-1.1.2/lib/coderay/scanners/lua.rb, line 59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">scan_tokens</span>(<span class="ruby-identifier">encoder</span>, <span class="ruby-identifier">options</span>)
  <span class="ruby-identifier">state</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:state</span>] <span class="ruby-operator">||</span> <span class="ruby-ivar">@state</span>
  <span class="ruby-identifier">brace_depth</span> = <span class="ruby-ivar">@brace_depth</span>
  <span class="ruby-identifier">num_equals</span> = <span class="ruby-keyword">nil</span>
  
  <span class="ruby-keyword">until</span> <span class="ruby-identifier">eos?</span>
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">state</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\-\-\[\=*\[/</span>)   <span class="ruby-comment">#--[[ long (possibly multiline) comment ]]</span>
        <span class="ruby-identifier">num_equals</span> = <span class="ruby-identifier">match</span>.<span class="ruby-identifier">count</span>(<span class="ruby-string">&quot;=&quot;</span>) <span class="ruby-comment"># Number must match for comment end</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">begin_group</span>(<span class="ruby-value">:comment</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:delimiter</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:long_comment</span>
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/--.*$/</span>) <span class="ruby-comment"># --Lua comment</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:comment</span>)
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\[=*\[/</span>)     <span class="ruby-comment"># [[ long (possibly multiline) string ]]</span>
        <span class="ruby-identifier">num_equals</span> = <span class="ruby-identifier">match</span>.<span class="ruby-identifier">count</span>(<span class="ruby-string">&quot;=&quot;</span>) <span class="ruby-comment"># Number must match for comment end</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">begin_group</span>(<span class="ruby-value">:string</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:delimiter</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:long_string</span>
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/::\s*[a-zA-Z_][a-zA-Z0-9_]+\s*::/</span>) <span class="ruby-comment"># ::goto_label::</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:label</span>)
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/_[A-Z]+/</span>) <span class="ruby-comment"># _UPPERCASE are names reserved for Lua</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:predefined</span>)
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[a-zA-Z_][a-zA-Z0-9_]*/</span>) <span class="ruby-comment"># Normal letters (or letters followed by digits)</span>
        <span class="ruby-identifier">kind</span> = <span class="ruby-constant">IDENT_KIND</span>[<span class="ruby-identifier">match</span>]
        
        <span class="ruby-comment"># Extra highlighting for entities following certain keywords</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">kind</span> <span class="ruby-operator">==</span> <span class="ruby-value">:keyword</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">match</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;function&quot;</span>
          <span class="ruby-identifier">state</span> = <span class="ruby-value">:function_expected</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">kind</span> <span class="ruby-operator">==</span> <span class="ruby-value">:keyword</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">match</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;goto&quot;</span>
          <span class="ruby-identifier">state</span> = <span class="ruby-value">:goto_label_expected</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">kind</span> <span class="ruby-operator">==</span> <span class="ruby-value">:keyword</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">match</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;local&quot;</span>
          <span class="ruby-identifier">state</span> = <span class="ruby-value">:local_var_expected</span>
        <span class="ruby-keyword">end</span>
        
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-identifier">kind</span>)
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\{/</span>) <span class="ruby-comment"># Opening table brace {</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">begin_group</span>(<span class="ruby-value">:map</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-identifier">brace_depth</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">1</span> <span class="ruby-operator">?</span> <span class="ruby-value">:inline_delimiter</span> <span class="ruby-operator">:</span> <span class="ruby-value">:delimiter</span>)
        <span class="ruby-identifier">brace_depth</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">state</span>        = <span class="ruby-value">:map</span>
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\}/</span>) <span class="ruby-comment"># Closing table brace }</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">brace_depth</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
          <span class="ruby-identifier">brace_depth</span> = <span class="ruby-value">0</span>
          <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:delimiter</span>)
          <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span>(<span class="ruby-value">:map</span>)
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">brace_depth</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-comment"># Mismatched brace</span>
          <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:error</span>)
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">brace_depth</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>
          <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:inline_delimiter</span>)
          <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span>(<span class="ruby-value">:map</span>)
          <span class="ruby-identifier">state</span> = <span class="ruby-value">:map</span>
        <span class="ruby-keyword">end</span>
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[&quot;&#39;]/</span>) <span class="ruby-comment"># String delimiters &quot; and &#39;</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">begin_group</span>(<span class="ruby-value">:string</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:delimiter</span>)
        <span class="ruby-identifier">start_delim</span> = <span class="ruby-identifier">match</span>
        <span class="ruby-identifier">state</span>       = <span class="ruby-value">:string</span>
      
                        <span class="ruby-comment"># ↓Prefix                hex number ←|→ decimal number</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/-? (?:0x\h* \. \h+ (?:p[+\-]?\d+)? | \d*\.\d+ (?:e[+\-]?\d+)?)/ix</span>) <span class="ruby-comment"># hexadecimal constants have no E power, decimal ones no P power</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:float</span>)
      
                        <span class="ruby-comment"># ↓Prefix         hex number ←|→ decimal number</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/-? (?:0x\h+ (?:p[+\-]?\d+)? | \d+ (?:e[+\-]?\d+)?)/ix</span>) <span class="ruby-comment"># hexadecimal constants have no E power, decimal ones no P power</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:integer</span>)
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-node">/[\+\-\*\/%^\#=~&lt;&gt;\(\)\[\]:;,] | \.(?!\d)/x</span>) <span class="ruby-comment"># Operators</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:operator</span>)
      
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\s+/</span>) <span class="ruby-comment"># Space</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:space</span>)
      
      <span class="ruby-keyword">else</span> <span class="ruby-comment"># Invalid stuff. Note that Lua doesn’t accept multibyte chars outside of strings, hence these are also errors.</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">getch</span>, <span class="ruby-value">:error</span>)
      <span class="ruby-keyword">end</span>
      
      <span class="ruby-comment"># It may be that we’re scanning a full-blown subexpression of a table</span>
      <span class="ruby-comment"># (tables can contain full expressions in parts).</span>
      <span class="ruby-comment"># If this is the case, return to :map scanning state.</span>
      <span class="ruby-identifier">state</span> = <span class="ruby-value">:map</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">state</span> <span class="ruby-operator">==</span> <span class="ruby-value">:initial</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">brace_depth</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">1</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:function_expected</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\(.*?\)/m</span>) <span class="ruby-comment"># x = function() # &quot;Anonymous&quot; function without explicit name</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:operator</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[a-zA-Z_] (?:[a-zA-Z0-9_\.] (?!\.\d))* [\.\:]/x</span>) <span class="ruby-comment"># function tbl.subtbl.foo() | function tbl:foo() # Colon only allowed as last separator</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:ident</span>)
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[a-zA-Z_][a-zA-Z0-9_]*/</span>) <span class="ruby-comment"># function foo()</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:function</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\s+/</span>) <span class="ruby-comment"># Between the `function&#39; keyword and the ident may be any amount of whitespace</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:space</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">getch</span>, <span class="ruby-value">:error</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">end</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:goto_label_expected</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[a-zA-Z_][a-zA-Z0-9_]*/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:label</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\s+/</span>) <span class="ruby-comment"># Between the `goto&#39; keyword and the label may be any amount of whitespace</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:space</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">getch</span>, <span class="ruby-value">:error</span>)
      <span class="ruby-keyword">end</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:local_var_expected</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/function/</span>) <span class="ruby-comment"># local function ...</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:keyword</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:function_expected</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[a-zA-Z_][a-zA-Z0-9_]*/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:local_variable</span>)
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/,/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:operator</span>)
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\=/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:operator</span>)
        <span class="ruby-comment"># After encountering the equal sign, arbitrary expressions are</span>
        <span class="ruby-comment"># allowed again, so just return to the main state for further</span>
        <span class="ruby-comment"># parsing.</span>
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\n/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:space</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\s+/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:space</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">getch</span>, <span class="ruby-value">:error</span>)
      <span class="ruby-keyword">end</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:long_comment</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-node">/.*?(?=\]={#{num_equals}}\])/m</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:content</span>)
        
        <span class="ruby-identifier">delim</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-node">/\]={#{num_equals}}\]/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">delim</span>, <span class="ruby-value">:delimiter</span>)
      <span class="ruby-keyword">else</span> <span class="ruby-comment"># No terminator found till EOF</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">rest</span>, <span class="ruby-value">:error</span>)
        <span class="ruby-identifier">terminate</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span>(<span class="ruby-value">:comment</span>)
      <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:long_string</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-node">/.*?(?=\]={#{num_equals}}\])/m</span>) <span class="ruby-comment"># Long strings do not interpret any escape sequences</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:content</span>)
        
        <span class="ruby-identifier">delim</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-node">/\]={#{num_equals}}\]/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">delim</span>, <span class="ruby-value">:delimiter</span>)
      <span class="ruby-keyword">else</span> <span class="ruby-comment"># No terminator found till EOF</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">rest</span>, <span class="ruby-value">:error</span>)
        <span class="ruby-identifier">terminate</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span>(<span class="ruby-value">:string</span>)
      <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:string</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-node">/[^\#{start_delim}\n]+/</span>) <span class="ruby-comment"># Everything except \ and the start delimiter character is string content (newlines are only allowed if preceeded by \ or \z)</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:content</span>)
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\(?:[&#39;&quot;abfnrtv\]|z\s*|x\h\h|\d{1,3}|\n)/m</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:char</span>)
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">start_delim</span>))
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:delimiter</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span>(<span class="ruby-value">:string</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\n/</span>) <span class="ruby-comment"># Lua forbids unescaped newlines in normal non-long strings</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-string">&quot;\\n\n&quot;</span>, <span class="ruby-value">:error</span>) <span class="ruby-comment"># Visually appealing error indicator--otherwise users may wonder whether the highlighter cannot highlight multine strings</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span>(<span class="ruby-value">:string</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">getch</span>, <span class="ruby-value">:error</span>)
      <span class="ruby-keyword">end</span>
    
    <span class="ruby-keyword">when</span> <span class="ruby-value">:map</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[,;]/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:operator</span>)
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/[a-zA-Z_][a-zA-Z0-9_]* (?=\s*=)/x</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:key</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\s+/</span>), <span class="ruby-value">:space</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">check</span>(<span class="ruby-regexp">/\s+/</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\=/</span>), <span class="ruby-value">:operator</span>)
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\s+/m</span>)
        <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">text_token</span>(<span class="ruby-identifier">match</span>, <span class="ruby-value">:space</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># Note this clause doesn’t advance the scan pointer, it’s a kind of</span>
        <span class="ruby-comment"># &quot;retry with other options&quot; (the :initial state then of course</span>
        <span class="ruby-comment"># advances the pointer).</span>
        <span class="ruby-identifier">state</span> = <span class="ruby-value">:initial</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">raise</span>
    <span class="ruby-keyword">end</span>
    
  <span class="ruby-keyword">end</span>
  
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:keep_state</span>]
    <span class="ruby-ivar">@state</span> = <span class="ruby-identifier">state</span>
  <span class="ruby-keyword">end</span>
  
  <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span> <span class="ruby-value">:string</span> <span class="ruby-keyword">if</span> [<span class="ruby-value">:string</span>].<span class="ruby-identifier">include?</span> <span class="ruby-identifier">state</span>
  <span class="ruby-identifier">brace_depth</span>.<span class="ruby-identifier">times</span> { <span class="ruby-identifier">encoder</span>.<span class="ruby-identifier">end_group</span> <span class="ruby-value">:map</span> }
  
  <span class="ruby-identifier">encoder</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-setup" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">setup</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p><a href="Scanner.html">Scanner</a> initialization.</p>
          
          

          
          <div class="method-source-code" id="setup-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/coderay-1.1.2/lib/coderay/scanners/lua.rb, line 53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">setup</span>
  <span class="ruby-ivar">@state</span> = <span class="ruby-value">:initial</span>
  <span class="ruby-ivar">@brace_depth</span> = <span class="ruby-value">0</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://rdoc.github.io/rdoc">RDoc</a> 5.0.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

