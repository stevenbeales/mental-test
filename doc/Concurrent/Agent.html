<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Concurrent::Agent - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
  var index_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/darkfish.js"></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">Synchronization::LockableObject
  
</div>

    <div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
  
  
    <li><a class="include" href="Concern/Observable.html">Concurrent::Concern::Observable</a>
  
  
  </ul>
</div>

    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-await">::await</a>
    
    <li ><a href="#method-c-await_for">::await_for</a>
    
    <li ><a href="#method-c-await_for-21">::await_for!</a>
    
    <li class="calls-super" ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-i-3C-3C">#&lt;&lt;</a>
    
    <li ><a href="#method-i-await">#await</a>
    
    <li ><a href="#method-i-await_for">#await_for</a>
    
    <li ><a href="#method-i-await_for-21">#await_for!</a>
    
    <li ><a href="#method-i-deref">#deref</a>
    
    <li ><a href="#method-i-error">#error</a>
    
    <li ><a href="#method-i-failed-3F">#failed?</a>
    
    <li ><a href="#method-i-post">#post</a>
    
    <li ><a href="#method-i-reason">#reason</a>
    
    <li ><a href="#method-i-restart">#restart</a>
    
    <li ><a href="#method-i-send">#send</a>
    
    <li ><a href="#method-i-send-21">#send!</a>
    
    <li ><a href="#method-i-send_off">#send_off</a>
    
    <li ><a href="#method-i-send_off-21">#send_off!</a>
    
    <li ><a href="#method-i-send_via">#send_via</a>
    
    <li ><a href="#method-i-send_via-21">#send_via!</a>
    
    <li ><a href="#method-i-stopped-3F">#stopped?</a>
    
    <li ><a href="#method-i-value">#value</a>
    
    <li ><a href="#method-i-wait">#wait</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Concurrent::Agent">
  <h1 id="class-Concurrent::Agent" class="class">
    class Concurrent::Agent
  </h1>

  <section class="description">
    
<p>`Agent` is inspired by Clojure&#39;s [agent](<a
href="http://clojure.org/agents">clojure.org/agents</a>) function. An agent
is a shared, mutable variable providing independent, uncoordinated,
<strong>asynchronous</strong> change of individual values. Best used when
the value will undergo frequent, complex updates. Suitable when the result
of an update does not need to be known immediately. `Agent` is (mostly)
functionally equivalent to Clojure&#39;s agent, except where the runtime
prevents parity.</p>

<p>Agents are reactive, not autonomous - there is no imperative message loop
and no blocking receive. The state of an <a href="Agent.html">Agent</a>
should be itself immutable and the `#value` of an <a
href="Agent.html">Agent</a> is always immediately available for reading by
any thread without any messages, i.e. observation does not require
cooperation or coordination.</p>

<p><a href="Agent.html">Agent</a> action dispatches are made using the various
`#send` methods. These methods always return immediately. At some point
later, in another thread, the following will happen:</p>
<ol><li>
<p>The given `action` will be applied to the state of the <a
href="Agent.html">Agent</a> and the `args`, if any were supplied.</p>
</li><li>
<p>The return value of `action` will be passed to the validator lambda, if one
has been set on the <a href="Agent.html">Agent</a>.</p>
</li><li>
<p>If the validator succeeds or if no validator was given, the return value of
the given `action` will become the new `#value` of the <a
href="Agent.html">Agent</a>. See `#initialize` for details.</p>
</li><li>
<p>If any observers were added to the <a href="Agent.html">Agent</a>, they
will be notified. See `#add_observer` for details.</p>
</li><li>
<p>If during the `action` execution any other dispatches are made (directly or
indirectly), they will be held until after the `#value` of the <a
href="Agent.html">Agent</a> has been changed.</p>
</li></ol>

<p>If any exceptions are thrown by an action function, no nested dispatches
will occur, and the exception will be cached in the <a
href="Agent.html">Agent</a> itself. When an <a href="Agent.html">Agent</a>
has errors cached, any subsequent interactions will immediately throw an
exception, until the agent&#39;s errors are cleared. <a
href="Agent.html">Agent</a> errors can be examined with `#error` and the
agent restarted with `#restart`.</p>

<p>The actions of all Agents get interleaved amongst threads in a thread pool.
At any point in time, at most one action for each <a
href="Agent.html">Agent</a> is being executed. Actions dispatched to an
agent from another single agent or thread will occur in the order they were
sent, potentially interleaved with actions dispatched to the same agent
from other sources. The `#send` method should be used for actions that are
CPU limited, while the `#send_off` method is appropriate for actions that
may block on IO.</p>

<p>Unlike in Clojure, `Agent` cannot participate in `Concurrent::TVar`
transactions.</p>

<p>## Example</p>

<p>“` def next_fibonacci(set = nil)</p>

<pre class="ruby"><span class="ruby-keyword">return</span> [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">set</span>.<span class="ruby-identifier">nil?</span>
<span class="ruby-identifier">set</span> <span class="ruby-operator">+</span> [<span class="ruby-identifier">set</span>[<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">reduce</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">sum</span>,<span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">x</span> }]
</pre>

<p>end</p>

<p># create an agent with an initial value agent = <a
href="Agent.html#method-c-new">::new</a></p>

<p># send a few update requests 5.times do</p>

<pre class="ruby"><span class="ruby-identifier">agent</span>.<span class="ruby-identifier">send</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">set</span><span class="ruby-operator">|</span> <span class="ruby-identifier">next_fibonacci</span>(<span class="ruby-identifier">set</span>) }
</pre>

<p>end</p>

<p># wait for them to complete agent.await</p>

<p># get the current value agent.value #=&gt; [0, 1, 1, 2, 3, 5, 8] “`</p>

<p>## Observation</p>

<p>Agents support observers through the {Concurrent::Observable} mixin module.
Notification of observers occurs every time an action dispatch returns and
the new value is successfully validated. Observation will
<strong>not</strong> occur if the action raises an exception, if validation
fails, or when a {#restart} occurs.</p>

<p>When notified the observer will receive three arguments: `time`,
`old_value`, and `new_value`. The `time` argument is the time at which the
value change occurred. The `old_value` is the value of the <a
href="Agent.html">Agent</a> when the action began processing. The
`new_value` is the value to which the <a href="Agent.html">Agent</a> was
set when the action completed. Note that `old_value` and `new_value` may be
the same. This is not an error. It simply means that the action returned
the same value.</p>

<p>## Nested Actions</p>

<p>It is possible for an <a href="Agent.html">Agent</a> action to post further
actions back to itself. The nested actions will be enqueued normally then
processed <strong>after</strong> the outer action completes, in the order
they were sent, possibly interleaved with action dispatches from other
threads. Nested actions never deadlock with one another and a failure in a
nested action will never affect the outer action.</p>

<p>Nested actions can be called using the <a href="Agent.html">Agent</a>
reference from the enclosing scope or by passing the reference in as a
“send” argument. Nested actions cannot be post using `self` from within the
action block/proc/lambda; `self` in this context will not reference the <a
href="Agent.html">Agent</a>. The preferred method for dispatching nested
actions is to pass the <a href="Agent.html">Agent</a> as an argument. This
allows Ruby to more effectively manage the closing scope.</p>

<p>Prefer this:</p>

<p>“` agent = <a href="Agent.html#method-c-new">::new</a> agent.send(agent) do
|value, this|</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">send</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span> <span class="ruby-operator">+</span> <span class="ruby-value">42</span> }
<span class="ruby-value">3.14</span>
</pre>

<p>end agent.value #=&gt; 45.14 “`</p>

<p>Over this:</p>

<p>“` agent = <a href="Agent.html#method-c-new">::new</a> agent.send do
|value|</p>

<pre class="ruby"><span class="ruby-identifier">agent</span>.<span class="ruby-identifier">send</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span> <span class="ruby-operator">+</span> <span class="ruby-value">42</span> }
<span class="ruby-value">3.14</span>
</pre>

<p>end “`</p>

<p>@!macro [new] agent_await_warning</p>

<pre>**NOTE** Never, *under any circumstances*, call any of the &quot;await&quot; methods
({#await}, {#await_for}, {#await_for!}, and {#wait}) from within an action
block/proc/lambda. The call will block the Agent and will always fail.
Calling either {#await} or {#wait} (with a timeout of `nil`) will
hopelessly deadlock the Agent with no possibility of recovery.</pre>

<p>@!macro thread_safe_variable_comparison</p>

<p>@see <a href="http://clojure.org/Agents">clojure.org/Agents</a> Clojure
Agents @see <a href="http://clojure.org/state">clojure.org/state</a> Values
and Change - Clojure&#39;s approach to Identity and State</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="AWAIT_ACTION">AWAIT_ACTION
        
        <dd>
        
      
        <dt id="AWAIT_FLAG">AWAIT_FLAG
        
        <dd>
        
      
        <dt id="DEFAULT_ERROR_HANDLER">DEFAULT_ERROR_HANDLER
        
        <dd>
        
      
        <dt id="DEFAULT_VALIDATOR">DEFAULT_VALIDATOR
        
        <dd>
        
      
        <dt id="ERROR_MODES">ERROR_MODES
        
        <dd>
        
      
        <dt id="Job">Job
        
        <dd>
        
      
      </dl>
    </section>
    

    
    <section class="attribute-method-details" class="method-section">
      <header>
        <h3>Attributes</h3>
      </header>

      
      <div id="attribute-i-error_mode" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">error_mode</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        <p>The error mode this <a href="Agent.html">Agent</a> is operating in. See
{#initialize} for details.</p>
        
        </div>
      </div>
      
    </section>
    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-await" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">await</span><span
            class="method-args">(*agents)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Blocks the current thread (indefinitely!) until all actions dispatched thus
far to all the given Agents, from this thread or nested by the given
Agents, have occurred. Will block when any of the agents are failed. Will
never return if a failed <a href="Agent.html">Agent</a> is restart with
`:clear_actions` true.</p>

<p>@param [Array&lt;Concurrent::Agent&gt;] agents the Agents on which to wait
@return [Boolean] true</p>

<p>@!macro agent_await_warning</p>
          
          

          
          <div class="method-source-code" id="await-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 448</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">await</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">agents</span>)
  <span class="ruby-identifier">agents</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">agent</span><span class="ruby-operator">|</span> <span class="ruby-identifier">agent</span>.<span class="ruby-identifier">await</span> }
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-await_for" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">await_for</span><span
            class="method-args">(timeout, *agents)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Blocks the current thread until all actions dispatched thus far to all the
given Agents, from this thread or nested by the given Agents, have
occurred, or the timeout (in seconds) has elapsed.</p>

<p>@param [Float] timeout the maximum number of seconds to wait @param
[Array&lt;Concurrent::Agent&gt;] agents the Agents on which to wait @return
[Boolean] true if all actions complete before timeout else false</p>

<p>@!macro agent_await_warning</p>
          
          

          
          <div class="method-source-code" id="await_for-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 462</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">await_for</span>(<span class="ruby-identifier">timeout</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">agents</span>)
  <span class="ruby-identifier">end_at</span> = <span class="ruby-constant">Concurrent</span>.<span class="ruby-identifier">monotonic_time</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">timeout</span>.<span class="ruby-identifier">to_f</span>
  <span class="ruby-identifier">ok</span>     = <span class="ruby-identifier">agents</span>.<span class="ruby-identifier">length</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">break</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">delay</span> = <span class="ruby-identifier">end_at</span> <span class="ruby-operator">-</span> <span class="ruby-constant">Concurrent</span>.<span class="ruby-identifier">monotonic_time</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>
    <span class="ruby-keyword">break</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">agents</span>[<span class="ruby-identifier">i</span>].<span class="ruby-identifier">await_for</span>(<span class="ruby-identifier">delay</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-operator">!</span><span class="ruby-operator">!</span><span class="ruby-identifier">ok</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-await_for-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">await_for!</span><span
            class="method-args">(timeout, *agents)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Blocks the current thread until all actions dispatched thus far to all the
given Agents, from this thread or nested by the given Agents, have
occurred, or the timeout (in seconds) has elapsed.</p>

<p>@param [Float] timeout the maximum number of seconds to wait @param
[Array&lt;Concurrent::Agent&gt;] agents the Agents on which to wait @return
[Boolean] true if all actions complete before timeout</p>

<p>@raise [Concurrent::TimeoutError] when timout is reached @!macro
agent_await_warning</p>
          
          

          
          <div class="method-source-code" id="await_for-21-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 481</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">await_for!</span>(<span class="ruby-identifier">timeout</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">agents</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">TimeoutError</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">await_for</span>(<span class="ruby-identifier">timeout</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">agents</span>)
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">(initial, opts = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Create a new `Agent` with the given initial value and options.</p>

<p>The `:validator` option must be `nil` or a side-effect free proc/lambda
which takes one argument. On any intended value change the validator, if
provided, will be called. If the new value is invalid the validator should
return `false` or raise an error.</p>

<p>The `:error_handler` option must be `nil` or a proc/lambda which takes two
arguments. When an action raises an error or validation fails, either by
returning false or raising an error, the error handler will be called. The
arguments to the error handler will be a reference to the agent itself and
the error object which was raised.</p>

<p>The `:error_mode` may be either `:continue` (the default if an error
handler is given) or `:fail` (the default if error handler nil or not
given).</p>

<p>If an action being run by the agent throws an error or doesn&#39;t pass
validation the error handler, if present, will be called. After the handler
executes if the error mode is `:continue` the <a
href="Agent.html">Agent</a> will continue as if neither the action that
caused the error nor the error itself ever happened.</p>

<p>If the mode is `:fail` the <a href="Agent.html">Agent</a> will become
{#failed?} and will stop accepting new action dispatches. Any previously
queued actions will be held until {#restart} is called. The {#value} method
will still work, returning the value of the <a href="Agent.html">Agent</a>
before the error.</p>

<p>@param [Object] initial the initial value @param [Hash] opts the
configuration options</p>

<p>@option opts [Symbol] :error_mode either `:continue` or `:fail` @option
opts [nil, Proc] :error_handler the (optional) error handler @option opts
[nil, Proc] :validator the (optional) validation procedure</p>
          
          
            <div class="method-calls-super">
              Calls superclass method
              
            </div>
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">initial</span>, <span class="ruby-identifier">opts</span> = {})
  <span class="ruby-keyword">super</span>()
  <span class="ruby-identifier">synchronize</span> { <span class="ruby-identifier">ns_initialize</span>(<span class="ruby-identifier">initial</span>, <span class="ruby-identifier">opts</span>) }
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-3C-3C" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">&lt;&lt;</span><span
            class="method-args">(action)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Dispatches an action to the <a href="Agent.html">Agent</a> and returns
immediately. Subsequently, in a thread from a thread pool, the {#value}
will be set to the return value of the action. Appropriate for actions that
may block on IO.</p>

<p>@param [Proc] action the action dispatch to be enqueued @return
[Concurrent::Agent] self @see {#send_off}</p>
          
          

          
          <div class="method-source-code" id="3C-3C-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 330</span>
<span class="ruby-keyword">def</span> <span class="ruby-operator">&lt;&lt;</span>(<span class="ruby-identifier">action</span>)
  <span class="ruby-identifier">send_off</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-await" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">await</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Blocks the current thread (indefinitely!) until all actions dispatched thus
far, from this thread or nested by the <a href="Agent.html">Agent</a>, have
occurred. Will block when {#failed?}. Will never return if a failed <a
href="Agent.html">Agent</a> is {#restart} with `:clear_actions` true.</p>

<p>Returns a reference to `self` to support method chaining:</p>

<p>“` current_value = agent.await.value “`</p>

<p>@return [Boolean] self</p>

<p>@!macro agent_await_warning</p>
          
          

          
          <div class="method-source-code" id="await-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 349</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">await</span>
  <span class="ruby-identifier">wait</span>(<span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-await_for" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">await_for</span><span
            class="method-args">(timeout)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Blocks the current thread until all actions dispatched thus far, from this
thread or nested by the <a href="Agent.html">Agent</a>, have occurred, or
the timeout (in seconds) has elapsed.</p>

<p>@param [Float] timeout the maximum number of seconds to wait @return
[Boolean] true if all actions complete before timeout else false</p>

<p>@!macro agent_await_warning</p>
          
          

          
          <div class="method-source-code" id="await_for-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 362</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">await_for</span>(<span class="ruby-identifier">timeout</span>)
  <span class="ruby-identifier">wait</span>(<span class="ruby-identifier">timeout</span>.<span class="ruby-identifier">to_f</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-await_for-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">await_for!</span><span
            class="method-args">(timeout)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Blocks the current thread until all actions dispatched thus far, from this
thread or nested by the <a href="Agent.html">Agent</a>, have occurred, or
the timeout (in seconds) has elapsed.</p>

<p>@param [Float] timeout the maximum number of seconds to wait @return
[Boolean] true if all actions complete before timeout</p>

<p>@raise [Concurrent::TimeoutError] when timout is reached</p>

<p>@!macro agent_await_warning</p>
          
          

          
          <div class="method-source-code" id="await_for-21-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 376</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">await_for!</span>(<span class="ruby-identifier">timeout</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">TimeoutError</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">wait</span>(<span class="ruby-identifier">timeout</span>.<span class="ruby-identifier">to_f</span>)
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-deref" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">deref</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Agent.html#method-i-value">value</a>
        </div>
        
      </div>

    
      <div id="method-i-error" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">error</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>When {#failed?} and {#error_mode} is `:fail`, returns the error object
which caused the failure, else `nil`. When {#error_mode} is `:continue`
will <strong>always</strong> return `nil`.</p>

<p>@return [nil, Error] the error which caused the failure when {#failed?}</p>
          
          

          
          <div class="method-source-code" id="error-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 239</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">error</span>
  <span class="ruby-ivar">@error</span>.<span class="ruby-identifier">value</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Agent.html#method-i-reason">reason</a>
        </div>
        

        
      </div>

    
      <div id="method-i-failed-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">failed?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Is the <a href="Agent.html">Agent</a> in a failed state?</p>

<p>@see {#restart}</p>
          
          

          
          <div class="method-source-code" id="failed-3F-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 401</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">failed?</span>
  <span class="ruby-operator">!</span><span class="ruby-ivar">@error</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">nil?</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Agent.html#method-i-stopped-3F">stopped?</a>
        </div>
        

        
      </div>

    
      <div id="method-i-post" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">post</span><span
            class="method-args">(*args, &action)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Agent.html#method-i-send_off">send_off</a>
        </div>
        
      </div>

    
      <div id="method-i-reason" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">reason</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Agent.html#method-i-error">error</a>
        </div>
        
      </div>

    
      <div id="method-i-restart" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">restart</span><span
            class="method-args">(new_value, opts = {})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>When an <a href="Agent.html">Agent</a> is {#failed?}, changes the <a
href="Agent.html">Agent</a> {#value} to `new_value` then un-fails the <a
href="Agent.html">Agent</a> so that action dispatches are allowed again. If
the `:clear_actions` option is give and true, any actions queued on the <a
href="Agent.html">Agent</a> that were being held while it was failed will
be discarded, otherwise those held actions will proceed. The `new_value`
must pass the validator if any, or `restart` will raise an exception and
the <a href="Agent.html">Agent</a> will remain failed with its old {#value}
and {#error}. Observers, if any, will not be notified of the new state.</p>

<p>@param [Object] new_value the new value for the <a
href="Agent.html">Agent</a> once restarted @param [Hash] opts the
configuration options @option opts [Symbol] :clear_actions true if all
enqueued but unprocessed</p>

<pre>actions should be discarded on restart, else false (default: false)</pre>

<p>@return [Boolean] true</p>

<p>@raise [Concurrent:AgentError] when not failed</p>
          
          

          
          <div class="method-source-code" id="restart-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 423</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">restart</span>(<span class="ruby-identifier">new_value</span>, <span class="ruby-identifier">opts</span> = {})
  <span class="ruby-identifier">clear_actions</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:clear_actions</span>, <span class="ruby-keyword">false</span>)
  <span class="ruby-identifier">synchronize</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;agent is not failed&#39;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">failed?</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ValidationError</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">ns_validate</span>(<span class="ruby-identifier">new_value</span>)
    <span class="ruby-ivar">@current</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">new_value</span>
    <span class="ruby-ivar">@error</span>.<span class="ruby-identifier">value</span>   = <span class="ruby-keyword">nil</span>
    <span class="ruby-ivar">@queue</span>.<span class="ruby-identifier">clear</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">clear_actions</span>
    <span class="ruby-identifier">ns_post_next_job</span> <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@queue</span>.<span class="ruby-identifier">empty?</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-send" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">send</span><span
            class="method-args">(*args, &action)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro [attach] agent_send</p>

<pre>Dispatches an action to the Agent and returns immediately. Subsequently,
in a thread from a thread pool, the {#value} will be set to the return
value of the action. Action dispatches are only allowed when the Agent
is not {#failed?}.

The action must be a block/proc/lambda which takes 1 or more arguments.
The first argument is the current {#value} of the Agent. Any arguments
passed to the send method via the `args` parameter will be passed to the
action as the remaining arguments. The action must return the new value
of the Agent.

* {#send} and {#send!} should be used for actions that are CPU limited
* {#send_off}, {#send_off!}, and {#&lt;&lt;} are appropriate for actions that
  may block on IO
* {#send_via} and {#send_via!} are used when a specific executor is to
  be used for the action

@param [Array&lt;Object&gt;] args zero or more arguments to be passed to
  the action
@param [Proc] action the action dispatch to be enqueued

@yield [agent, value, *args] process the old value and return the new
@yieldparam [Object] value the current {#value} of the Agent
@yieldparam [Array&lt;Object&gt;] args zero or more arguments to pass to the
  action
@yieldreturn [Object] the new value of the Agent</pre>

<p>@!macro [attach] send_return</p>

<pre>@return [Boolean] true if the action is successfully enqueued, false if
  the Agent is {#failed?}</pre>
          
          

          
          <div class="method-source-code" id="send-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 277</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>)
  <span class="ruby-identifier">enqueue_action_job</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>, <span class="ruby-constant">Concurrent</span>.<span class="ruby-identifier">global_fast_executor</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-send-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">send!</span><span
            class="method-args">(*args, &action)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro agent_send</p>

<p>@!macro [attach] send_bang_return_and_raise</p>

<pre>@return [Boolean] true if the action is successfully enqueued
@raise [Concurrent::Agent::Error] if the Agent is {#failed?}</pre>
          
          

          
          <div class="method-source-code" id="send-21-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 286</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">send</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>)
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-send_off" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">send_off</span><span
            class="method-args">(*args, &action)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro agent_send @!macro send_return</p>
          
          

          
          <div class="method-source-code" id="send_off-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 293</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send_off</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>)
  <span class="ruby-identifier">enqueue_action_job</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>, <span class="ruby-constant">Concurrent</span>.<span class="ruby-identifier">global_io_executor</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Agent.html#method-i-post">post</a>
        </div>
        

        
      </div>

    
      <div id="method-i-send_off-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">send_off!</span><span
            class="method-args">(*args, &action)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro agent_send @!macro send_bang_return_and_raise</p>
          
          

          
          <div class="method-source-code" id="send_off-21-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 301</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send_off!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">send_off</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>)
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-send_via" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">send_via</span><span
            class="method-args">(executor, *args, &action)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro agent_send @!macro send_return @param [Concurrent::ExecutorService]
executor the executor on which the</p>

<pre class="ruby"><span class="ruby-identifier">action</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">dispatched</span>
</pre>
          
          

          
          <div class="method-source-code" id="send_via-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 310</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send_via</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>)
  <span class="ruby-identifier">enqueue_action_job</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">executor</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-send_via-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">send_via!</span><span
            class="method-args">(executor, *args, &action)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>@!macro agent_send @!macro send_bang_return_and_raise @param
[Concurrent::ExecutorService] executor the executor on which the</p>

<pre class="ruby"><span class="ruby-identifier">action</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">dispatched</span>
</pre>
          
          

          
          <div class="method-source-code" id="send_via-21-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 318</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send_via!</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">send_via</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>)
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-stopped-3F" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">stopped?</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Agent.html#method-i-failed-3F">failed?</a>
        </div>
        
      </div>

    
      <div id="method-i-value" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">value</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The current value (state) of the <a href="Agent.html">Agent</a>,
irrespective of any pending or in-progress actions. The value is always
available and is non-blocking.</p>

<p>@return [Object] the current value</p>
          
          

          
          <div class="method-source-code" id="value-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 228</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">value</span>
  <span class="ruby-ivar">@current</span>.<span class="ruby-identifier">value</span> <span class="ruby-comment"># TODO (pitr 12-Sep-2015): broken unsafe read?</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Agent.html#method-i-deref">deref</a>
        </div>
        

        
      </div>

    
      <div id="method-i-wait" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">wait</span><span
            class="method-args">(timeout = nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Blocks the current thread until all actions dispatched thus far, from this
thread or nested by the <a href="Agent.html">Agent</a>, have occurred, or
the timeout (in seconds) has elapsed. Will block indefinitely when timeout
is nil or not given.</p>

<p>Provided mainly for consistency with other classes in this library. Prefer
the various `await` methods instead.</p>

<p>@param [Float] timeout the maximum number of seconds to wait @return
[Boolean] true if all actions complete before timeout else false</p>

<p>@!macro agent_await_warning</p>
          
          

          
          <div class="method-source-code" id="wait-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/concurrent-ruby-1.0.5/lib/concurrent/agent.rb, line 392</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">latch</span> = <span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">CountDownLatch</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1</span>)
  <span class="ruby-identifier">enqueue_await_job</span>(<span class="ruby-identifier">latch</span>)
  <span class="ruby-identifier">latch</span>.<span class="ruby-identifier">wait</span>(<span class="ruby-identifier">timeout</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://rdoc.github.io/rdoc">RDoc</a> 5.0.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

