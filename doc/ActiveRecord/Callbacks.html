<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>module ActiveRecord::Callbacks - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
  var index_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/darkfish.js"></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="module">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#module-ActiveRecord::Callbacks-label-Active+Record+Callbacks">Active Record Callbacks</a>
    <li><a href="#module-ActiveRecord::Callbacks-label-Inheritable+callback+queues">Inheritable callback queues</a>
    <li><a href="#module-ActiveRecord::Callbacks-label-Types+of+callbacks">Types of callbacks</a>
    <li><a href="#module-ActiveRecord::Callbacks-label-before_validation-2A+returning+statements"><code>before_validation*</code> returning statements</a>
    <li><a href="#module-ActiveRecord::Callbacks-label-Canceling+callbacks">Canceling callbacks</a>
    <li><a href="#module-ActiveRecord::Callbacks-label-Ordering+callbacks">Ordering callbacks</a>
    <li><a href="#module-ActiveRecord::Callbacks-label-Transactions">Transactions</a>
    <li><a href="#module-ActiveRecord::Callbacks-label-Debugging+callbacks">Debugging callbacks</a>
  </ul>
</div>


  <div id="class-metadata">
    
    
    
    <div id="extends-section" class="nav-section">
  <h3>Extended With Modules</h3>

  <ul class="link-list">
    
  
    <li><a class="extend" href="../ActiveSupport/Concern.html">ActiveSupport::Concern</a>
  
  
  </ul>
</div>

    
  </div>
</nav>

<main role="main" aria-labelledby="module-ActiveRecord::Callbacks">
  <h1 id="module-ActiveRecord::Callbacks" class="module">
    module ActiveRecord::Callbacks
  </h1>

  <section class="description">
    
<h1 id="module-ActiveRecord::Callbacks-label-Active+Record+Callbacks">Active Record Callbacks<span><a href="#module-ActiveRecord::Callbacks-label-Active+Record+Callbacks">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>Callbacks are hooks into the life cycle of an Active Record object that
allow you to trigger logic before or after an alteration of the object
state. This can be used to make sure that associated and dependent objects
are deleted when <a
href="Persistence.html#method-i-destroy">ActiveRecord::Base#destroy</a> is
called (by overwriting <code>before_destroy</code>) or to massage
attributes before they&#39;re validated (by overwriting
<code>before_validation</code>). As an example of the callbacks initiated,
consider the <a
href="Persistence.html#method-i-save">ActiveRecord::Base#save</a> call for
a new record:</p>
<ul><li>
<p>(-) <code>save</code></p>
</li><li>
<p>(-) <code>valid</code></p>
</li><li>
<p>(1) <code>before_validation</code></p>
</li><li>
<p>(-) <code>validate</code></p>
</li><li>
<p>(2) <code>after_validation</code></p>
</li><li>
<p>(3) <code>before_save</code></p>
</li><li>
<p>(4) <code>before_create</code></p>
</li><li>
<p>(-) <code>create</code></p>
</li><li>
<p>(5) <code>after_create</code></p>
</li><li>
<p>(6) <code>after_save</code></p>
</li><li>
<p>(7) <code>after_commit</code></p>
</li></ul>

<p>Also, an <code>after_rollback</code> callback can be configured to be
triggered whenever a rollback is issued. Check out <a
href="Transactions.html">ActiveRecord::Transactions</a> for more details
about <code>after_commit</code> and <code>after_rollback</code>.</p>

<p>Additionally, an <code>after_touch</code> callback is triggered whenever an
object is touched.</p>

<p>Lastly an <code>after_find</code> and <code>after_initialize</code>
callback is triggered for each object that is found and instantiated by a
finder, with <code>after_initialize</code> being triggered after new
objects are instantiated as well.</p>

<p>There are nineteen callbacks in total, which give you immense power to
react and prepare for each state in the Active Record life cycle. The
sequence for calling <a
href="Persistence.html#method-i-save">ActiveRecord::Base#save</a> for an
existing record is similar, except that each <code>_create</code> callback
is replaced by the corresponding <code>_update</code> callback.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">CreditCard</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-comment"># Strip everything but digits, so the user can specify &quot;555 234 34&quot; or</span>
  <span class="ruby-comment"># &quot;5552-3434&quot; and both will mean &quot;55523434&quot;</span>
  <span class="ruby-identifier">before_validation</span>(<span class="ruby-identifier">on</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">create</span>) <span class="ruby-keyword">do</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">number</span> = <span class="ruby-identifier">number</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/[^0-9]/</span>, <span class="ruby-string">&quot;&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">attribute_present?</span>(<span class="ruby-string">&quot;number&quot;</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Subscription</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">before_create</span> :<span class="ruby-identifier">record_signup</span>

  <span class="ruby-identifier">private</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier">record_signup</span>
      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">signed_up_on</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">today</span>
    <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Firm</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-comment"># Disables access to the system, for associated clients and people when the firm is destroyed</span>
  <span class="ruby-identifier">before_destroy</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">record</span><span class="ruby-operator">|</span> <span class="ruby-constant">Person</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">firm_id</span><span class="ruby-operator">:</span> <span class="ruby-identifier">record</span>.<span class="ruby-identifier">id</span>).<span class="ruby-identifier">update_all</span>(<span class="ruby-identifier">access</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;disabled&#39;</span>)   }
  <span class="ruby-identifier">before_destroy</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">record</span><span class="ruby-operator">|</span> <span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">client_of</span><span class="ruby-operator">:</span> <span class="ruby-identifier">record</span>.<span class="ruby-identifier">id</span>).<span class="ruby-identifier">update_all</span>(<span class="ruby-identifier">access</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;disabled&#39;</span>) }
<span class="ruby-keyword">end</span>
</pre>

<h2 id="module-ActiveRecord::Callbacks-label-Inheritable+callback+queues">Inheritable callback queues<span><a href="#module-ActiveRecord::Callbacks-label-Inheritable+callback+queues">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Besides the overwritable callback methods, it&#39;s also possible to
register callbacks through the use of the callback macros. Their main
advantage is that the macros add behavior into a callback queue that is
kept intact down through an inheritance hierarchy.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Topic</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">before_destroy</span> :<span class="ruby-identifier">destroy_author</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Reply</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Topic</span>
  <span class="ruby-identifier">before_destroy</span> :<span class="ruby-identifier">destroy_readers</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Now, when <code>Topic#destroy</code> is run only
<code>destroy_author</code> is called. When <code>Reply#destroy</code> is
run, both <code>destroy_author</code> and <code>destroy_readers</code> are
called. Contrast this to the following situation where the
<code>before_destroy</code> method is overridden:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Topic</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">before_destroy</span>() <span class="ruby-identifier">destroy_author</span> <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Reply</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Topic</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">before_destroy</span>() <span class="ruby-identifier">destroy_readers</span> <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>In that case, <code>Reply#destroy</code> would only run
<code>destroy_readers</code> and <em>not</em> <code>destroy_author</code>.
So, use the callback macros when you want to ensure that a certain callback
is called for the entire hierarchy, and use the regular overwritable
methods when you want to leave it up to each descendant to decide whether
they want to call <code>super</code> and trigger the inherited callbacks.</p>

<p><strong>IMPORTANT:</strong> In order for inheritance to work for the
callback queues, you must specify the callbacks before specifying the
associations. Otherwise, you might trigger the loading of a child before
the parent has registered the callbacks and they won&#39;t be inherited.</p>

<h2 id="module-ActiveRecord::Callbacks-label-Types+of+callbacks">Types of callbacks<span><a href="#module-ActiveRecord::Callbacks-label-Types+of+callbacks">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>There are four types of callbacks accepted by the callback macros: <a
href="../Method.html">Method</a> references (symbol), callback objects,
inline methods (using a proc), and inline eval methods (using a string). <a
href="../Method.html">Method</a> references and callback objects are the
recommended approaches, inline methods using a proc are sometimes
appropriate (such as for creating mix-ins), and inline eval methods are
deprecated.</p>

<p>The method reference callbacks work by specifying a protected or private
method available in the object, like this:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Topic</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">before_destroy</span> :<span class="ruby-identifier">delete_parents</span>

  <span class="ruby-identifier">private</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier">delete_parents</span>
      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">delete_all</span> <span class="ruby-node">&quot;parent_id = #{id}&quot;</span>
    <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The callback objects have methods named after the callback called with the
record as the only parameter, such as:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">BankAccount</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">before_save</span>      <span class="ruby-constant">EncryptionWrapper</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">after_save</span>       <span class="ruby-constant">EncryptionWrapper</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">after_initialize</span> <span class="ruby-constant">EncryptionWrapper</span>.<span class="ruby-identifier">new</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">EncryptionWrapper</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">before_save</span>(<span class="ruby-identifier">record</span>)
    <span class="ruby-identifier">record</span>.<span class="ruby-identifier">credit_card_number</span> = <span class="ruby-identifier">encrypt</span>(<span class="ruby-identifier">record</span>.<span class="ruby-identifier">credit_card_number</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">after_save</span>(<span class="ruby-identifier">record</span>)
    <span class="ruby-identifier">record</span>.<span class="ruby-identifier">credit_card_number</span> = <span class="ruby-identifier">decrypt</span>(<span class="ruby-identifier">record</span>.<span class="ruby-identifier">credit_card_number</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">alias_method</span> :<span class="ruby-identifier">after_initialize</span>, :<span class="ruby-identifier">after_save</span>

  <span class="ruby-identifier">private</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier">encrypt</span>(<span class="ruby-identifier">value</span>)
      <span class="ruby-comment"># Secrecy is committed</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">def</span> <span class="ruby-identifier">decrypt</span>(<span class="ruby-identifier">value</span>)
      <span class="ruby-comment"># Secrecy is unveiled</span>
    <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>So you specify the object you want messaged on a given callback. When that
callback is triggered, the object has a method by the name of the callback
messaged. You can make these callbacks more flexible by passing in other
initialization data such as the name of the attribute to work with:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">BankAccount</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">before_save</span>      <span class="ruby-constant">EncryptionWrapper</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;credit_card_number&quot;</span>)
  <span class="ruby-identifier">after_save</span>       <span class="ruby-constant">EncryptionWrapper</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;credit_card_number&quot;</span>)
  <span class="ruby-identifier">after_initialize</span> <span class="ruby-constant">EncryptionWrapper</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;credit_card_number&quot;</span>)
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">EncryptionWrapper</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">attribute</span>)
    <span class="ruby-ivar">@attribute</span> = <span class="ruby-identifier">attribute</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">before_save</span>(<span class="ruby-identifier">record</span>)
    <span class="ruby-identifier">record</span>.<span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{@attribute}=&quot;</span>, <span class="ruby-identifier">encrypt</span>(<span class="ruby-identifier">record</span>.<span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{@attribute}&quot;</span>)))
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">after_save</span>(<span class="ruby-identifier">record</span>)
    <span class="ruby-identifier">record</span>.<span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{@attribute}=&quot;</span>, <span class="ruby-identifier">decrypt</span>(<span class="ruby-identifier">record</span>.<span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{@attribute}&quot;</span>)))
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">alias_method</span> :<span class="ruby-identifier">after_initialize</span>, :<span class="ruby-identifier">after_save</span>

  <span class="ruby-identifier">private</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier">encrypt</span>(<span class="ruby-identifier">value</span>)
      <span class="ruby-comment"># Secrecy is committed</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">def</span> <span class="ruby-identifier">decrypt</span>(<span class="ruby-identifier">value</span>)
      <span class="ruby-comment"># Secrecy is unveiled</span>
    <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<h2 id="module-ActiveRecord::Callbacks-label-before_validation-2A+returning+statements"><code>before_validation*</code> returning statements<span><a href="#module-ActiveRecord::Callbacks-label-before_validation-2A+returning+statements">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If the <code>before_validation</code> callback throws <code>:abort</code>,
the process will be aborted and <a
href="Persistence.html#method-i-save">ActiveRecord::Base#save</a> will
return <code>false</code>. If <a
href="Persistence.html#method-i-save-21">ActiveRecord::Base#save!</a> is
called it will raise an <a
href="RecordInvalid.html">ActiveRecord::RecordInvalid</a> exception.
Nothing will be appended to the errors object.</p>

<h2 id="module-ActiveRecord::Callbacks-label-Canceling+callbacks">Canceling callbacks<span><a href="#module-ActiveRecord::Callbacks-label-Canceling+callbacks">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If a <code>before_*</code> callback throws <code>:abort</code>, all the
later callbacks and the associated action are cancelled. <a
href="Callbacks.html">Callbacks</a> are generally run in the order they are
defined, with the exception of callbacks defined as methods on the model,
which are called last.</p>

<h2 id="module-ActiveRecord::Callbacks-label-Ordering+callbacks">Ordering callbacks<span><a href="#module-ActiveRecord::Callbacks-label-Ordering+callbacks">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Sometimes the code needs that the callbacks execute in a specific order.
For example, a <code>before_destroy</code> callback
(<code>log_children</code> in this case) should be executed before the
children get destroyed by the <code>dependent: :destroy</code> option.</p>

<p>Let&#39;s look at the code below:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Topic</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">children</span>, <span class="ruby-identifier">dependent</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">destroy</span>

  <span class="ruby-identifier">before_destroy</span> :<span class="ruby-identifier">log_children</span>

  <span class="ruby-identifier">private</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier">log_children</span>
      <span class="ruby-comment"># Child processing</span>
    <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>In this case, the problem is that when the <code>before_destroy</code>
callback is executed, the children are not available because the <a
href="Persistence.html#method-i-destroy">ActiveRecord::Base#destroy</a>
callback gets executed first. You can use the <code>prepend</code> option
on the <code>before_destroy</code> callback to avoid this.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Topic</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">children</span>, <span class="ruby-identifier">dependent</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">destroy</span>

  <span class="ruby-identifier">before_destroy</span> :<span class="ruby-identifier">log_children</span>, <span class="ruby-identifier">prepend</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>

  <span class="ruby-identifier">private</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier">log_children</span>
      <span class="ruby-comment"># Child processing</span>
    <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This way, the <code>before_destroy</code> gets executed before the
<code>dependent: :destroy</code> is called, and the data is still
available.</p>

<p>Also, there are cases when you want several callbacks of the same type to
be executed in order.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Topic</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">children</span>

  <span class="ruby-identifier">after_save</span> :<span class="ruby-identifier">log_children</span>
  <span class="ruby-identifier">after_save</span> :<span class="ruby-identifier">do_something_else</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">log_chidren</span>
    <span class="ruby-comment"># Child processing</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">do_something_else</span>
    <span class="ruby-comment"># Something else</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>In this case the <code>log_children</code> gets executed before
<code>do_something_else</code>. The same applies to all non-transactional
callbacks.</p>

<p>In case there are multiple transactional callbacks as seen below, the order
is reversed.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Topic</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">children</span>

  <span class="ruby-identifier">after_commit</span> :<span class="ruby-identifier">log_children</span>
  <span class="ruby-identifier">after_commit</span> :<span class="ruby-identifier">do_something_else</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">log_chidren</span>
    <span class="ruby-comment"># Child processing</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">do_something_else</span>
    <span class="ruby-comment"># Something else</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>In this case the <code>do_something_else</code> gets executed before
<code>log_children</code>.</p>

<h2 id="module-ActiveRecord::Callbacks-label-Transactions">Transactions<span><a href="#module-ActiveRecord::Callbacks-label-Transactions">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The entire callback chain of a <a
href="Persistence.html#method-i-save">#save</a>, <a
href="Persistence.html#method-i-save-21">#save!</a>, or <a
href="Persistence.html#method-i-destroy">#destroy</a> call runs within a
transaction. That includes <code>after_*</code> hooks. If everything goes
fine a COMMIT is executed once the chain has been completed.</p>

<p>If a <code>before_*</code> callback cancels the action a ROLLBACK is
issued. You can also trigger a ROLLBACK raising an exception in any of the
callbacks, including <code>after_*</code> hooks. Note, however, that in
that case the client needs to be aware of it because an ordinary <a
href="Persistence.html#method-i-save">#save</a> will raise such exception
instead of quietly returning <code>false</code>.</p>

<h2 id="module-ActiveRecord::Callbacks-label-Debugging+callbacks">Debugging callbacks<span><a href="#module-ActiveRecord::Callbacks-label-Debugging+callbacks">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The callback chain is accessible via the <code>_*_callbacks</code> method
on an object. Active Model Callbacks support <code>:before</code>,
<code>:after</code> and <code>:around</code> as values for the
<code>kind</code> property. The <code>kind</code> property defines what
part of the chain the callback runs in.</p>

<p>To find all callbacks in the before_save callback chain:</p>

<pre class="ruby"><span class="ruby-constant">Topic</span>.<span class="ruby-identifier">_save_callbacks</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">cb</span><span class="ruby-operator">|</span> <span class="ruby-identifier">cb</span>.<span class="ruby-identifier">kind</span>.<span class="ruby-identifier">eql?</span>(:<span class="ruby-identifier">before</span>) }
</pre>

<p>Returns an array of callback objects that form the before_save chain.</p>

<p>To further check if the before_save chain contains a proc defined as
<code>rest_when_dead</code> use the <code>filter</code> property of the
callback object:</p>

<pre class="ruby"><span class="ruby-constant">Topic</span>.<span class="ruby-identifier">_save_callbacks</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">cb</span><span class="ruby-operator">|</span> <span class="ruby-identifier">cb</span>.<span class="ruby-identifier">kind</span>.<span class="ruby-identifier">eql?</span>(:<span class="ruby-identifier">before</span>) }.<span class="ruby-identifier">collect</span>(<span class="ruby-operator">&amp;</span>:<span class="ruby-identifier">filter</span>).<span class="ruby-identifier">include?</span>(:<span class="ruby-identifier">rest_when_dead</span>)
</pre>

<p>Returns true or false depending on whether the proc is contained in the
before_save callback chain on a Topic model.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="CALLBACKS">CALLBACKS
        
        <dd>
        
      
      </dl>
    </section>
    

    

    
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://rdoc.github.io/rdoc">RDoc</a> 5.0.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

