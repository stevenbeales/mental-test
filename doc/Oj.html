<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>module Oj - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/darkfish.js"></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="module">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    
    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-add_to_json">::add_to_json</a>
    
    <li ><a href="#method-c-compat_load">::compat_load</a>
    
    <li ><a href="#method-c-default_options">::default_options</a>
    
    <li ><a href="#method-c-default_options-3D">::default_options=</a>
    
    <li ><a href="#method-c-dump">::dump</a>
    
    <li ><a href="#method-c-generate">::generate</a>
    
    <li ><a href="#method-c-json_create">::json_create</a>
    
    <li ><a href="#method-c-load">::load</a>
    
    <li ><a href="#method-c-load_file">::load_file</a>
    
    <li ><a href="#method-c-mimic_JSON">::mimic_JSON</a>
    
    <li ><a href="#method-c-mimic_loaded">::mimic_loaded</a>
    
    <li ><a href="#method-c-object_load">::object_load</a>
    
    <li ><a href="#method-c-register_odd">::register_odd</a>
    
    <li ><a href="#method-c-register_odd_raw">::register_odd_raw</a>
    
    <li ><a href="#method-c-safe_load">::safe_load</a>
    
    <li ><a href="#method-c-saj_parse">::saj_parse</a>
    
    <li ><a href="#method-c-sc_parse">::sc_parse</a>
    
    <li ><a href="#method-c-strict_load">::strict_load</a>
    
    <li ><a href="#method-c-to_file">::to_file</a>
    
    <li ><a href="#method-c-to_json">::to_json</a>
    
    <li ><a href="#method-c-to_stream">::to_stream</a>
    
    <li ><a href="#method-c-wab_load">::wab_load</a>
    
    <li ><a href="#method-i-as_json">#as_json</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="module-Oj">
  <h1 id="module-Oj" class="module">
    module Oj
  </h1>

  <section class="description">
    
<p>Optimized <a href="JSON.html">JSON</a> (Oj), as the name implies was
written to provide speed optimized <a href="JSON.html">JSON</a> handling.</p>

<p><a href="Oj.html">Oj</a> uses modes to control how object are encoded and
decoded. In addition global and options to methods allow additional
behavior modifications. The modes are:</p>
<ul><li>
<p><strong>:strict</strong> mode will only allow the 7 basic <a
href="JSON.html">JSON</a> types to be serialized. Any other <a
href="Object.html">Object</a> will raise an <a
href="Exception.html">Exception</a>.</p>
</li><li>
<p><strong>:null</strong> mode is similar to the :strict mode except any <a
href="Object.html">Object</a> that is not one of the <a
href="JSON.html">JSON</a> base types is replaced by a <a
href="JSON.html">JSON</a> null.</p>
</li><li>
<p><strong>:object</strong> mode will dump any <a
href="Object.html">Object</a> as a <a href="JSON.html">JSON</a> <a
href="Object.html">Object</a> with keys that match the Ruby Object&#39;s
variable names without the &#39;@&#39; character. This is the highest
performance mode.</p>
</li><li>
<p><strong>:compat</strong> or <strong>:json</strong> mode is the compatible
mode for the json gem. It mimics the json gem including the options,
defaults, and restrictions.</p>
</li><li>
<p><strong>:rails</strong> is the compatibility mode for <a
href="Oj/Rails.html">Rails</a> or Active support.</p>
</li><li>
<p><strong>:custom</strong> is the most configurable mode.</p>
</li><li>
<p><strong>:wab</strong> specifically for <a href="WAB.html">WAB</a> data
exchange.</p>
</li></ul>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="DepthError">DepthError
        
        <dd><p>An <a href="Exception.html">Exception</a> that is raised as a result of a
path being too deep.</p>
        
      
        <dt id="Error">Error
        
        <dd><p>Inherit <a href="Error.html">Error</a> class from StandardError.</p>
        
      
        <dt id="LoadError">LoadError
        
        <dd><p>An <a href="Exception.html">Exception</a> that is raised if a file fails to
load.</p>
        
      
        <dt id="MimicError">MimicError
        
        <dd><p>An <a href="Exception.html">Exception</a> that is raised if there is a
conflict with mimicing <a href="JSON.html">JSON</a></p>
        
      
        <dt id="ParseError">ParseError
        
        <dd><p>An <a href="Exception.html">Exception</a> that is raised as a result of a
parse error while parsing a <a href="JSON.html">JSON</a> document.</p>
        
      
        <dt id="VERSION">VERSION
        
        <dd><p>Current version of the module.</p>
        
      
      </dl>
    </section>
    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-add_to_json" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            add_to_json(*args)
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Override simple to_s dump behavior in :compat mode to instead use an
optimized dump that includes the classname and attributes so that the
object can be re-created on load. The format is the same as the json gem
but does not use the ruby methods for encoding.</p>

<p>The classes supported for optimization are: <a href="Array.html">Array</a>,
<a href="BigDecimal.html">BigDecimal</a>, <a
href="Complex.html">Complex</a>, <a href="Date.html">Date</a>, <a
href="DateTime.html">DateTime</a>, <a href="Exception.html">Exception</a>,
<a href="Hash.html">Hash</a>, <a href="Integer.html">Integer</a>,
OpenStruct, <a href="Range.html">Range</a>, <a
href="Rational.html">Rational</a>, Regexp, Struct, and <a
href="Time.html">Time</a>. Providing no classes will result in all those
classes being optimized.q</p>
<ul><li>
<p>*args( [<em>Class</em>] zero or more classes to optimize.</p>
</li></ul>
          
          

          
        </div>

        

        
      </div>

    
      <div id="method-c-compat_load" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            compat_load(json, options) { _|_obj, start, len_|_ }
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Parses a <a href="JSON.html">JSON</a> document <a
href="String.html">String</a> into an <a href="Object.html">Object</a>, <a
href="Hash.html">Hash</a>, <a href="Array.html">Array</a>, <a
href="String.html">String</a>, Fixnum, <a href="Float.html">Float</a>,
true, false, or nil. It parses using a mode that is generally compatible
with other Ruby <a href="JSON.html">JSON</a> parsers in that it will create
objects based on the :create_id value. It is not compatible in every way to
every other parser though as each parser has it&#39;s own variations.</p>

<p>When used with a document that has multiple <a href="JSON.html">JSON</a>
elements the block, if any, will be yielded to. If no block then the last
element read will be returned.</p>

<p>Raises an exception if the <a href="JSON.html">JSON</a> is malformed or the
classes specified are not valid. If the input is not a valid <a
href="JSON.html">JSON</a> document (an empty string is not a valid <a
href="JSON.html">JSON</a> document) an exception is raised.</p>

<p>A block can be provided with a single argument. That argument will be the
parsed <a href="JSON.html">JSON</a> document. This is useful when parsing a
string that includes multiple <a href="JSON.html">JSON</a> documents. The
block can take up to 3 arguments, the parsed object, the position in the
string or stream of the start of the <a href="JSON.html">JSON</a> for that
object, and the length of the <a href="JSON.html">JSON</a> for that object
plus trailing whitespace.</p>
<ul><li>
<p><strong>json</strong> [<em>String</em>|<em>IO</em>] <a
href="JSON.html">JSON</a> <a href="String.html">String</a> or an <a
href="Object.html">Object</a> that responds to read().</p>
</li><li>
<p><strong>options</strong> [<em>Hash</em>] load options (same as <a
href="Oj.html#method-c-default_options">::default_options</a>).</p>
<ul><li>
<p>-</p>
</li></ul>
</li><li>
<p><strong>obj</strong>
[<em>Hash</em>|<em>Array</em>|<em>String</em>|<em>Fixnum</em>|<em>Float</em>|<em>Boolean</em>|<em>nil</em>]
parsed object.</p>
</li><li>
<p><strong>start</strong> [_optional, <em>Integer</em>] start position of
parsed <a href="JSON.html">JSON</a> for obj.</p>
</li><li>
<p><strong>len</strong> [_optional, <em>Integer</em>] length of parsed <a
href="JSON.html">JSON</a> for obj.</p>
</li></ul>

<p>Returns
[<em>Hash</em>|<em>Array</em>|<em>String</em>|<em>Fixnum</em>|<em>Float</em>|<em>Boolean</em>|<em>nil</em>]</p>
          
          

          
        </div>

        

        
      </div>

    
      <div id="method-c-default_options" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            default_options()
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>()</p>

<p>Returns the default load and dump options as a <a
href="Hash.html">Hash</a>. The options are</p>
<ul><li>
<p><strong>:indent</strong> [<em>Fixnum</em>|<em>String</em>|<em>nil</em>]
number of spaces to indent each element in an <a href="JSON.html">JSON</a>
document, zero or nil is no newline between <a href="JSON.html">JSON</a>
elements, negative indicates no newline between top level <a
href="JSON.html">JSON</a> elements in a stream, a <a
href="String.html">String</a> indicates the string should be used for
indentation</p>
</li><li>
<p><strong>:circular</strong> [<em>Boolean</em>|<em>nil</em>] support circular
references while dumping</p>
</li><li>
<p><strong>:auto_define</strong> [<em>Boolean</em>|<em>nil</em>] automatically
define classes if they do not exist</p>
</li><li>
<p><strong>:symbol_keys</strong> [<em>Boolean</em>|<em>nil</em>] use symbols
instead of strings for hash keys</p>
</li><li>
<p><strong>:escape_mode</strong>
[<em>:newline</em>|<em>:json</em>|<em>:xss_safe</em>|<em>:ascii</em>|<em>unicode_xss</em>|<em>nil</em>]
determines the characters to escape</p>
</li><li>
<p><strong>:class_cache</strong> [<em>Boolean</em>|<em>nil</em>] cache classes
for faster parsing (if dynamically modifying classes or reloading classes
then don&#39;t use this)</p>
</li><li>
<p><strong>:mode</strong>
[<em>:object</em>|<em>:strict</em>|<em>:compat</em>|<em>:null</em>|<em>:custom</em>|<em>:rails</em>|<em>:wab</em>]
load and dump modes to use for <a href="JSON.html">JSON</a></p>
</li><li>
<p><strong>:time_format</strong>
[<em>:unix</em>|<em>:unix_zone</em>|<em>:xmlschema</em>|<em>:ruby</em>]
time format when dumping in :compat and :object mode</p>
</li><li>
<p><strong>:bigdecimal_as_decimal</strong> [<em>Boolean</em>|<em>nil</em>]
dump <a href="BigDecimal.html">BigDecimal</a> as a decimal number or as a
<a href="String.html">String</a></p>
</li><li>
<p><strong>:bigdecimal_load</strong>
[<em>:bigdecimal</em>|<em>:float</em>|<em>:auto</em>] load decimals as <a
href="BigDecimal.html">BigDecimal</a> instead of as a <a
href="Float.html">Float</a>. :auto pick the most precise for the number of
digits.</p>
</li><li>
<p><strong>:create_id</strong> [<em>String</em>|<em>nil</em>] create id for
json compatible object encoding, default is &#39;json_class&#39;</p>
</li><li>
<p><strong>:second_precision</strong> [<em>Fixnum</em>|<em>nil</em>] number of
digits after the decimal when dumping the seconds portion of time</p>
</li><li>
<p><strong>:float_precision</strong> [<em>Fixnum</em>|<em>nil</em>] number of
digits of precision when dumping floats, 0 indicates use Ruby</p>
</li><li>
<p><strong>:use_to_json</strong> [<em>Boolean</em>|<em>nil</em>] call <a
href="Oj.html#method-c-to_json">::to_json</a>() methods on dump, default is
false</p>
</li><li>
<p><strong>:use_as_json</strong> [<em>Boolean</em>|<em>nil</em>] call <a
href="Oj.html#method-i-as_json">#as_json</a>() methods on dump, default is
false</p>
</li><li>
<p><strong>:nilnil</strong> [<em>Boolean</em>|<em>nil</em>] if true a nil
input to load will return nil and not raise an <a
href="Exception.html">Exception</a></p>
</li><li>
<p><strong>:empty_string</strong> [<em>Boolean</em>|<em>nil</em>] if true an
empty input will not raise an <a href="Exception.html">Exception</a></p>
</li><li>
<p><strong>:allow_gc</strong> [<em>Boolean</em>|<em>nil</em>] allow or
prohibit GC during parsing, default is true (allow)</p>
</li><li>
<p><strong>:quirks_mode</strong> [<em>true,</em>|<em>false</em>|<em>nil</em>]
Allow single <a href="JSON.html">JSON</a> values instead of documents,
default is true (allow)</p>
</li><li>
<p><strong>:allow_invalid_unicode</strong>
[<em>true,</em>|<em>false</em>|<em>nil</em>] Allow invalid unicode, default
is false (don&#39;t allow)</p>
</li><li>
<p><strong>:allow_nan</strong> [<em>true,</em>|<em>false</em>|<em>nil</em>]
Allow Nan, Infinity, and -Infinity to be parsed, default is true (allow)</p>
</li><li>
<p><strong>:indent_str</strong> [<em>String</em>|<em>nil</em>] <a
href="String.html">String</a> to use for indentation, overriding the indent
option is not nil</p>
</li><li>
<p><strong>:space</strong> [<em>String</em>|<em>nil</em>] <a
href="String.html">String</a> to use for the space after the colon in <a
href="JSON.html">JSON</a> object fields</p>
</li><li>
<p><strong>:space_before</strong> [<em>String</em>|<em>nil</em>] <a
href="String.html">String</a> to use before the colon separator in <a
href="JSON.html">JSON</a> object fields</p>
</li><li>
<p><strong>:object_nl</strong> [<em>String</em>|<em>nil</em>] <a
href="String.html">String</a> to use after a <a href="JSON.html">JSON</a>
object field value</p>
</li><li>
<p><strong>:array_nl</strong> [<em>String</em>|<em>nil</em>] <a
href="String.html">String</a> to use after a <a href="JSON.html">JSON</a>
array value</p>
</li><li>
<p><strong>:nan</strong>
[<em>:null</em>|<em>:huge</em>|<em>:word</em>|<em>:raise</em>|<em>:auto</em>]
how to dump Infinity and NaN in null, strict, and compat mode. :null places
a null, :huge places a huge number, :word places Infinity or NaN, :raise
raises and exception, :auto uses default for each mode.</p>
</li><li>
<p><strong>:hash_class</strong> [<em>Class</em>|<em>nil</em>] <a
href="Class.html">Class</a> to use instead of <a href="Hash.html">Hash</a>
on load, :object_class can also be used</p>
</li><li>
<p><strong>:array_class</strong> [<em>Class</em>|<em>nil</em>] <a
href="Class.html">Class</a> to use instead of <a
href="Array.html">Array</a> on load</p>
</li><li>
<p><strong>:omit_nil</strong> [<em>true</em>|<em>false</em>] if true <a
href="Hash.html">Hash</a> and <a href="Object.html">Object</a> attributes
with nil values are omitted</p>
</li><li>
<p><strong>:ignore</strong> [<em>nil</em>|Array] either nil or an <a
href="Array.html">Array</a> of classes to ignore when dumping</p>
</li></ul>

<p>Return [<em>Hash</em>] all current option settings.</p>
          
          

          
          <div class="method-source-code" id="default_options-source">
            <pre>static VALUE
get_def_opts(VALUE self) {
    VALUE       opts = rb_hash_new();

    if (0 == oj_default_options.dump_opts.indent_size) {
        rb_hash_aset(opts, oj_indent_sym, INT2FIX(oj_default_options.indent));
    } else {
        rb_hash_aset(opts, oj_indent_sym, rb_str_new2(oj_default_options.dump_opts.indent_str));
    }
    rb_hash_aset(opts, sec_prec_sym, INT2FIX(oj_default_options.sec_prec));
    rb_hash_aset(opts, circular_sym, (Yes == oj_default_options.circular) ? Qtrue : ((No == oj_default_options.circular) ? Qfalse : Qnil));
    rb_hash_aset(opts, class_cache_sym, (Yes == oj_default_options.class_cache) ? Qtrue : ((No == oj_default_options.class_cache) ? Qfalse : Qnil));
    rb_hash_aset(opts, auto_define_sym, (Yes == oj_default_options.auto_define) ? Qtrue : ((No == oj_default_options.auto_define) ? Qfalse : Qnil));
    rb_hash_aset(opts, symbol_keys_sym, (Yes == oj_default_options.sym_key) ? Qtrue : ((No == oj_default_options.sym_key) ? Qfalse : Qnil));
    rb_hash_aset(opts, bigdecimal_as_decimal_sym, (Yes == oj_default_options.bigdec_as_num) ? Qtrue : ((No == oj_default_options.bigdec_as_num) ? Qfalse : Qnil));
    rb_hash_aset(opts, use_to_json_sym, (Yes == oj_default_options.to_json) ? Qtrue : ((No == oj_default_options.to_json) ? Qfalse : Qnil));
    rb_hash_aset(opts, use_to_hash_sym, (Yes == oj_default_options.to_hash) ? Qtrue : ((No == oj_default_options.to_hash) ? Qfalse : Qnil));
    rb_hash_aset(opts, use_as_json_sym, (Yes == oj_default_options.as_json) ? Qtrue : ((No == oj_default_options.as_json) ? Qfalse : Qnil));
    rb_hash_aset(opts, nilnil_sym, (Yes == oj_default_options.nilnil) ? Qtrue : ((No == oj_default_options.nilnil) ? Qfalse : Qnil));
    rb_hash_aset(opts, empty_string_sym, (Yes == oj_default_options.empty_string) ? Qtrue : ((No == oj_default_options.empty_string) ? Qfalse : Qnil));
    rb_hash_aset(opts, allow_gc_sym, (Yes == oj_default_options.allow_gc) ? Qtrue : ((No == oj_default_options.allow_gc) ? Qfalse : Qnil));
    rb_hash_aset(opts, oj_quirks_mode_sym, (Yes == oj_default_options.quirks_mode) ? Qtrue : ((No == oj_default_options.quirks_mode) ? Qfalse : Qnil));
    rb_hash_aset(opts, allow_invalid_unicode_sym, (Yes == oj_default_options.allow_invalid) ? Qtrue : ((No == oj_default_options.allow_invalid) ? Qfalse : Qnil));
    rb_hash_aset(opts, oj_allow_nan_sym, (Yes == oj_default_options.allow_nan) ? Qtrue : ((No == oj_default_options.allow_nan) ? Qfalse : Qnil));
    rb_hash_aset(opts, float_prec_sym, INT2FIX(oj_default_options.float_prec));
    switch (oj_default_options.mode) {
    case StrictMode:    rb_hash_aset(opts, mode_sym, strict_sym);  break;
    case CompatMode:    rb_hash_aset(opts, mode_sym, compat_sym);  break;
    case NullMode:      rb_hash_aset(opts, mode_sym, null_sym);              break;
    case ObjectMode:    rb_hash_aset(opts, mode_sym, object_sym);  break;
    case CustomMode:    rb_hash_aset(opts, mode_sym, custom_sym);  break;
    case RailsMode:     rb_hash_aset(opts, mode_sym, rails_sym);    break;
    case WabMode:       rb_hash_aset(opts, mode_sym, wab_sym);                break;
    default:            rb_hash_aset(opts, mode_sym, object_sym); break;
    }
    switch (oj_default_options.escape_mode) {
    case NLEsc:         rb_hash_aset(opts, escape_mode_sym, newline_sym);      break;
    case JSONEsc:       rb_hash_aset(opts, escape_mode_sym, json_sym);                break;
    case XSSEsc:        rb_hash_aset(opts, escape_mode_sym, xss_safe_sym);     break;
    case ASCIIEsc:      rb_hash_aset(opts, escape_mode_sym, ascii_sym);              break;
    case JXEsc:         rb_hash_aset(opts, escape_mode_sym, unicode_xss_sym);  break;
    default:            rb_hash_aset(opts, escape_mode_sym, json_sym);            break;
    }
    switch (oj_default_options.time_format) {
    case XmlTime:       rb_hash_aset(opts, time_format_sym, xmlschema_sym);   break;
    case RubyTime:      rb_hash_aset(opts, time_format_sym, ruby_sym);               break;
    case UnixZTime:     rb_hash_aset(opts, time_format_sym, unix_zone_sym); break;
    case UnixTime:
    default:            rb_hash_aset(opts, time_format_sym, unix_sym);            break;
    }
    switch (oj_default_options.bigdec_load) {
    case BigDec:        rb_hash_aset(opts, bigdecimal_load_sym, bigdecimal_sym);break;
    case FloatDec:      rb_hash_aset(opts, bigdecimal_load_sym, float_sym);  break;
    case AutoDec:
    default:            rb_hash_aset(opts, bigdecimal_load_sym, auto_sym);        break;
    }
    rb_hash_aset(opts, create_id_sym, (0 == oj_default_options.create_id) ? Qnil : rb_str_new2(oj_default_options.create_id));
    rb_hash_aset(opts, oj_space_sym, (0 == oj_default_options.dump_opts.after_size) ? Qnil : rb_str_new2(oj_default_options.dump_opts.after_sep));
    rb_hash_aset(opts, oj_space_before_sym, (0 == oj_default_options.dump_opts.before_size) ? Qnil : rb_str_new2(oj_default_options.dump_opts.before_sep));
    rb_hash_aset(opts, oj_object_nl_sym, (0 == oj_default_options.dump_opts.hash_size) ? Qnil : rb_str_new2(oj_default_options.dump_opts.hash_nl));
    rb_hash_aset(opts, oj_array_nl_sym, (0 == oj_default_options.dump_opts.array_size) ? Qnil : rb_str_new2(oj_default_options.dump_opts.array_nl));

    switch (oj_default_options.dump_opts.nan_dump) {
    case NullNan:       rb_hash_aset(opts, nan_sym, null_sym);        break;
    case RaiseNan:      rb_hash_aset(opts, nan_sym, raise_sym);      break;
    case WordNan:       rb_hash_aset(opts, nan_sym, word_sym);        break;
    case HugeNan:       rb_hash_aset(opts, nan_sym, huge_sym);        break;
    case AutoNan:
    default:            rb_hash_aset(opts, nan_sym, auto_sym);    break;
    }
    rb_hash_aset(opts, omit_nil_sym, oj_default_options.dump_opts.omit_nil ? Qtrue : Qfalse);
    rb_hash_aset(opts, oj_hash_class_sym, oj_default_options.hash_class);
    rb_hash_aset(opts, oj_array_class_sym, oj_default_options.array_class);

    if (NULL == oj_default_options.ignore) {
        rb_hash_aset(opts, ignore_sym, Qnil);
    } else {
        VALUE          *vp;
        volatile VALUE a = rb_ary_new();
        
        for (vp = oj_default_options.ignore; Qnil != *vp; vp++) {
            rb_ary_push(a, *vp);
        }
        rb_hash_aset(opts, ignore_sym, a);
    }
    return opts;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-default_options-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            default_options=(opts)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sets the default options for load and dump.</p>
<ul><li>
<p><strong>opts</strong> [<em>Hash</em>] options to change</p>
<ul><li>
<p><strong>:indent</strong> [<em>Fixnum</em>|<em>String</em>|<em>nil</em>]
number of spaces to indent each element in a <a href="JSON.html">JSON</a>
document or the <a href="String.html">String</a> to use for identation.</p>
</li><li>
<p>:circular [<em>Boolean</em>|<em>nil</em>] support circular references while
dumping.</p>
</li><li>
<p><strong>:auto_define</strong> [<em>Boolean</em>|<em>nil</em>] automatically
define classes if they do not exist.</p>
</li><li>
<p><strong>:symbol_keys</strong> [<em>Boolean</em>|<em>nil</em>] convert hash
keys to symbols.</p>
</li><li>
<p><strong>:class_cache</strong> [<em>Boolean</em>|<em>nil</em>] cache classes
for faster parsing.</p>
</li><li>
<p><strong>:escape</strong>
[<em>:newline</em>|<em>:json</em>|<em>:xss_safe</em>|<em>:ascii</em>|<em>unicode_xss</em>|<em>nil</em>]
mode encodes all high-bit characters as escaped sequences if :ascii, :json
is standand UTF-8 <a href="JSON.html">JSON</a> encoding, :newline is the
same as :json but newlines are not escaped, :unicode_xss allows unicode but
escapes &amp;, &lt;, and &gt;, and any u20xx characters along with some
others, and :xss_safe escapes &amp;, &lt;, and &gt;, and some others.</p>
</li><li>
<p><strong>:bigdecimal_as_decimal</strong> [<em>Boolean</em>|<em>nil</em>]
dump <a href="BigDecimal.html">BigDecimal</a> as a decimal number or as a
<a href="String.html">String</a>.</p>
</li><li>
<p><strong>:bigdecimal_load</strong>
[<em>:bigdecimal</em>|<em>:float</em>|<em>:auto</em>|<em>nil</em>] load
decimals as <a href="BigDecimal.html">BigDecimal</a> instead of as a <a
href="Float.html">Float</a>. :auto pick the most precise for the number of
digits.</p>
</li><li>
<p><strong>:mode</strong>
[<em>:object</em>|<em>:strict</em>|<em>:compat</em>|<em>:null</em>|<em>:custom</em>|<em>:rails</em>|<em>:wab</em>]
load and dump mode to use for <a href="JSON.html">JSON</a> :strict raises
an exception when a non-supported <a href="Object.html">Object</a> is
encountered. :compat attempts to extract variable values from an <a
href="Object.html">Object</a> using <a
href="Oj.html#method-c-to_json">::to_json</a>() or to_hash() then it walks
the Object&#39;s variables if neither is found. The :object mode ignores
to_hash() and <a href="Oj.html#method-c-to_json">::to_json</a>() methods
and encodes variables using code internal to the <a href="Oj.html">Oj</a>
gem. The :null mode ignores non-supported Objects and replaces them with a
null. The :custom mode honors all dump options. The :rails more mimics
rails and Active behavior.</p>
</li><li>
<p><strong>:time_format</strong>
[<em>:unix</em>|<em>:xmlschema</em>|<em>:ruby</em>] time format when
dumping in :compat mode :unix decimal number denoting the number of seconds
since 1/1/1970, :unix_zone decimal number denoting the number of seconds
since 1/1/1970 plus the utc_offset in the exponent, :xmlschema date-time
format taken from XML Schema as a <a href="String.html">String</a>, :ruby
<a href="Time.html#method-i-to_s">Time#to_s</a> formatted <a
href="String.html">String</a>.</p>
</li><li>
<p><strong>:create_id</strong> [<em>String</em>|<em>nil</em>] create id for
json compatible object encoding</p>
</li><li>
<p><strong>:second_precision</strong> [<em>Fixnum</em>|<em>nil</em>] number of
digits after the decimal when dumping the seconds portion of time.</p>
</li><li>
<p><strong>:float_precision</strong> [<em>Fixnum</em>|<em>nil</em>] number of
digits of precision when dumping floats, 0 indicates use Ruby.</p>
</li><li>
<p><strong>:use_to_json</strong> [<em>Boolean</em>|<em>nil</em>] call <a
href="Oj.html#method-c-to_json">::to_json</a>() methods on dump, default is
false.</p>
</li><li>
<p><strong>:use_as_json</strong> [<em>Boolean</em>|<em>nil</em>] call <a
href="Oj.html#method-i-as_json">#as_json</a>() methods on dump, default is
false.</p>
</li><li>
<p><strong>:use_to_hash</strong> [<em>Boolean</em>|<em>nil</em>] call
to_hash() methods on dump, default is false.</p>
</li><li>
<p><strong>:nilnil</strong> [<em>Boolean</em>|<em>nil</em>] if true a nil
input to load will return nil and not raise an <a
href="Exception.html">Exception</a>.</p>
</li><li>
<p><strong>:allow_gc</strong> [<em>Boolean</em>|<em>nil</em>] allow or
prohibit GC during parsing, default is true (allow).</p>
</li><li>
<p><strong>:quirks_mode</strong> [<em>Boolean</em>|<em>nil</em>] allow single
<a href="JSON.html">JSON</a> values instead of documents, default is true
(allow).</p>
</li><li>
<p><strong>:allow_invalid_unicode</strong> [<em>Boolean</em>|<em>nil</em>]
allow invalid unicode, default is false (don&#39;t allow).</p>
</li><li>
<p><strong>:allow_nan</strong> [<em>Boolean</em>|<em>nil</em>] allow Nan,
Infinity, and -Infinity, default is true (allow).</p>
</li><li>
<p><strong>:space</strong> [<em>String</em>|<em>nil</em>] <a
href="String.html">String</a> to use for the space after the colon in <a
href="JSON.html">JSON</a> object fields.</p>
</li><li>
<p><strong>:space_before</strong> [<em>String</em>|<em>nil</em>] <a
href="String.html">String</a> to use before the colon separator in <a
href="JSON.html">JSON</a> object fields.</p>
</li><li>
<p><strong>:object_nl</strong> [<em>String</em>|<em>nil</em>] <a
href="String.html">String</a> to use after a <a href="JSON.html">JSON</a>
object field value.</p>
</li><li>
<p><strong>:array_nl</strong> [<em>String</em>|<em>nil</em>] <a
href="String.html">String</a> to use after a <a href="JSON.html">JSON</a>
array value</p>
</li><li>
<p><strong>:nan</strong>
[<em>:null</em>|<em>:huge</em>|<em>:word</em>|<em>:raise</em>] how to dump
Infinity and NaN in null, strict, and compat mode. :null places a null,
:huge places a huge number, :word places Infinity or NaN, :raise raises and
exception, :auto uses default for each mode.</p>
</li><li>
<p><strong>:hash_class</strong> [<em>Class</em>|<em>nil</em>] <a
href="Class.html">Class</a> to use instead of <a href="Hash.html">Hash</a>
on load, :object_class can also be used.</p>
</li><li>
<p><strong>:array_class</strong> [<em>Class</em>|<em>nil</em>] <a
href="Class.html">Class</a> to use instead of <a
href="Array.html">Array</a> on load.</p>
</li><li>
<p><strong>:omit_nil</strong> [<em>true</em>|<em>false</em>] if true <a
href="Hash.html">Hash</a> and <a href="Object.html">Object</a> attributes
with nil values are omitted.</p>
</li><li>
<p><strong>:ignore</strong> [<em>nil</em>|Array] either nil or an <a
href="Array.html">Array</a> of classes to ignore when dumping</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="default_options-3D-source">
            <pre>static VALUE
set_def_opts(VALUE self, VALUE opts) {
    Check_Type(opts, T_HASH);
    oj_parse_options(opts, &amp;oj_default_options);

    return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-dump" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dump(obj, options)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Dumps an <a href="Object.html">Object</a> (obj) to a string.</p>
<ul><li>
<p><strong>obj</strong> [<em>Object</em>] <a href="Object.html">Object</a> to
serialize as an <a href="JSON.html">JSON</a> document <a
href="String.html">String</a></p>
</li><li>
<p><strong>options</strong> [<em>Hash</em>] same as <a
href="Oj.html#method-c-default_options">::default_options</a></p>
</li></ul>
          
          

          
          <div class="method-source-code" id="dump-source">
            <pre>static VALUE
dump(int argc, VALUE *argv, VALUE self) {
    char                buf[4096];
    struct _Out         out;
    struct _Options     copts = oj_default_options;
    VALUE               rstr;

    if (1 &gt; argc) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (0 for 1).&quot;);
    }
    if (CompatMode == copts.mode) {
        copts.dump_opts.nan_dump = WordNan;
    }
    if (2 == argc) {
        oj_parse_options(argv[1], &amp;copts);
    }
    out.buf = buf;
    out.end = buf + sizeof(buf) - 10;
    out.allocated = false;
    out.omit_nil = copts.dump_opts.omit_nil;
    out.caller = CALLER_DUMP;
    oj_dump_obj_to_json_using_params(*argv, &amp;copts, &amp;out, argc - 1,argv + 1);
    if (0 == out.buf) {
        rb_raise(rb_eNoMemError, &quot;Not enough memory.&quot;);
    }
    rstr = rb_str_new2(out.buf);
    rstr = oj_encode(rstr);
    if (out.allocated) {
        xfree(out.buf);
    }
    return rstr;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-generate" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            generate(obj, opts=nil)
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Encode obj as a <a href="JSON.html">JSON</a> <a
href="String.html">String</a>. The obj argument must be a <a
href="Hash.html">Hash</a>, <a href="Array.html">Array</a>, or respond to
to_h or to_json. <a
href="vendor/bundle/ruby/2_4_0/gems/oj-3_4_0/pages/Options_md.html">Options</a>
other than those listed such as <code>:allow_nan</code> or
<code>:max_nesting</code> are ignored.</p>
<ul><li>
<p><strong>obj</strong> [<em>Object_</em>|<em>Hash</em>|<em>Array</em>] object
to convert to a <a href="JSON.html">JSON</a> <a
href="String.html">String</a></p>
</li><li>
<p><strong>opts</strong> [<em>Hash</em>] options</p>
</li><li><ul><li>
<p><strong>:indent</strong> [<em>String</em>] <a href="String.html">String</a>
to use for indentation.</p>
</li><li>
<p><strong>:space</strong> [<em>String</em>] <a href="String.html">String</a>
placed after a , or : delimiter</p>
</li><li>
<p>*:space * _before [<em>String</em>] <a href="String.html">String</a> placed
before a : delimiter</p>
</li><li>
<p><strong>:object_nl</strong> [<em>String</em>] <a
href="String.html">String</a> placed after a <a href="JSON.html">JSON</a>
object</p>
</li><li>
<p><strong>:array_nl</strong> [<em>String</em>] <a
href="String.html">String</a> placed after a <a href="JSON.html">JSON</a>
array</p>
</li><li>
<p><strong>:ascii_only</strong> [<em>Boolean</em>] if not nil or false then
use only ascii characters in the output. Note <a
href="JSON.html#method-c-generate">JSON.generate</a> does support this even
if it is not documented.</p>
</li></ul>
</li></ul>

<p>Returns [<em>String</em>]generated <a href="JSON.html">JSON</a>.</p>
          
          

          
        </div>

        

        
      </div>

    
      <div id="method-c-json_create" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">json_create</span><span
            class="method-args">(h)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="json_create-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/oj-3.4.0/lib/oj/mimic.rb, line 62</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">h</span>)
  <span class="ruby-identifier">new</span>(<span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;t&#39;</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">h</span>[<span class="ruby-value">:t</span>])
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-load" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            load(json, options) { _|_obj, start, len_|_ }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Parses a <a href="JSON.html">JSON</a> document <a
href="String.html">String</a> into a <a href="Object.html">Object</a>, <a
href="Hash.html">Hash</a>, <a href="Array.html">Array</a>, <a
href="String.html">String</a>, Fixnum, <a href="Float.html">Float</a>,
true, false, or nil according to the default mode or the mode specified.
Raises an exception if the <a href="JSON.html">JSON</a> is malformed or the
classes specified are not valid. If the string input is not a valid <a
href="JSON.html">JSON</a> document (an empty string is not a valid <a
href="JSON.html">JSON</a> document) an exception is raised.</p>

<p>When used with a document that has multiple <a href="JSON.html">JSON</a>
elements the block, if any, will be yielded to. If no block then the last
element read will be returned.</p>

<p>This parser operates on string and will attempt to load files into memory
if a file object is passed as the first argument. A stream input will be
parsed using a stream parser but others use the slightly faster string
parser.</p>

<p>A block can be provided with a single argument. That argument will be the
parsed <a href="JSON.html">JSON</a> document. This is useful when parsing a
string that includes multiple <a href="JSON.html">JSON</a> documents. The
block can take up to 3 arguments, the parsed object, the position in the
string or stream of the start of the <a href="JSON.html">JSON</a> for that
object, and the length of the <a href="JSON.html">JSON</a> for that object
plus trailing whitespace.</p>
<ul><li>
<p><strong>json</strong> [<em>String</em>|<em>IO</em>] <a
href="JSON.html">JSON</a> <a href="String.html">String</a> or an <a
href="Object.html">Object</a> that responds to read()</p>
</li><li>
<p><strong>options</strong> [<em>Hash</em>] load options (same as <a
href="Oj.html#method-c-default_options">::default_options</a>)</p>
<ul><li>
<p>-</p>
</li></ul>
</li><li>
<p><strong>obj</strong>
[<em>Hash</em>|<em>Array</em>|<em>String</em>|<em>Fixnum</em>|<em>Float</em>|<em>Boolean</em>|<em>nil</em>]
parsed object.</p>
</li><li>
<p><strong>start</strong> [_optional, <em>Integer</em>] start position of
parsed <a href="JSON.html">JSON</a> for obj.</p>
</li><li>
<p><strong>len</strong> [_optional, <em>Integer</em>] length of parsed <a
href="JSON.html">JSON</a> for obj.</p>
</li></ul>

<p>Returns
[<em>Hash</em>|<em>Array</em>|<em>String</em>|<em>Fixnum</em>|<em>Float</em>|<em>Boolean</em>|<em>nil</em>]</p>
          
          

          
          <div class="method-source-code" id="load-source">
            <pre>static VALUE
load(int argc, VALUE *argv, VALUE self) {
    Mode        mode = oj_default_options.mode;

    if (1 &gt; argc) {
        rb_raise(rb_eArgError, &quot;Wrong number of arguments to load().&quot;);
    }
    if (2 &lt;= argc) {
        VALUE  ropts = argv[1];
        VALUE  v;

        if (Qnil != ropts || CompatMode != mode) {
            Check_Type(ropts, T_HASH);
            if (Qnil != (v = rb_hash_lookup(ropts, mode_sym))) {
                if (object_sym == v) {
                    mode = ObjectMode;
                } else if (strict_sym == v) {
                    mode = StrictMode;
                } else if (compat_sym == v || json_sym == v) {
                    mode = CompatMode;
                } else if (null_sym == v) {
                    mode = NullMode;
                } else if (custom_sym == v) {
                    mode = CustomMode;
                } else if (rails_sym == v) {
                    mode = RailsMode;
                } else if (wab_sym == v) {
                    mode = WabMode;
                } else {
                    rb_raise(rb_eArgError, &quot;:mode must be :object, :strict, :compat, :null, :custom, :rails, or :wab.&quot;);
                }
            }
        }
    }
    switch (mode) {
    case StrictMode:
    case NullMode:
        return oj_strict_parse(argc, argv, self);
    case CompatMode:
    case RailsMode:
        return oj_compat_parse(argc, argv, self);
    case CustomMode:
        return oj_custom_parse(argc, argv, self);
    case WabMode:
        return oj_wab_parse(argc, argv, self);
    case ObjectMode:
    default:
        break;
    }
    return oj_object_parse(argc, argv, self);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-load_file" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            load_file(path, options) { _|_obj, start, len_|_ }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Parses a <a href="JSON.html">JSON</a> document <a
href="String.html">String</a> into a <a href="Object.html">Object</a>, <a
href="Hash.html">Hash</a>, <a href="Array.html">Array</a>, <a
href="String.html">String</a>, Fixnum, <a href="Float.html">Float</a>,
true, false, or nil according to the default mode or the mode specified.
Raises an exception if the <a href="JSON.html">JSON</a> is malformed or the
classes specified are not valid. If the string input is not a valid <a
href="JSON.html">JSON</a> document (an empty string is not a valid <a
href="JSON.html">JSON</a> document) an exception is raised.</p>

<p>When used with a document that has multiple <a href="JSON.html">JSON</a>
elements the block, if any, will be yielded to. If no block then the last
element read will be returned.</p>

<p>If the input file is not a valid <a href="JSON.html">JSON</a> document (an
empty file is not a valid <a href="JSON.html">JSON</a> document) an
exception is raised.</p>

<p>This is a stream based parser which allows a large or huge file to be
loaded without pulling the whole file into memory.</p>

<p>A block can be provided with a single argument. That argument will be the
parsed <a href="JSON.html">JSON</a> document. This is useful when parsing a
string that includes multiple <a href="JSON.html">JSON</a> documents. The
block can take up to 3 arguments, the parsed object, the position in the
string or stream of the start of the <a href="JSON.html">JSON</a> for that
object, and the length of the <a href="JSON.html">JSON</a> for that object
plus trailing whitespace.</p>
<ul><li>
<p><strong>path</strong> [<em>String</em>] to a file containing a <a
href="JSON.html">JSON</a> document</p>
</li><li>
<p><strong>options</strong> [<em>Hash</em>] load options (same as <a
href="Oj.html#method-c-default_options">::default_options</a>)</p>
<ul><li>
<p>-</p>
</li></ul>
</li><li>
<p><strong>obj</strong>
[<em>Hash</em>|<em>Array</em>|<em>String</em>|<em>Fixnum</em>|<em>Float</em>|<em>Boolean</em>|<em>nil</em>]
parsed object.</p>
</li><li>
<p><strong>start</strong> [_optional, <em>Integer</em>] start position of
parsed <a href="JSON.html">JSON</a> for obj.</p>
</li><li>
<p><strong>len</strong> [_optional, <em>Integer</em>] length of parsed <a
href="JSON.html">JSON</a> for obj.</p>
</li></ul>

<p>Returns
[<em>Object</em>|<em>Hash</em>|<em>Array</em>|<em>String</em>|<em>Fixnum</em>|<em>Float</em>|<em>Boolean</em>|<em>nil</em>]</p>
          
          

          
          <div class="method-source-code" id="load_file-source">
            <pre>static VALUE
load_file(int argc, VALUE *argv, VALUE self) {
    char                *path;
    int                 fd;
    Mode                mode = oj_default_options.mode;
    struct _ParseInfo   pi;

    if (1 &gt; argc) {
        rb_raise(rb_eArgError, &quot;Wrong number of arguments to load().&quot;);
    }
    Check_Type(*argv, T_STRING);
    parse_info_init(&amp;pi);
    pi.options = oj_default_options;
    pi.handler = Qnil;
    pi.err_class = Qnil;
    pi.max_depth = 0;
    if (2 &lt;= argc) {
        VALUE  ropts = argv[1];
        VALUE  v;

        Check_Type(ropts, T_HASH);
        if (Qnil != (v = rb_hash_lookup(ropts, mode_sym))) {
            if (object_sym == v) {
                mode = ObjectMode;
            } else if (strict_sym == v) {
                mode = StrictMode;
            } else if (compat_sym == v || json_sym == v) {
                mode = CompatMode;
            } else if (null_sym == v) {
                mode = NullMode;
            } else if (custom_sym == v) {
                mode = CustomMode;
            } else if (rails_sym == v) {
                mode = RailsMode;
            } else if (wab_sym == v) {
                mode = WabMode;
            } else {
                rb_raise(rb_eArgError, &quot;:mode must be :object, :strict, :compat, :null, :custom, :rails, or :wab.&quot;);
            }
        }
    }
    path = StringValuePtr(*argv);
    if (0 == (fd = open(path, O_RDONLY))) {
        rb_raise(rb_eIOError, &quot;%s&quot;, strerror(errno));
    }
    switch (mode) {
    case StrictMode:
        oj_set_strict_callbacks(&amp;pi);
        return oj_pi_sparse(argc, argv, &amp;pi, fd);
    case NullMode:
    case CompatMode:
    case CustomMode:
    case RailsMode:
        oj_set_compat_callbacks(&amp;pi);
        return oj_pi_sparse(argc, argv, &amp;pi, fd);
    case WabMode:
        oj_set_wab_callbacks(&amp;pi);
        return oj_pi_sparse(argc, argv, &amp;pi, fd);
    case ObjectMode:
    default:
        break;
    }
    oj_set_object_callbacks(&amp;pi);

    return oj_pi_sparse(argc, argv, &amp;pi, fd);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-mimic_JSON" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            mimic_JSON()
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates the <a href="JSON.html">JSON</a> module with methods and classes to
mimic the <a href="JSON.html">JSON</a> gem. After this method is invoked
calls that expect the <a href="JSON.html">JSON</a> module will use <a
href="Oj.html">Oj</a> instead and be faster than the original <a
href="JSON.html">JSON</a>. Most options that could be passed to the <a
href="JSON.html">JSON</a> methods are supported. The calls to set parser or
generator will not raise an <a href="Exception.html">Exception</a> but will
not have any effect. The method can also be called after the json gem is
loaded. The necessary methods on the json gem will be replaced with <a
href="Oj.html">Oj</a> methods.</p>

<p>Note that this also sets the default options of :mode to :compat and
:encoding to :unicode_xss.</p>

<p>Returns [<em>Module</em>] the <a href="JSON.html">JSON</a> module.</p>
          
          

          
        </div>

        

        
      </div>

    
      <div id="method-c-mimic_loaded" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">mimic_loaded</span><span
            class="method-args">(mimic_paths=[])</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Loads mimic-ed <a href="JSON.html">JSON</a> paths. Used by <a
href="Oj.html#method-c-mimic_JSON">::mimic_JSON</a>. @param mimic_path
[Array] additional paths to add to the Ruby loaded features.</p>
          
          

          
          <div class="method-source-code" id="mimic_loaded-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/oj-3.4.0/lib/oj/mimic.rb, line 35</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">mimic_loaded</span>(<span class="ruby-identifier">mimic_paths</span>=[])
  <span class="ruby-identifier">$LOAD_PATH</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">d</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">next</span> <span class="ruby-keyword">unless</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">exist?</span>(<span class="ruby-identifier">d</span>)

    <span class="ruby-identifier">jfile</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">join</span>(<span class="ruby-identifier">d</span>, <span class="ruby-string">&#39;json.rb&#39;</span>)
    <span class="ruby-identifier">$LOADED_FEATURES</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">jfile</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">$LOADED_FEATURES</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">jfile</span>) <span class="ruby-keyword">if</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">exist?</span>(<span class="ruby-identifier">jfile</span>)
    
    <span class="ruby-constant">Dir</span>.<span class="ruby-identifier">glob</span>(<span class="ruby-constant">File</span>.<span class="ruby-identifier">join</span>(<span class="ruby-identifier">d</span>, <span class="ruby-string">&#39;json&#39;</span>, <span class="ruby-string">&#39;**&#39;</span>, <span class="ruby-string">&#39;*.rb&#39;</span>)).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">file</span><span class="ruby-operator">|</span>
      <span class="ruby-comment"># allow json/add/xxx to be loaded. User can override with Oj.add_to_json(xxx).</span>
      <span class="ruby-identifier">$LOADED_FEATURES</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">file</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">$LOADED_FEATURES</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">file</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">file</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&#39;add&#39;</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">mimic_paths</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">p</span><span class="ruby-operator">|</span> <span class="ruby-identifier">$LOADED_FEATURES</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">p</span> }
  <span class="ruby-identifier">$LOADED_FEATURES</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&#39;json&#39;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">$LOADED_FEATURES</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&#39;json&#39;</span>)

  <span class="ruby-identifier">require</span> <span class="ruby-string">&#39;oj/json&#39;</span>

  <span class="ruby-keyword">if</span> <span class="ruby-constant">Object</span>.<span class="ruby-identifier">const_defined?</span>(<span class="ruby-string">&#39;OpenStruct&#39;</span>)
    <span class="ruby-constant">OpenStruct</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-keyword">do</span>
      <span class="ruby-comment"># Both the JSON gem and Rails monkey patch as_json. Let them battle it out.</span>
      <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">as_json</span>)
        <span class="ruby-keyword">def</span> <span class="ruby-identifier">as_json</span>(<span class="ruby-operator">*</span>)
          <span class="ruby-identifier">name</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">to_s</span>
          <span class="ruby-identifier">raise</span> <span class="ruby-constant">JSON</span><span class="ruby-operator">::</span><span class="ruby-constant">JSONError</span>, <span class="ruby-string">&quot;Only named structs are supported!&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-value">0</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">length</span>
          { <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">name</span>, <span class="ruby-string">&#39;t&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">table</span> }
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">h</span>)
        <span class="ruby-identifier">new</span>(<span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;t&#39;</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">h</span>[<span class="ruby-value">:t</span>])
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># Both the JSON gem and Rails monkey patch as_json. Let them battle it out.</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">as_json</span>)
      <span class="ruby-keyword">def</span> <span class="ruby-identifier">as_json</span>(<span class="ruby-operator">*</span>)
        {<span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;BigDecimal&#39;</span>, <span class="ruby-string">&#39;b&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">_dump</span> }
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">h</span>)
      <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">_load</span>(<span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;b&#39;</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Complex</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># Both the JSON gem and Rails monkey patch as_json. Let them battle it out.</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">as_json</span>)
      <span class="ruby-keyword">def</span> <span class="ruby-identifier">as_json</span>(<span class="ruby-operator">*</span>)
        {<span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;Complex&#39;</span>, <span class="ruby-string">&#39;r&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">real</span>, <span class="ruby-string">&#39;i&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">imag</span> }
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">h</span>)
      <span class="ruby-constant">Complex</span>(<span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;r&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;i&#39;</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Date</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># Both the JSON gem and Rails monkey patch as_json. Let them battle it out.</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">as_json</span>)
      <span class="ruby-keyword">def</span> <span class="ruby-identifier">as_json</span>(<span class="ruby-operator">*</span>)
        { <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;Date&#39;</span>, <span class="ruby-string">&#39;y&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">year</span>, <span class="ruby-string">&#39;m&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">month</span>, <span class="ruby-string">&#39;d&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">day</span>, <span class="ruby-string">&#39;sg&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">start</span> }
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">h</span>)
      <span class="ruby-identifier">civil</span>(<span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;y&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;m&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;d&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;sg&#39;</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># Both the JSON gem and Rails monkey patch as_json. Let them battle it out.</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">as_json</span>)
      <span class="ruby-keyword">def</span> <span class="ruby-identifier">as_json</span>(<span class="ruby-operator">*</span>)
        { <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;DateTime&#39;</span>,
          <span class="ruby-string">&#39;y&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">year</span>,
          <span class="ruby-string">&#39;m&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">month</span>,
          <span class="ruby-string">&#39;d&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">day</span>,
          <span class="ruby-string">&#39;H&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">hour</span>,
          <span class="ruby-string">&#39;M&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">min</span>,
          <span class="ruby-string">&#39;S&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">sec</span>,
          <span class="ruby-string">&#39;of&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">offset</span>.<span class="ruby-identifier">to_s</span>,
          <span class="ruby-string">&#39;sg&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">start</span> }
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">h</span>)
      <span class="ruby-comment"># offset is a rational as a string</span>
      <span class="ruby-identifier">as</span>, <span class="ruby-identifier">bs</span> = <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;of&#39;</span>].<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;/&#39;</span>)
      <span class="ruby-identifier">a</span> = <span class="ruby-identifier">as</span>.<span class="ruby-identifier">to_i</span>
      <span class="ruby-identifier">b</span> = <span class="ruby-identifier">bs</span>.<span class="ruby-identifier">to_i</span>
      <span class="ruby-keyword">if</span> <span class="ruby-value">0</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">b</span>
        <span class="ruby-identifier">off</span> = <span class="ruby-identifier">a</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">off</span> = <span class="ruby-constant">Rational</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>)
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">civil</span>(<span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;y&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;m&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;d&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;H&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;M&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;S&#39;</span>], <span class="ruby-identifier">off</span>, <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;sg&#39;</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Date</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># Both the JSON gem and Rails monkey patch as_json. Let them battle it out.</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">as_json</span>)
      <span class="ruby-keyword">def</span> <span class="ruby-identifier">as_json</span>(<span class="ruby-operator">*</span>)
        { <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;Date&#39;</span>, <span class="ruby-string">&#39;y&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">year</span>, <span class="ruby-string">&#39;m&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">month</span>, <span class="ruby-string">&#39;d&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">day</span>, <span class="ruby-string">&#39;sg&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">start</span> }
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">h</span>)
      <span class="ruby-identifier">civil</span>(<span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;y&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;m&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;d&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;sg&#39;</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Exception</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># Both the JSON gem and Rails monkey patch as_json. Let them battle it out.</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">as_json</span>)
      <span class="ruby-keyword">def</span> <span class="ruby-identifier">as_json</span>(<span class="ruby-operator">*</span>)
        {<span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>, <span class="ruby-string">&#39;m&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">message</span>, <span class="ruby-string">&#39;b&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">backtrace</span> }
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">h</span>)
      <span class="ruby-identifier">e</span> = <span class="ruby-identifier">new</span>(<span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;m&#39;</span>])
      <span class="ruby-identifier">e</span>.<span class="ruby-identifier">set_backtrace</span>(<span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;b&#39;</span>])
      <span class="ruby-identifier">e</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Range</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># Both the JSON gem and Rails monkey patch as_json. Let them battle it out.</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">as_json</span>)
      <span class="ruby-keyword">def</span> <span class="ruby-identifier">as_json</span>(<span class="ruby-operator">*</span>)
        {<span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;Range&#39;</span>, <span class="ruby-string">&#39;a&#39;</span> =<span class="ruby-operator">&gt;</span> [<span class="ruby-identifier">first</span>, <span class="ruby-identifier">last</span>, <span class="ruby-identifier">exclude_end?</span>]}
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">h</span>)
      <span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;a&#39;</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Rational</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># Both the JSON gem and Rails monkey patch as_json. Let them battle it out.</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">as_json</span>)
      <span class="ruby-keyword">def</span> <span class="ruby-identifier">as_json</span>(<span class="ruby-operator">*</span>)
        {<span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;Rational&#39;</span>, <span class="ruby-string">&#39;n&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">numerator</span>, <span class="ruby-string">&#39;d&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">denominator</span> }
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">h</span>)
      <span class="ruby-constant">Rational</span>(<span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;n&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;d&#39;</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># Both the JSON gem and Rails monkey patch as_json. Let them battle it out.</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">as_json</span>)
      <span class="ruby-keyword">def</span> <span class="ruby-identifier">as_json</span>(<span class="ruby-operator">*</span>)
        {<span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;Regexp&#39;</span>, <span class="ruby-string">&#39;o&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>, <span class="ruby-string">&#39;s&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">source</span> }
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">h</span>)
      <span class="ruby-identifier">new</span>(<span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;s&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;o&#39;</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Struct</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># Both the JSON gem and Rails monkey patch as_json. Let them battle it out.</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">as_json</span>)
      <span class="ruby-keyword">def</span> <span class="ruby-identifier">as_json</span>(<span class="ruby-operator">*</span>)
        <span class="ruby-identifier">name</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">to_s</span>
        <span class="ruby-identifier">raise</span> <span class="ruby-constant">JSON</span><span class="ruby-operator">::</span><span class="ruby-constant">JSONError</span>, <span class="ruby-string">&quot;Only named structs are supported!&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-value">0</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">length</span>
        { <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">name</span>, <span class="ruby-string">&#39;v&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">values</span> }
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">h</span>)
      <span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;v&#39;</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Symbol</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># Both the JSON gem and Rails monkey patch as_json. Let them battle it out.</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">as_json</span>)
      <span class="ruby-keyword">def</span> <span class="ruby-identifier">as_json</span>(<span class="ruby-operator">*</span>)
        {<span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;Symbol&#39;</span>, <span class="ruby-string">&#39;s&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">to_s</span> }
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">h</span>)
      <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;s&#39;</span>].<span class="ruby-identifier">to_sym</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Time</span>.<span class="ruby-identifier">class_eval</span> <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># Both the JSON gem and Rails monkey patch as_json. Let them battle it out.</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">as_json</span>)
      <span class="ruby-keyword">def</span> <span class="ruby-identifier">as_json</span>(<span class="ruby-operator">*</span>)
        <span class="ruby-identifier">nsecs</span> = [ <span class="ruby-identifier">tv_usec</span> <span class="ruby-operator">*</span> <span class="ruby-value">1000</span> ]
        <span class="ruby-identifier">nsecs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">tv_nsec</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:tv_nsec</span>)
        <span class="ruby-identifier">nsecs</span> = <span class="ruby-identifier">nsecs</span>.<span class="ruby-identifier">max</span>
        { <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;Time&#39;</span>, <span class="ruby-string">&#39;s&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">tv_sec</span>, <span class="ruby-string">&#39;n&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">nsecs</span> }
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">h</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">usec</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">&#39;u&#39;</span>)
        <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;n&#39;</span>] = <span class="ruby-identifier">usec</span> <span class="ruby-operator">*</span> <span class="ruby-value">1000</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">instance_methods</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-value">:tv_nsec</span>)
        <span class="ruby-identifier">at</span>(<span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;s&#39;</span>], <span class="ruby-constant">Rational</span>(<span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;n&#39;</span>], <span class="ruby-value">1000</span>))
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">at</span>(<span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;s&#39;</span>], <span class="ruby-identifier">h</span>[<span class="ruby-string">&#39;n&#39;</span>] <span class="ruby-operator">/</span> <span class="ruby-value">1000</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-object_load" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            object_load(json, options) { _|_obj, start, len_|_ }
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Parses a <a href="JSON.html">JSON</a> document <a
href="String.html">String</a> into an <a href="Object.html">Object</a>, <a
href="Hash.html">Hash</a>, <a href="Array.html">Array</a>, <a
href="String.html">String</a>, Fixnum, <a href="Float.html">Float</a>,
true, false, or nil. In the :object mode the <a href="JSON.html">JSON</a>
should have been generated by <a href="Oj.html#method-c-dump">::dump</a>.
The parser will reconstitute the original marshalled or dumped <a
href="Object.html">Object</a>. The :auto_define and :circular options have
meaning with this parsing mode.</p>

<p>Raises an exception if the <a href="JSON.html">JSON</a> is malformed or the
classes specified are not valid. If the input is not a valid <a
href="JSON.html">JSON</a> document (an empty string is not a valid <a
href="JSON.html">JSON</a> document) an exception is raised.</p>

<p>Note: <a href="Oj.html">Oj</a> is not able to automatically deserialize all
classes that are a subclass of a Ruby <a
href="Exception.html">Exception</a>. Only exception that take one required
string argument in the initialize() method are supported. This is an
example of how to write an <a href="Exception.html">Exception</a> subclass
that supports both a single string intializer and an <a
href="Exception.html">Exception</a> as an argument. Additional optional
arguments can be added as well.</p>

<p>The reason for this restriction has to do with a design decision on the
part of the Ruby developers. Exceptions are special Objects. They do not
follow the rules of other Objects. Exceptions have &#39;mesg&#39; and a
&#39;bt&#39; attribute. Note that these are not &#39;@mesg&#39; and
&#39;@bt&#39;. They can not be set using the normal C or Ruby calls. The
only way I have found to set the &#39;mesg&#39; attribute is through the
initializer. Unfortunately that means any subclass that provides a
different initializer can not be automatically decoded. A way around this
is to use a create function but this example shows an alternative.</p>

<p>A block can be provided with a single argument. That argument will be the
parsed <a href="JSON.html">JSON</a> document. This is useful when parsing a
string that includes multiple <a href="JSON.html">JSON</a> documents. The
block can take up to 3 arguments, the parsed object, the position in the
string or stream of the start of the <a href="JSON.html">JSON</a> for that
object, and the length of the <a href="JSON.html">JSON</a> for that object
plus trailing whitespace.</p>
<ul><li>
<p><strong>json</strong> [<em>String</em>|<em>IO</em>] <a
href="JSON.html">JSON</a> <a href="String.html">String</a> or an <a
href="Object.html">Object</a> that responds to read().</p>
</li><li>
<p><strong>options</strong> [<em>Hash</em>] load options (same as <a
href="Oj.html#method-c-default_options">::default_options</a>).</p>
<ul><li>
<p>-</p>
</li></ul>
</li><li>
<p><strong>obj</strong>
[<em>Hash</em>|<em>Array</em>|<em>String</em>|<em>Fixnum</em>|<em>Float</em>|<em>Boolean</em>|<em>nil</em>]
parsed object.</p>
</li><li>
<p><strong>start</strong> [_optional, <em>Integer</em>] start position of
parsed <a href="JSON.html">JSON</a> for obj.</p>
</li><li>
<p><strong>len</strong> [_optional, <em>Integer</em>] length of parsed <a
href="JSON.html">JSON</a> for obj.</p>
</li></ul>

<p>Returns
[<em>Hash</em>|<em>Array</em>|<em>String</em>|<em>Fixnum</em>|<em>Float</em>|<em>Boolean</em>|<em>nil</em>]</p>
          
          

          
        </div>

        

        
      </div>

    
      <div id="method-c-register_odd" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            register_odd(clas, create_object, create_method, *members)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Registers a class as special. This is useful for working around subclasses
of primitive types as is done with <a
href="ActiveSupport.html">ActiveSupport</a> classes. The use of this
function should be limited to just classes that can not be handled in the
normal way. It is not intended as a hook for changing the output of all
classes as it is not optimized for large numbers of classes.</p>
<ul><li>
<p><strong>clas</strong> [<em>Class_</em>|<em>Module</em>] <a
href="Class.html">Class</a> or <a href="Module.html">Module</a> to be made
special</p>
</li><li>
<p><strong>create_object</strong> [<em>Object</em>]  object to call the create
method on</p>
</li><li>
<p><strong>create_method</strong> [<em>Symbol</em>] method on the clas that
will create a new instance of the clas when given all the member values in
the order specified.</p>
</li><li>
<p><strong>members</strong> [<em>Symbol_</em>|<em>String</em>] methods used to
get the member values from instances of the clas.</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="register_odd-source">
            <pre>static VALUE
register_odd(int argc, VALUE *argv, VALUE self) {
    if (3 &gt; argc) {
        rb_raise(rb_eArgError, &quot;incorrect number of arguments.&quot;);
    }
    switch (rb_type(*argv)) {
    case T_CLASS:
    case T_MODULE:
        break;
    default:
        rb_raise(rb_eTypeError, &quot;expected a class or module.&quot;);
        break;
    }
    Check_Type(argv[2], T_SYMBOL);
    if (MAX_ODD_ARGS &lt; argc - 2) {
        rb_raise(rb_eArgError, &quot;too many members.&quot;);
    }
    oj_reg_odd(argv[0], argv[1], argv[2], argc - 3, argv + 3, false);

    return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-register_odd_raw" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            register_odd_raw(clas, create_object, create_method, dump_method)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Registers a class as special and expect the output to be a string that can
be included in the dumped <a href="JSON.html">JSON</a> directly. This is
useful for working around subclasses of primitive types as is done with <a
href="ActiveSupport.html">ActiveSupport</a> classes. The use of this
function should be limited to just classes that can not be handled in the
normal way. It is not intended as a hook for changing the output of all
classes as it is not optimized for large numbers of classes. Be careful
with this option as the <a href="JSON.html">JSON</a> may be incorrect if
invalid <a href="JSON.html">JSON</a> is returned.</p>
<ul><li>
<p><strong>clas</strong> [<em>Class</em>|<em>Module</em>] <a
href="Class.html">Class</a> or <a href="Module.html">Module</a> to be made
special</p>
</li><li>
<p><strong>create_object</strong> [<em>Object</em>] object to call the create
method on</p>
</li><li>
<p><strong>create_method</strong> [<em>Symbol</em>] method on the clas that
will create a new instance of the clas when given all the member values in
the order specified.</p>
</li><li>
<p><strong>dump_method</strong> [<em>Symbol</em>|<em>String</em>] method to
call on the object being serialized to generate the raw <a
href="JSON.html">JSON</a>.</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="register_odd_raw-source">
            <pre>static VALUE
register_odd_raw(int argc, VALUE *argv, VALUE self) {
    if (3 &gt; argc) {
        rb_raise(rb_eArgError, &quot;incorrect number of arguments.&quot;);
    }
    switch (rb_type(*argv)) {
    case T_CLASS:
    case T_MODULE:
        break;
    default:
        rb_raise(rb_eTypeError, &quot;expected a class or module.&quot;);
        break;
    }
    Check_Type(argv[2], T_SYMBOL);
    if (MAX_ODD_ARGS &lt; argc - 2) {
        rb_raise(rb_eArgError, &quot;too many members.&quot;);
    }
    oj_reg_odd(argv[0], argv[1], argv[2], 1, argv + 3, true);

    return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-safe_load" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            safe_load(doc)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Loads a <a href="JSON.html">JSON</a> document in strict mode with
:auto_define and :symbol_keys turned off. This function should be safe to
use with <a href="JSON.html">JSON</a> received on an unprotected public
interface.</p>
<ul><li>
<p><strong>doc</strong> [<em>String_</em>|<em>IO</em>] <a
href="JSON.html">JSON</a> <a href="String.html">String</a> or IO to load.</p>
</li></ul>

<p>Returns
[<em>Hash</em>|<em>Array</em>|<em>String</em>|<em>Fixnum</em>|<em>Bignum</em>|<em>BigDecimal</em>|<em>nil</em>|<em>True</em>|<em>False</em>]</p>
          
          

          
          <div class="method-source-code" id="safe_load-source">
            <pre>static VALUE
safe_load(VALUE self, VALUE doc) {
    struct _ParseInfo   pi;
    VALUE               args[1];

    parse_info_init(&amp;pi);
    pi.err_class = Qnil;
    pi.max_depth = 0;
    pi.options = oj_default_options;
    pi.options.auto_define = No;
    pi.options.sym_key = No;
    pi.options.mode = StrictMode;
    oj_set_strict_callbacks(&amp;pi);
    *args = doc;

    return oj_pi_parse(1, args, &amp;pi, 0, 0, 1);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-saj_parse" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            saj_parse(handler, io)
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Parses an IO stream or file containing a <a href="JSON.html">JSON</a>
document. Raises an exception if the <a href="JSON.html">JSON</a> is
malformed. This is a callback parser that calls the methods in the handler
if they exist. A sample is the <a href="Oj/Saj.html">Oj::Saj</a> class
which can be used as a base class for the handler.</p>
<ul><li>
<p><strong>handler</strong> [<em>Oj::Saj</em>] responds to <a
href="Oj/Saj.html">Oj::Saj</a> methods</p>
</li><li>
<p><strong>io</strong> [<em>IO</em>|<em>String</em>] IO <a
href="Object.html">Object</a> to read from</p>
</li></ul>
          
          

          
        </div>

        

        
      </div>

    
      <div id="method-c-sc_parse" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sc_parse(handler, io)
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Parses an IO stream or file containing a <a href="JSON.html">JSON</a>
document. Raises an exception if the <a href="JSON.html">JSON</a> is
malformed. This is a callback parser (Simple Callback <a
href="Parser.html">Parser</a>) that calls the methods in the handler if
they exist. A sample is the <a href="Oj/ScHandler.html">Oj::ScHandler</a>
class which can be used as a base class for the handler. This callback
parser is slightly more efficient than the <a href="Oj/Saj.html">Saj</a>
callback parser and requires less argument checking.</p>
<ul><li>
<p><strong>handler</strong> [<em>Oj</em>::ScHandler_] responds to <a
href="Oj/ScHandler.html">Oj::ScHandler</a> methods</p>
</li><li>
<p><strong>io</strong> [<em>IO_</em>|<em>String</em>] IO <a
href="Object.html">Object</a> to read from</p>
</li></ul>
          
          

          
        </div>

        

        
      </div>

    
      <div id="method-c-strict_load" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            strict_load(json, options) { _|_obj, start, len_|_ }
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Parses a <a href="JSON.html">JSON</a> document <a
href="String.html">String</a> into an <a href="Hash.html">Hash</a>, <a
href="Array.html">Array</a>, <a href="String.html">String</a>, Fixnum, <a
href="Float.html">Float</a>, true, false, or nil. It parses using a mode
that is strict in that it maps each primitive <a href="JSON.html">JSON</a>
type to a similar Ruby type. The :create_id is not honored in this mode.
Note that a Ruby <a href="Hash.html">Hash</a> is used to represent the <a
href="JSON.html">JSON</a> <a href="Object.html">Object</a> type. These two
are not the same since the <a href="JSON.html">JSON</a> <a
href="Object.html">Object</a> type can have repeating entries with the same
key and Ruby <a href="Hash.html">Hash</a> can not.</p>

<p>When used with a document that has multiple <a href="JSON.html">JSON</a>
elements the block, if any, will be yielded to. If no block then the last
element read will be returned.</p>

<p>Raises an exception if the <a href="JSON.html">JSON</a> is malformed or the
classes specified are not valid. If the input is not a valid <a
href="JSON.html">JSON</a> document (an empty string is not a valid <a
href="JSON.html">JSON</a> document) an exception is raised.</p>

<p>A block can be provided with a single argument. That argument will be the
parsed <a href="JSON.html">JSON</a> document. This is useful when parsing a
string that includes multiple <a href="JSON.html">JSON</a> documents. The
block can take up to 3 arguments, the parsed object, the position in the
string or stream of the start of the <a href="JSON.html">JSON</a> for that
object, and the length of the <a href="JSON.html">JSON</a> for that object
plus trailing whitespace.</p>
<ul><li>
<p><strong>json</strong> [<em>String</em>|<em>IO</em>] <a
href="JSON.html">JSON</a> <a href="String.html">String</a> or an <a
href="Object.html">Object</a> that responds to read().</p>
</li><li>
<p><strong>options</strong> [<em>Hash</em>] load options (same as <a
href="Oj.html#method-c-default_options">::default_options</a>).</p>
<ul><li>
<p>-</p>
</li></ul>
</li><li>
<p><strong>obj</strong>
[<em>Hash</em>|<em>Array</em>|<em>String</em>|<em>Fixnum</em>|<em>Float</em>|<em>Boolean</em>|<em>nil</em>]
parsed object.</p>
</li><li>
<p><strong>start</strong> [_optional, <em>Integer</em>] start position of
parsed <a href="JSON.html">JSON</a> for obj.</p>
</li><li>
<p><strong>len</strong> [_optional, <em>Integer</em>] length of parsed <a
href="JSON.html">JSON</a> for obj.</p>
</li></ul>

<p>Returns
[<em>Hash</em>|<em>Array</em>|<em>String</em>|<em>Fixnum</em>|<em>Float</em>|<em>Boolean</em>|<em>nil</em>]</p>
          
          

          
        </div>

        

        
      </div>

    
      <div id="method-c-to_file" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_file(file_path, obj, options)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Dumps an <a href="Object.html">Object</a> to the specified file.</p>
<ul><li>
<p><strong>file</strong> [<em>String</em>] _path file path to write the <a
href="JSON.html">JSON</a> document to</p>
</li><li>
<p><strong>obj</strong> [<em>Object</em>] <a href="Object.html">Object</a> to
serialize as an <a href="JSON.html">JSON</a> document <a
href="String.html">String</a></p>
</li><li>
<p><strong>options</strong> [<em>Hash</em>] formating options</p>
<ul><li>
<p><strong>:indent</strong> [<em>Fixnum</em>] format expected</p>
</li><li>
<p><strong>:circular</strong> [<em>Boolean</em>] allow circular references,
default: false</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="to_file-source">
            <pre>static VALUE
to_file(int argc, VALUE *argv, VALUE self) {
    struct _Options     copts = oj_default_options;
    
    if (3 == argc) {
        oj_parse_options(argv[2], &amp;copts);
    }
    Check_Type(*argv, T_STRING);
    oj_write_obj_to_file(argv[1], StringValuePtr(*argv), &amp;copts);

    return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-to_json" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_json(obj, options)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Dumps an <a href="Object.html">Object</a> (obj) to a string. If the object
has a <a href="Oj.html#method-c-to_json">::to_json</a> method that will be
called. The mode is set to :compat.</p>
<ul><li>
<p><strong>obj</strong> [<em>Object</em>] <a href="Object.html">Object</a> to
serialize as an <a href="JSON.html">JSON</a> document <a
href="String.html">String</a></p>
</li><li>
<p><strong>options</strong> [<em>Hash</em>]</p>
<ul><li>
<p><strong>:max_nesting</strong> [<em>boolean</em>] It true nesting is limited
to 100. The option to detect circular references is available but is not
compatible with the json gem., default is false</p>
</li><li>
<p><strong>:allow_nan</strong> [<em>boolean</em>] If true non <a
href="JSON.html">JSON</a> compliant words such as Nan and Infinity will be
used as appropriate, default is true.</p>
</li><li>
<p><strong>:quirks_mode</strong> [<em>boolean</em>] Allow single <a
href="JSON.html">JSON</a> values instead of documents, default is true
(allow).</p>
</li><li>
<p><strong>:indent</strong> [<em>String</em>|<em>nil</em>] <a
href="String.html">String</a> to use for indentation, overriding the indent
option if not nil.</p>
</li><li>
<p><strong>:space</strong> [<em>String</em>|<em>nil</em>] <a
href="String.html">String</a> to use for the space after the colon in <a
href="JSON.html">JSON</a> object fields.</p>
</li><li>
<p><strong>:space_before</strong> [<em>String</em>|<em>nil</em>] <a
href="String.html">String</a> to use before the colon separator in <a
href="JSON.html">JSON</a> object fields.</p>
</li><li>
<p><strong>:object_nl</strong> [<em>String</em>|<em>nil</em>] <a
href="String.html">String</a> to use after a <a href="JSON.html">JSON</a>
object field value.</p>
</li><li>
<p><strong>:array_nl</strong> [<em>String</em>|<em>nil</em>] <a
href="String.html">String</a> to use after a <a href="JSON.html">JSON</a>
array value.</p>
</li></ul>
</li></ul>

<p>Returns [<em>String</em>] the encoded <a href="JSON.html">JSON</a>.</p>
          
          

          
          <div class="method-source-code" id="to_json-source">
            <pre>static VALUE
to_json(int argc, VALUE *argv, VALUE self) {
    char                buf[4096];
    struct _Out         out;
    struct _Options     copts = oj_default_options;
    VALUE               rstr;

    if (1 &gt; argc) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (0 for 1).&quot;);
    }
    copts.escape_mode = JXEsc;
    copts.dump_opts.nan_dump = RaiseNan;
    if (2 == argc) {
        oj_parse_mimic_dump_options(argv[1], &amp;copts);
    }
    copts.mode = CompatMode;
    copts.to_json = Yes;
    out.buf = buf;
    out.end = buf + sizeof(buf) - 10;
    out.allocated = false;
    out.omit_nil = copts.dump_opts.omit_nil;
    // For obj.to_json or generate nan is not allowed but if called from dump
    // it is.
    oj_dump_obj_to_json_using_params(*argv, &amp;copts, &amp;out, argc - 1, argv + 1);

    if (0 == out.buf) {
        rb_raise(rb_eNoMemError, &quot;Not enough memory.&quot;);
    }
    rstr = rb_str_new2(out.buf);
    rstr = oj_encode(rstr);
    if (out.allocated) {
        xfree(out.buf);
    }
    return rstr;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-to_stream" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_stream(io, obj, options)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Dumps an <a href="Object.html">Object</a> to the specified IO stream.</p>
<ul><li>
<p><strong>io</strong> [<em>IO</em>] IO stream to write the <a
href="JSON.html">JSON</a> document to</p>
</li><li>
<p><strong>obj</strong> [<em>Object</em>] <a href="Object.html">Object</a> to
serialize as an <a href="JSON.html">JSON</a> document <a
href="String.html">String</a></p>
</li><li>
<p><strong>options</strong> [<em>Hash</em>] formating options</p>
<ul><li>
<p><strong>:indent</strong> [<em>Fixnum</em>] format expected</p>
</li><li>
<p><strong>:circular</strong> [<em>Boolean</em>] allow circular references,
default: false</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="to_stream-source">
            <pre>static VALUE
to_stream(int argc, VALUE *argv, VALUE self) {
    struct _Options     copts = oj_default_options;
    
    if (3 == argc) {
        oj_parse_options(argv[2], &amp;copts);
    }
    oj_write_obj_to_stream(argv[1], *argv, &amp;copts);

    return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-wab_load" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            wab_load(json, options) { _|_obj, start, len_|_ }
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Parses a <a href="JSON.html">JSON</a> document <a
href="String.html">String</a> into an <a href="Hash.html">Hash</a>, <a
href="Array.html">Array</a>, <a href="String.html">String</a>, Fixnum, <a
href="Float.html">Float</a>, true, false, or nil. It parses using a mode
that is :wab in that it maps each primitive <a href="JSON.html">JSON</a>
type to a similar Ruby type. The :create_id is not honored in this mode.
Note that a Ruby <a href="Hash.html">Hash</a> is used to represent the <a
href="JSON.html">JSON</a> <a href="Object.html">Object</a> type. These two
are not the same since the <a href="JSON.html">JSON</a> <a
href="Object.html">Object</a> type can have repeating entries with the same
key and Ruby <a href="Hash.html">Hash</a> can not.</p>

<p>When used with a document that has multiple <a href="JSON.html">JSON</a>
elements the block, if any, will be yielded to. If no block then the last
element read will be returned.</p>

<p>Raises an exception if the <a href="JSON.html">JSON</a> is malformed or the
classes specified are not valid. If the input is not a valid <a
href="JSON.html">JSON</a> document (an empty string is not a valid <a
href="JSON.html">JSON</a> document) an exception is raised.</p>

<p>A block can be provided with a single argument. That argument will be the
parsed <a href="JSON.html">JSON</a> document. This is useful when parsing a
string that includes multiple <a href="JSON.html">JSON</a> documents. The
block can take up to 3 arguments, the parsed object, the position in the
string or stream of the start of the <a href="JSON.html">JSON</a> for that
object, and the length of the <a href="JSON.html">JSON</a> for that object
plus trailing whitespace.</p>
<ul><li>
<p><strong>json</strong> [<em>String</em>|<em>IO</em>] <a
href="JSON.html">JSON</a> <a href="String.html">String</a> or an <a
href="Object.html">Object</a> that responds to read().</p>
</li><li>
<p><strong>options</strong> [<em>Hash</em>] load options (same as <a
href="Oj.html#method-c-default_options">::default_options</a>).</p>
<ul><li>
<p>-</p>
</li></ul>
</li><li>
<p><strong>obj</strong>
[<em>Hash</em>|<em>Array</em>|<em>String</em>|<em>Fixnum</em>|<em>Float</em>|<em>Boolean</em>|<em>nil</em>]
parsed object.</p>
</li><li>
<p><strong>start</strong> [_optional, <em>Integer</em>] start position of
parsed <a href="JSON.html">JSON</a> for obj.</p>
</li><li>
<p><strong>len</strong> [_optional, <em>Integer</em>] length of parsed <a
href="JSON.html">JSON</a> for obj.</p>
</li></ul>

<p>Returns
[<em>Hash</em>|<em>Array</em>|<em>String</em>|<em>Fixnum</em>|<em>Float</em>|<em>Boolean</em>|<em>nil</em>]</p>
          
          

          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-as_json" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">as_json</span><span
            class="method-args">(*)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="as_json-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/2.4.0/gems/oj-3.4.0/lib/oj/mimic.rb, line 56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">as_json</span>(<span class="ruby-operator">*</span>)
  <span class="ruby-identifier">name</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">to_s</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">JSON</span><span class="ruby-operator">::</span><span class="ruby-constant">JSONError</span>, <span class="ruby-string">&quot;Only named structs are supported!&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-value">0</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">length</span>
  { <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">name</span>, <span class="ruby-string">&#39;t&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">table</span> }
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://rdoc.github.io/rdoc">RDoc</a> 5.0.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

